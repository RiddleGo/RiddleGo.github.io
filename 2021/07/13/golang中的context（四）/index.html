<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="golang中的context（四）"/>




  <meta name="keywords" content="golang,面试,context," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/07/13/golang中的context（四）/"/>


<meta name="description" content="前言：最近在学协程，看见资料说在复杂的网络高并发环境，channel是难以满足我们的使用要求，需要用到context，以前我也看见这个万一，看来真的很重要，于是就学习两篇很厉害的blog学习一下。 https:&#x2F;&#x2F;studygolang.com&#x2F;articles&#x2F;9517https:&#x2F;&#x2F;leileiluoluo.com&#x2F;posts&#x2F;golang-context.html 正文简介golang 中的">
<meta property="og:type" content="article">
<meta property="og:title" content="golang中的context（四）">
<meta property="og:url" content="https://riddlego.github.io/2021/07/13/golang%E4%B8%AD%E7%9A%84context%EF%BC%88%E5%9B%9B%EF%BC%89/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="前言：最近在学协程，看见资料说在复杂的网络高并发环境，channel是难以满足我们的使用要求，需要用到context，以前我也看见这个万一，看来真的很重要，于是就学习两篇很厉害的blog学习一下。 https:&#x2F;&#x2F;studygolang.com&#x2F;articles&#x2F;9517https:&#x2F;&#x2F;leileiluoluo.com&#x2F;posts&#x2F;golang-context.html 正文简介golang 中的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-13T11:19:30.000Z">
<meta property="article:modified_time" content="2021-07-13T11:20:14.904Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="context">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> golang中的context（四） - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          golang中的context（四）
        
      </h1>

      <time class="post-time">
          7月 13 2021
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近在学协程，看见资料说在复杂的网络高并发环境，channel是难以满足我们的使用要求，需要用到context，以前我也看见这个万一，看来真的很重要，于是就学习两篇很厉害的blog学习一下。</p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/9517">https://studygolang.com/articles/9517</a><br><a target="_blank" rel="noopener" href="https://leileiluoluo.com/posts/golang-context.html">https://leileiluoluo.com/posts/golang-context.html</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>golang 中的创建一个新的 goroutine , 并不会返回像c语言类似的pid，<br>所有我们不能从外部杀死某个goroutine，所有我就得让它自己结束，<br>之前我们用 channel ＋ select 的方式，来解决这个问题，但是有些场景实现起来比较麻烦，<br>例如由一个请求衍生出的各个 goroutine 之间需要满足一定的约束关系，<br>以实现一些诸如有效期，中止routine树，传递请求全局变量之类的功能。<br>于是google 就为我们提供一个解决方案，开源了 context 包。<br>使用 context 实现上下文功能约定需要在你的方法的传入参数的第一个<br>传入一个 context.Context 类型的变量。</p>
<h4 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h4><p>我们知道，在Go服务端，每个进入的请求会被其所属goroutine处理。</p>
<p>例如，如下代码，每次请求，<strong>Handler会创建一个goroutine来为其提供服务</strong>，而且连续请求3次，r的地址也是不同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net&#x2F;http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;&#x2F;echo&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Println(&amp;r)</span><br><span class="line">        w.Write([]byte(&quot;hello&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost:8080&#x2F;echo</span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost:8080&#x2F;echo</span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost:8080&#x2F;echo</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xc000072040</span><br><span class="line">0xc000072048</span><br><span class="line">0xc000072050</span><br></pre></td></tr></table></figure>
<p>而每个请求对应的Handler，常会启动额外的的goroutine进行数据查询或PRC调用等。</p>
<p>而当请求返回时，这些额外创建的goroutine需要及时回收。<br>而且，一个请求对应一组请求域内的数据可能会被该请求调用链条内的各goroutine所需要。</p>
<p>例如，在如下代码中，当请求进来时，<br>Handler会创建一个监控goroutine，其会每隔1s打印一句“req is processing”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net&#x2F;http&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;&#x2F;echo&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        &#x2F;&#x2F; monitor</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for range time.Tick(time.Second) &#123;</span><br><span class="line">                fmt.Println(&quot;req is processing&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; assume req processing takes 3s</span><br><span class="line">        time.Sleep(3 * time.Second)</span><br><span class="line">        w.Write([]byte(&quot;hello&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假定请求需耗时3s，即请求在3s后返回，我们期望监控goroutine在打印3次“req is processing”后即停止。</p>
<p>但运行发现，监控goroutine打印3次后，其仍不会结束，而会一直打印下去。</p>
<p><strong>问题出在创建监控goroutine后</strong>，<strong>未对其生命周期作控制</strong>，<strong>下面我们使用context作一下控制</strong>，即监控程序打印前需检测r.Context()是否已经结束，若结束则退出循环，即结束生命周期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net&#x2F;http&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;&#x2F;echo&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        &#x2F;&#x2F; monitor</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for range time.Tick(time.Second) &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-r.Context().Done():</span><br><span class="line">                    fmt.Println(&quot;req is outgoing&quot;)</span><br><span class="line">                    return</span><br><span class="line">                default:</span><br><span class="line">                    fmt.Println(&quot;req is processing&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; assume req processing takes 3s</span><br><span class="line">        time.Sleep(3 * time.Second)</span><br><span class="line">        w.Write([]byte(&quot;hello&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于如上需求，context包应用而生。</p>
<p>context包可以提供一个请求从API请求边界到各goroutine的请求域数据传递、取消信号及截至时间等能力。</p>
<h4 id="2-Context类型"><a href="#2-Context类型" class="headerlink" title="2 Context类型"></a>2 Context类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A Context carries a deadline, cancelation signal, and request-scoped values</span><br><span class="line">&#x2F;&#x2F; across API boundaries. Its methods are safe for simultaneous use by multiple</span><br><span class="line">&#x2F;&#x2F; goroutines.</span><br><span class="line">type Context interface &#123;</span><br><span class="line">    &#x2F;&#x2F; Done returns a channel that is closed when this Context is canceled</span><br><span class="line">    &#x2F;&#x2F; or times out.</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Err indicates why this context was canceled, after the Done channel</span><br><span class="line">    &#x2F;&#x2F; is closed.</span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deadline returns the time when this Context will be canceled, if any.</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Value returns the value associated with key or nil if none.</span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done方法返回一个channel，当Context取消或到达截至时间时，该channel即会关闭。Err方法返回Context取消的原因。</p>
<p><strong>Context自己没有Cancel方法，而且Done channel仅用来接收信号：接收取消信号的函数不应同时是发送取消信号的函数。父goroutine启动子goroutine来做一些子操作，而子goroutine不应用来取消父goroutine。</strong></p>
<p><strong>Context是安全的，可被多个goroutine同时使用。一个Context可以传给多个goroutine，而且可以给所有这些goroutine发取消信号。</strong></p>
<p>若有截至时间，Deadline方法可以返回该Context的取消时间。</p>
<p><strong>Value允许Context携带请求域内的数据，该数据访问必须保障多个goroutine同时访问的安全性。</strong></p>
<h4 id="衍生Context"><a href="#衍生Context" class="headerlink" title="衍生Context"></a>衍生Context</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Background returns an empty Context. It is never canceled, has no deadline,</span><br><span class="line">&#x2F;&#x2F; and has no values. Background is typically used in main, init, and tests,</span><br><span class="line">&#x2F;&#x2F; and as the top-level Context for incoming requests.</span><br><span class="line">func Background() Context</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WithCancel returns a copy of parent whose Done channel is closed as soon as</span><br><span class="line">&#x2F;&#x2F; parent.Done is closed or cancel is called.</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A CancelFunc cancels a Context.</span><br><span class="line">type CancelFunc func()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A CancelFunc cancels a Context.</span><br><span class="line">type CancelFunc func()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WithTimeout returns a copy of parent whose Done channel is closed as soon as</span><br><span class="line">&#x2F;&#x2F; parent.Done is closed, cancel is called, or timeout elapses. The new</span><br><span class="line">&#x2F;&#x2F; Context&#39;s Deadline is the sooner of now+timeout and the parent&#39;s deadline, if</span><br><span class="line">&#x2F;&#x2F; any. If the timer is still running, the cancel function releases its</span><br><span class="line">&#x2F;&#x2F; resources.</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WithValue returns a copy of parent whose Value method returns val for key.</span><br><span class="line">func WithValue(parent Context, key interface&#123;&#125;, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure>

<p>context包提供从已有Context衍生新的Context的能力。这样即可形成一个Context树，<br><strong>当父Context取消时，所有从其衍生出来的子Context亦会被取消。</strong></p>
<p><strong>Background是所有Context树的根，其永远不会被取消。</strong></p>
<p>使用WithCancel及WithTimeout可以<strong>创建衍生的Context，WithCancel可用来取消一组从其衍生的goroutine，WithTimeout可用来设置截至时间。</strong></p>
<p><strong>WithValue提供给Context赋予请求域数据的能力。</strong></p>
<p>下面来看几个对如上方法使用的例子。</p>
<h5 id="1）首先，看一下WitchCancel的使用。"><a href="#1）首先，看一下WitchCancel的使用。" class="headerlink" title="1）首先，看一下WitchCancel的使用。"></a>1）首先，看一下WitchCancel的使用。</h5><p>在如下代码中，<strong>main函数使用WithCancel创建一个基于Background的ctx</strong>。</p>
<p>然后启动一个monitor goroutine，该monitor每隔1s打印一句“monitor woring”，</p>
<p>main函数在3s后执行cancel，那么monitor检测到取消信号后即会退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx, cancel :&#x3D; context.WithCancel(context.Background())</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; monitor</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for range time.Tick(time.Second) &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-ctx.Done():</span><br><span class="line">                return</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(&quot;monitor woring&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(3 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）再看一个使用WithTimeout的例子，"><a href="#2）再看一个使用WithTimeout的例子，" class="headerlink" title="2）再看一个使用WithTimeout的例子，"></a>2）再看一个使用WithTimeout的例子，</h5><p>如下代码中使用WithTimeout创建一个基于Background的ctx，其会在3s后取消。</p>
<p>注意，虽然到截至时间会自动cancel，但cancel代码仍建议加上。</p>
<p>到截至时间而被取消还是被cancel代码所取消，取决于哪个信号发送的早。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 3*time.Second)</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-time.After(4 * time.Second):</span><br><span class="line">        fmt.Println(&quot;overslept&quot;)</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WithDeadline的使用与WithTimeout相似。</p>
<p><strong>没想好Context的具体使用，可以使用TODO来占位，也便于工具作正确性检查。</strong></p>
<h5 id="3）最后看一下WithValue的使用。"><a href="#3）最后看一下WithValue的使用。" class="headerlink" title="3）最后看一下WithValue的使用。"></a>3）最后看一下WithValue的使用。</h5><p>如下代码基于Background创建一个带值的ctx，然后可以根据key来取值。</p>
<p><strong>注意：避免多个包同时使用context而带来冲突，key不建议使用string或其他内置类型，而建议自定义key类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ctxKey string</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx :&#x3D; context.WithValue(context.Background(), ctxKey(&quot;a&quot;), &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">    get :&#x3D; func(ctx context.Context, k ctxKey) &#123;</span><br><span class="line">        if v, ok :&#x3D; ctx.Value(k).(string); ok &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    get(ctx, ctxKey(&quot;a&quot;))</span><br><span class="line">    get(ctx, ctxKey(&quot;b&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后列一下Context使用规则："><a href="#最后列一下Context使用规则：" class="headerlink" title="最后列一下Context使用规则："></a>最后列一下Context使用规则：</h4><p>a）勿将Context作为struct的字段使用，<strong>而是对每个使用其的函数分别作参数使用，其需定义为函数或方法的第一个参数，一般叫作ctx；</strong></p>
<p>b）勿对Context参数传nil，未想好的使用那个Context，请传context.TODO；</p>
<p><strong>c）使用context传值仅可用作请求域的数据，其它类型数据请不要滥用；</strong></p>
<p>d）同一个Context可以传给使用其的多个goroutine，且Context可被多个goroutine同时安全访问。</p>
<h4 id="最后再重复一边剖析源码"><a href="#最后再重复一边剖析源码" class="headerlink" title="最后再重复一边剖析源码"></a>最后再重复一边剖析源码</h4><p>context.Context 接口</p>
<p>context 包的核心</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  context 包里的方法是线程安全的，可以被多个 goroutine 使用    </span><br><span class="line">type Context interface &#123;               </span><br><span class="line">    &#x2F;&#x2F; 当Context 被 canceled 或是 times out 的时候，Done 返回一个被 closed 的channel      </span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;        </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在 Done 的 channel被closed 后， Err 代表被关闭的原因   </span><br><span class="line">    Err() error </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果存在，Deadline 返回Context将要关闭的时间  </span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果存在，Value 返回与 key 相关了的值，不存在返回 nil  </span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不需要手动实现这个接口，context 包已经给我们提供了两个，<br>一个是 Background()，一个是 TODO()，这两个函数都会返回一个 Context 的实例。<br>只是返回的这两个实例都是空 Context。</p>
<h5 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h5><p>cancelCtx 结构体继承了 Context ，实现了 canceler 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;*cancelCtx 和 *timerCtx 都实现了canceler接口，实现该接口的类型都可以被直接canceled</span><br><span class="line">type canceler interface &#123;</span><br><span class="line">    cancel(removeFromParent bool, err error)</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">type cancelCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line">    done chan struct&#123;&#125; &#x2F;&#x2F; closed by the first cancel call.</span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children map[canceler]bool &#x2F;&#x2F; set to nil by the first cancel call</span><br><span class="line">    err      error             &#x2F;&#x2F; 当其被cancel时将会把err设置为非nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">    return c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) Err() error &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    defer c.mu.Unlock()</span><br><span class="line">    return c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%v.WithCancel&quot;, c.Context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;核心是关闭c.done</span><br><span class="line">&#x2F;&#x2F;同时会设置c.err &#x3D; err, c.children &#x3D; nil</span><br><span class="line">&#x2F;&#x2F;依次遍历c.children，每个child分别cancel</span><br><span class="line">&#x2F;&#x2F;如果设置了removeFromParent，则将c从其parent的children中删除</span><br><span class="line">func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        panic(&quot;context: internal error: missing cancel error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    if c.err !&#x3D; nil &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        return &#x2F;&#x2F; already canceled</span><br><span class="line">    &#125;</span><br><span class="line">    c.err &#x3D; err</span><br><span class="line">    close(c.done)</span><br><span class="line">    for child :&#x3D; range c.children &#123;</span><br><span class="line">        &#x2F;&#x2F; NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.</span><br><span class="line">        child.cancel(false, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children &#x3D; nil</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    if removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c) &#x2F;&#x2F; 从此处可以看到 cancelCtx的Context项是一个类似于parent的概念</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timerCtx 结构继承 cancelCtx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type timerCtx struct &#123;</span><br><span class="line">    cancelCtx &#x2F;&#x2F;此处的封装为了继承来自于cancelCtx的方法，cancelCtx.Context才是父亲节点的指针</span><br><span class="line">    timer *time.Timer &#x2F;&#x2F; Under cancelCtx.mu. 是一个计时器</span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueCtx 结构继承 cancelCtx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type valueCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithValue(parent Context, key interface&#123;&#125;, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure>

<p>WithCancel 对应的是 cancelCtx ,其中，返回一个 cancelCtx ，<br>同时返回一个 CancelFunc，<br>CancelFunc 是 context 包中定义的一个函数类型：type CancelFunc func()。<br><strong>调用这个 CancelFunc 时，关闭对应的c.done，也就是让他的后代goroutine退出。</strong></p>
<p>WithDeadline 和 WithTimeout 对应的是 timerCtx ，WithDeadline 和 WithTimeout 是相似的，<br><strong>WithDeadline 是设置具体的 deadline 时间，到达 deadline 的时候，后代 goroutine 退出，</strong><br><strong>而 WithTimeout 简单粗暴，直接 return WithDeadline(parent, time.Now().Add(timeout))。</strong></p>
<p>WithValue 对应 valueCtx ，WithValue 是在 Context 中设置一个 map，<br><strong>拿到这个 Context 以及它的后代的 goroutine 都可以拿到 map 里的值。</strong></p>
<p>详细 context 包源码解读:go源码解读</p>
<h4 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h4><p>使用 Context 的程序包需要遵循如下的原则来满足接口的一致性以及便于静态分析</p>
<p>不要把 Context 存在一个结构体当中，显式地传入函数。Context 变量需要作为第一个参数使用，一般命名为ctx</p>
<p>即使方法允许，也不要传入一个 nil 的 Context ，如果你不确定你要用什么 Context 的时候传一个 context.TODO</p>
<p>使用 context 的 Value 相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数</p>
<p>同样的 Context 可以用来传递到不同的 goroutine 中，Context 在多个goroutine 中是安全的</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>例子copy自: <a target="_blank" rel="noopener" href="https://github.com/eleme/sre/blob/master/context.md">关于 Golang 中的 context 包的介绍</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;golang.org&#x2F;x&#x2F;net&#x2F;context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟一个最小执行时间的阻塞函数</span><br><span class="line">func inc(a int) int &#123;</span><br><span class="line">    res :&#x3D; a + 1                &#x2F;&#x2F; 虽然我只做了一次简单的 +1 的运算,</span><br><span class="line">    time.Sleep(1 * time.Second) &#x2F;&#x2F; 但是由于我的机器指令集中没有这条指令,</span><br><span class="line">    &#x2F;&#x2F; 所以在我执行了 1000000000 条机器指令, 续了 1s 之后, 我才终于得到结果。B)</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向外部提供的阻塞接口</span><br><span class="line">&#x2F;&#x2F; 计算 a + b, 注意 a, b 均不能为负</span><br><span class="line">&#x2F;&#x2F; 如果计算被中断, 则返回 -1</span><br><span class="line">func Add(ctx context.Context, a, b int) int &#123;</span><br><span class="line">    res :&#x3D; 0</span><br><span class="line">    for i :&#x3D; 0; i &lt; a; i++ &#123;</span><br><span class="line">        res &#x3D; inc(res)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            return -1</span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; b; i++ &#123;</span><br><span class="line">        res &#x3D; inc(res)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            return -1</span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用开放的 API 计算 a+b</span><br><span class="line">        a :&#x3D; 1</span><br><span class="line">        b :&#x3D; 2</span><br><span class="line">        timeout :&#x3D; 2 * time.Second</span><br><span class="line">        ctx, _ :&#x3D; context.WithTimeout(context.Background(), timeout)</span><br><span class="line">        res :&#x3D; Add(ctx, 1, 2)</span><br><span class="line">        fmt.Printf(&quot;Compute: %d+%d, result: %d\n&quot;, a, b, res)</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 手动取消</span><br><span class="line">        a :&#x3D; 1</span><br><span class="line">        b :&#x3D; 2</span><br><span class="line">        ctx, cancel :&#x3D; context.WithCancel(context.Background())</span><br><span class="line">        go func() &#123;</span><br><span class="line">            time.Sleep(2 * time.Second)</span><br><span class="line">            cancel() &#x2F;&#x2F; 在调用处主动取消</span><br><span class="line">        &#125;()</span><br><span class="line">        res :&#x3D; Add(ctx, 1, 2)</span><br><span class="line">        fmt.Printf(&quot;Compute: %d+%d, result: %d\n&quot;, a, b, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/golang/">golang</a>
		  
			<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
		  
			<a href="/tags/context/">context</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/07/13/golang%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88%E4%BA%94%EF%BC%89/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">golang的编码规范（五）</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/07/13/golang%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/">
        <span class="next-text nav-default">golang并发与多线程（三）</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
