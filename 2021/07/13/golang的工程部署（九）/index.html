<!DOCTYPE html>
<html>

	<head>
		
<title>golang的工程部署（九）-Russshare</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">


<meta name="keywords" content="golang,docker,部署,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4b5fe1472f22fa";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">
</head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Russshare</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg ">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/golang">golang</a></li>
            
            <li><a href="/tags/docker">docker</a></li>
            
            <li><a href="/tags/部署">部署</a></li>
            
            
        </ul>
        <h1>golang的工程部署（九）</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                    <g>
                        <path fill="#12183A"
                            d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                        </path>
                    </g>
                </svg>
                
                <span> <a href="">Russshare</a></span>
                <p>2021-07-13 19:23:08</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h3 id="前言：文章转自李文周的blog"><a href="#前言：文章转自李文周的blog" class="headerlink" title="前言：文章转自李文周的blog"></a>前言：文章转自李文周的blog</h3><p>这位前辈的blog的干货太多了，真的大家一定要好好去研读一下blog<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/deploy_go_app/">文章</a><br>(本文没有图片，只是相当于记笔记一样，边复制边实践，边阅读。)<br>(为了最好的阅读体验，移步<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/deploy_go_app/">原文</a>)<br>(为了最好的阅读体验，移步<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/deploy_go_app/">原文</a>)<br>(为了最好的阅读体验，移步<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/deploy_go_app/">原文</a>)</p>
<p>本文以部署 Go Web 程序为例，介绍了在 CentOS7 服务器上部署 Go 语言程序的若干方法。</p>
<h2 id="部署Go语言项目"><a href="#部署Go语言项目" class="headerlink" title="部署Go语言项目"></a>部署Go语言项目</h2><p>本文以部署 Go Web 程序为例，介绍了在 CentOS7 服务器上部署 Go 语言程序的若干方法。</p>
<h3 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h3><p><strong>Go 语言支持跨平台交叉编译，</strong>也就是说我们可以在 Windows 或 Mac 平台下编写代码，并且将代码编译成能够在 Linux amd64 服务器上运行的程序。</p>
<p><strong>对于简单的项目，通常我们只需要将编译后的二进制文件拷贝到服务器上，然后设置为后台守护进程运行即可。</strong></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译可以通过以下命令或编写 makefile 来操作。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build -o ./bin/bluebell<br></code></pre></td></tr></table></figure>

<p>下面假设我们将本地编译好的 bluebell 二进制文件、配置文件和静态文件等上传到服务器的/data/app/bluebell目录下。</p>
<p>补充一点，如果嫌弃编译后的二进制文件太大，可以在编译的时候加上-ldflags “-s -w”参数去掉符号表和调试信息，一般能减小20%的大小。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build -ldflags <span class="hljs-string">&quot;-s -w&quot;</span> -o ./bin/bluebell<br><br></code></pre></td></tr></table></figure>
<p>如果还是嫌大的话可以继续使用 upx 工具对二进制可执行文件进行压缩。</p>
<p>我们编译好 bluebell 项目后，相关必要文件的目录结构如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">├── bin<br>│   └── bluebell<br>├── conf<br>│   └── config.yaml<br>├── static<br>│   ├── css<br>│   │   └── app.<span class="hljs-number">0</span>afe9dae.css<br>│   ├── favicon.ico<br>│   ├── img<br>│   │   ├── avatar.<span class="hljs-number">7</span>b0a9835.png<br>│   │   ├── iconfont<span class="hljs-selector-class">.cdbe38a0</span>.svg<br>│   │   ├── logo<span class="hljs-selector-class">.da56125f</span>.png<br>│   │   └── search.<span class="hljs-number">8</span>e85063d.png<br>│   └── js<br>│       ├── app.<span class="hljs-number">9</span>f3efa6d.js<br>│       ├── app.<span class="hljs-number">9</span>f3efa6d<span class="hljs-selector-class">.js</span>.map<br>│       ├── chunk-vendors.<span class="hljs-number">57</span>f9e9d6.js<br>│       └── chunk-vendors.<span class="hljs-number">57</span>f9e9d6<span class="hljs-selector-class">.js</span>.map<br>└── templates<br>    └── index.html<br></code></pre></td></tr></table></figure>

<h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>nohup 用于在系统后台不挂断地运行命令，不挂断指的是退出执行命令的终端也不会影响程序的运行。</p>
<p>我们可以使用 nohup 命令来运行应用程序，使其作为后台守护进程运行。由于在主流的 Linux 发行版中都会默认安装 nohup 命令工具，我们可以直接输入以下命令来启动我们的项目：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">sudo nohup ./bin/bluebell conf/config.yaml &gt; nohup_bluebell.<span class="hljs-built_in">log</span> <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &amp;</span><br></code></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams">./bluebell conf/config.yaml是我们应用程序的启动命令<br><br><span class="hljs-function"><span class="hljs-title">nohup</span></span> ... &amp;表示在后台不挂断的执行上述应用程序的启动命令<br><br>&gt; nohup_bluebell.<span class="hljs-built_in">log</span>表示将命令的标准输出重定向到 nohup_bluebell.<span class="hljs-built_in">log</span> 文件<br><br><span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>表示将标准错误输出也重定向到标准输出中，结合上一条就是把执行命令的输出都定向到 nohup_bluebell.<span class="hljs-built_in">log</span> 文件<br><br></code></pre></td></tr></table></figure>

<p>上面的命令执行后会返回进程 id</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>] <span class="hljs-number">6338</span><br></code></pre></td></tr></table></figure>
<p>当然我们也可以通过以下命令查看 bluebell 相关活动进程：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> bluebell<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>      <span class="hljs-number">6338</span>  <span class="hljs-number">4048</span>  <span class="hljs-number">0</span> <span class="hljs-number">08</span>:<span class="hljs-number">43</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ./bin/bluebell conf/config.yaml<br><span class="hljs-attribute">root</span>      <span class="hljs-number">6376</span>  <span class="hljs-number">4048</span>  <span class="hljs-number">0</span> <span class="hljs-number">08</span>:<span class="hljs-number">43</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto bluebell<br></code></pre></td></tr></table></figure>
<p>此时就可以打开浏览器输入http://服务器公网ip:端口查看应用程序的展示效果了。</p>
<h4 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h4><p>Supervisor <strong>是业界流行的一个通用的进程管理程序</strong>，<strong>它能将一个普通的命令行进程变为后台守护进程</strong>，<strong>并监控该进程的运行状态</strong>，<strong>当该进程异常退出时能将其自动重启</strong>。</p>
<p>首先使用 yum 来安装 supervisor：</p>
<p>如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装，如果已安装则跳过此步骤：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">sudo yum install epel-release<br></code></pre></td></tr></table></figure>
<p>安装 supervisor</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> supervisor<br></code></pre></td></tr></table></figure>

<p>Supervisor 的配置文件为：/etc/supervisord.conf ，Supervisor 所管理的应用的配置文件放在 /etc/supervisord.d/ 目录中，这个目录可以在 supervisord.conf 中的include配置。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">[<span class="hljs-keyword">include</span>]<br>files = <span class="hljs-regexp">/etc/</span>supervisord.d<span class="hljs-comment">/*.conf</span><br></code></pre></td></tr></table></figure>
<p>启动supervisor服务：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">sudo supervisord -c <span class="hljs-regexp">/etc/</span>supervisord.conf<br></code></pre></td></tr></table></figure>
<p>我们在/etc/supervisord.d目录下创建一个名为bluebell.conf的配置文件，具体内容如下。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[program:bluebell]</span>  <span class="hljs-comment">;程序名称</span><br><span class="hljs-attr">user</span>=root  <span class="hljs-comment">;执行程序的用户</span><br><span class="hljs-attr">command</span>=/data/app/bluebell/bin/bluebell /data/app/bluebell/conf/config.yaml  <span class="hljs-comment">;执行的命令</span><br><span class="hljs-attr">directory</span>=/data/app/bluebell/ <span class="hljs-comment">;命令执行的目录</span><br><span class="hljs-attr">stopsignal</span>=TERM  <span class="hljs-comment">;重启时发送的信号</span><br><span class="hljs-attr">autostart</span>=<span class="hljs-literal">true</span>  <br><span class="hljs-attr">autorestart</span>=<span class="hljs-literal">true</span>  <span class="hljs-comment">;是否自动重启</span><br><span class="hljs-attr">stdout_logfile</span>=/var/log/bluebell-stdout.log  <span class="hljs-comment">;标准输出日志位置</span><br><span class="hljs-attr">stderr_logfile</span>=/var/log/bluebell-stderr.log  <span class="hljs-comment">;标准错误日志位置</span><br></code></pre></td></tr></table></figure>
<p>创建好配置文件之后，重启supervisor服务</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> supervisorctl update <span class="hljs-comment"># 更新配置文件并重启相关的程序</span><br></code></pre></td></tr></table></figure>
<p>查看bluebell的运行状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo supervisorctl status bluebell</span><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bluebell</span>                         RUNNING   pid <span class="hljs-number">10918</span>, uptime <span class="hljs-number">0</span>:<span class="hljs-number">05</span>:<span class="hljs-number">46</span><br></code></pre></td></tr></table></figure>
<p>最后补充一下常用的supervisr管理命令：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">supervisorctl status       <span class="hljs-comment"># 查看所有任务状态</span><br>supervisorctl shutdown     <span class="hljs-comment"># 关闭所有任务</span><br>supervisorctl <span class="hljs-literal">start</span> 程序名  <span class="hljs-comment"># 启动任务</span><br>supervisorctl <span class="hljs-literal">stop</span> 程序名   <span class="hljs-comment"># 关闭任务</span><br>supervisorctl reload       <span class="hljs-comment"># 重启supervisor</span><br></code></pre></td></tr></table></figure>
<p>接下来就是打开浏览器查看网站是否正常了。</p>
<h3 id="搭配nginx部署"><a href="#搭配nginx部署" class="headerlink" title="搭配nginx部署"></a>搭配nginx部署</h3><p><strong>在需要静态文件分离</strong>、<strong>需要配置多个域名及证书</strong>、<strong>需要自建负载均衡层等稍复杂的场景下</strong>，我们一般需要搭配第三方的web服务器（Nginx、Apache）来部署我们的程序。</p>
<h4 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h4><p><strong>正向代理可以简单理解为客户端的代理</strong>，你访问墙外的网站用的那个属于正向代理。</p>
<p><strong>反向代理可以简单理解为服务器的代理</strong>，通常说的 Nginx 和 Apache 就属于反向代理。</p>
<p>Nginx 是一个免费的、开源的、高性能的 HTTP 和反向代理服务，主要负责负载一些访问量比较大的站点。</p>
<p>Nginx 可以作为一个独立的 Web 服务，也可以用来给 Apache 或是其他的 Web 服务做反向代理。<strong>相比于 Apache，Nginx 可以处理更多的并发连接，而且每个连接的内存占用的非常小。</strong></p>
<h4 id="使用yum安装nginx"><a href="#使用yum安装nginx" class="headerlink" title="使用yum安装nginx"></a>使用yum安装nginx</h4><p>EPEL 仓库中有 Nginx 的安装包。如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">sudo yum install epel-release<br></code></pre></td></tr></table></figure>
<p>安装nginx</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure>
<p>安装完成后，执行下面的命令设置Nginx开机启动：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-builtin-name">enable</span> nginx<br></code></pre></td></tr></table></figure>
<p>启动Nginx</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure>
<p>查看Nginx运行状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl status nginx</span><br></code></pre></td></tr></table></figure>
<h4 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h4><p>通过上面的方法安装的 nginx，所有相关的配置文件都在 /etc/nginx/ 目录中。Nginx 的主配置文件是 /etc/nginx/nginx.conf。</p>
<p>默认还有一个nginx.conf.default的配置文件示例，可以作为参考。<strong>你可以为多个服务创建不同的配置文件（建议为每个服务（域名）创建一个单独的配置文件），每一个独立的 Nginx 服务配置文件都必须以 .conf结尾，并存储在 /etc/nginx/conf.d 目录中。</strong></p>
<h4 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h4><p>补充几个 Nginx 常用命令。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">nginx -s stop    <span class="hljs-comment"># 停止 Nginx 服务</span><br>nginx -s <span class="hljs-keyword">reload</span>  <span class="hljs-comment"># 重新加载配置文件</span><br>nginx -s <span class="hljs-keyword">quit</span>    <span class="hljs-comment"># 平滑停止 Nginx 服务</span><br>nginx -t         <span class="hljs-comment"># 测试配置文件是否正确</span><br></code></pre></td></tr></table></figure>
<h4 id="Nginx反向代理部署"><a href="#Nginx反向代理部署" class="headerlink" title="Nginx反向代理部署"></a>Nginx反向代理部署</h4><p>我们推荐使用 nginx 作为反向代理来部署我们的程序，按下面的内容修改 nginx 的配置文件。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-attribute">access_log</span>   /var/log/bluebell-access.log;<br>        <span class="hljs-attribute">error_log</span>    /var/log/bluebell-<span class="hljs-literal">error</span>.log;<br><br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span>                 http://127.0.0.1:8084;<br>            <span class="hljs-attribute">proxy_redirect</span>             <span class="hljs-literal">off</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>           Host             $host;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Real-IP        $remote_addr;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Forwarded-For  $proxy_add_x_forwarded_for;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行下面的命令检查配置文件语法：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -t</span><br></code></pre></td></tr></table></figure>
<p>执行下面的命令重新加载配置文件：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure>
<p>接下来就是打开浏览器查看网站是否正常了。</p>
<p>当然我们还可以使用 nginx 的 upstream 配置来添加多个服务器地址实现负载均衡。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-attribute">upstream</span> backend &#123;<br>      <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8084</span>;<br>      <span class="hljs-comment"># 这里需要填真实可用的地址，默认轮询</span><br>      <span class="hljs-comment">#server backend1.example.com;</span><br>      <span class="hljs-comment">#server backend2.example.com;</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-attribute">access_log</span>   /var/log/bluebell-access.log;<br>        <span class="hljs-attribute">error_log</span>    /var/log/bluebell-<span class="hljs-literal">error</span>.log;<br><br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span>                 http://backend/;<br>            <span class="hljs-attribute">proxy_redirect</span>             <span class="hljs-literal">off</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>           Host             $host;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Real-IP        $remote_addr;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Forwarded-For  $proxy_add_x_forwarded_for;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Nginx分离静态文件请求"><a href="#Nginx分离静态文件请求" class="headerlink" title="Nginx分离静态文件请求"></a>Nginx分离静态文件请求</h4><p><strong>上面的配置是简单的使用 nginx 作为反向代理处理所有的请求并转发给我们的 Go 程序处理，其实我们还可以有选择的将静态文件部分的请求直接使用 nginx 处理，</strong>而将 API 接口类的动态处理请求转发给后端的 Go 程序来处理。</p>
<p>分离静态文件请求图示</p>
<p>下面继续修改我们的 nginx 的配置文件来实现上述功能。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  bluebell;<br><br>        <span class="hljs-attribute">access_log</span>   /var/log/bluebell-access.log;<br>        <span class="hljs-attribute">error_log</span>    /var/log/bluebell-<span class="hljs-literal">error</span>.log;<br><br>		<span class="hljs-comment"># 静态文件请求</span><br>        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(gif|jpg|jpeg|png|js|css|eot|ttf|woff|svg|otf)$</span> &#123;<br>            <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>            <span class="hljs-attribute">expires</span>    <span class="hljs-number">1d</span>;<br>            <span class="hljs-attribute">root</span>       /data/app/bluebell;<br>        &#125;<br><br>        <span class="hljs-comment"># index.html页面请求</span><br>        <span class="hljs-comment"># 因为是单页面应用这里使用 try_files 处理一下，避免刷新页面时出现404的问题</span><br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span> /data/app/bluebell/templates;<br>            <span class="hljs-attribute">index</span> index.html;<br>            <span class="hljs-attribute">try_files</span> $uri $uri/ /index.html;<br>        &#125;<br><br>		<span class="hljs-comment"># API请求</span><br>        <span class="hljs-attribute">location</span> /api &#123;<br>            <span class="hljs-attribute">proxy_pass</span>                 http://127.0.0.1:8084;<br>            <span class="hljs-attribute">proxy_redirect</span>             <span class="hljs-literal">off</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>           Host             $host;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Real-IP        $remote_addr;<br>            <span class="hljs-attribute">proxy_set_header</span>           X-Forwarded-For  $proxy_add_x_forwarded_for;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="前后端分开部署"><a href="#前后端分开部署" class="headerlink" title="前后端分开部署"></a>前后端分开部署</h4><p>前后端的代码没必要都部署到相同的服务器上，也可以分开部署到不同的服务器上，下图是前端服务将 API 请求转发至后端服务的方案。</p>
<p>前后端分开部署方案1</p>
<p>上面的部署方案中，所有浏览器的请求都是直接访问前端服务，而如果是浏览器直接访问后端API服务的部署模式下，如下图。</p>
<p>此时前端和后端通常不在同一个域下，我们还需要在后端代码中添加跨域支持。</p>
<p>前后端分开部署方案2</p>
<p>这里使用github.com/gin-contrib/cors库来支持跨域请求。</p>
<p>最简单的允许跨域的配置是使用cors.Default()，它默认允许所有跨域请求。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> main() &#123;<br>	router := gin.Default()<br>	<span class="hljs-regexp">//</span> same as<br>	<span class="hljs-regexp">//</span> config := cors.DefaultConfig()<br>	<span class="hljs-regexp">//</span> config.AllowAllOrigins = true<br>	<span class="hljs-regexp">//</span> router.Use(cors.New(config))<br>	router.Use(cors.Default())<br>	router.Run()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，还可以使用cors.Config自定义具体的跨域请求相关配置项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;time&quot;</span><br><br>	<span class="hljs-string">&quot;github.com/gin-contrib/cors&quot;</span><br>	<span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	router := gin.Default()<br>	<span class="hljs-comment">// CORS for https://foo.com and https://github.com origins, allowing:</span><br>	<span class="hljs-comment">// - PUT and PATCH methods</span><br>	<span class="hljs-comment">// - Origin header</span><br>	<span class="hljs-comment">// - Credentials share</span><br>	<span class="hljs-comment">// - Preflight requests cached for 12 hours</span><br>	router.Use(cors.New(cors.Config&#123;<br>		AllowOrigins:     []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;https://foo.com&quot;</span>&#125;,<br>		AllowMethods:     []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;PATCH&quot;</span>&#125;,<br>		AllowHeaders:     []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;Origin&quot;</span>&#125;,<br>		ExposeHeaders:    []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;Content-Length&quot;</span>&#125;,<br>		AllowCredentials: <span class="hljs-literal">true</span>,<br>		AllowOriginFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(origin <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>			<span class="hljs-keyword">return</span> origin == <span class="hljs-string">&quot;https://github.com&quot;</span><br>		&#125;,<br>		MaxAge: <span class="hljs-number">12</span> * time.Hour,<br>	&#125;))<br>	router.Run()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="容器部署"><a href="#容器部署" class="headerlink" title="容器部署"></a>容器部署</h3><h4 id="为什么需要Docker？"><a href="#为什么需要Docker？" class="headerlink" title="为什么需要Docker？"></a>为什么需要Docker？</h4><p>使用docker的主要目标是容器化。也就是为你的应用程序提供一致的环境，而不依赖于它运行的主机。</p>
<p><strong>想象一下你是否也会遇到下面这个场景，你在本地开发了你的应用程序，它很可能有很多的依赖环境或包，甚至对依赖的具体版本都有严格的要求，当开发过程完成后，你希望将应用程序部署到web服务器。这个时候你必须确保所有依赖项都安装正确并且版本也完全相同，否则应用程序可能会崩溃并无法运行。如果你想在另一个web服务器上也部署该应用程序，那么你必须从头开始重复这个过程。这种场景就是Docker发挥作用的地方。</strong><br>（我一直认为学好一个东西，就必须先知道这个玩意解决了什么问题。）</p>
<p>对于运行我们应用程序的主机，不管是笔记本电脑还是web服务器，我们唯一需要做的就是运行一个docker容器平台。从以后，你就不需要担心你使用的是MacOS，Ubuntu，Arch还是其他。你只需定义一次应用，即可随时随地运行。</p>
<h4 id="Docker部署示例"><a href="#Docker部署示例" class="headerlink" title="Docker部署示例"></a>Docker部署示例</h4><h5 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h5><p>这里我先用一段使用net/http库编写的简单代码为例讲解如何使用Docker进行部署，后面再讲解稍微复杂一点的项目部署案例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>	server := &amp;http.Server&#123;<br>		Addr: <span class="hljs-string">&quot;:8888&quot;</span>,<br>	&#125;<br>  fmt.Println(<span class="hljs-string">&quot;server startup...&quot;</span>)<br>	<span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;server startup failed, err:%v\n&quot;</span>, err)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;<br>	w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello liwenzhou.com!&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码通过8888端口对外提供服务，返回一个字符串响应：hello liwenzhou.com!。</p>
<h5 id="创建Docker镜像"><a href="#创建Docker镜像" class="headerlink" title="创建Docker镜像"></a>创建Docker镜像</h5><p>镜像（image）包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。</p>
<p>或者简单地说，镜像（image）是定义应用程序及其运行所需的一切。</p>
<h5 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h5><p>要创建Docker镜像（image）必须在配置文件中指定步骤。这个文件默认我们通常称之为Dockerfile。（虽然这个文件名可以随意命名它，但最好还是使用默认的Dockerfile。）</p>
<p>现在我们开始编写Dockerfile，具体内容如下：<br><strong>注意：某些步骤不是唯一的，可以根据自己的需要修改诸如文件路径、最终可执行文件的名称等</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> golang:alpine<br><br><span class="hljs-comment"># 为我们的镜像设置必要的环境变量</span><br>ENV <span class="hljs-attribute">GO111MODULE</span>=on \<br>    <span class="hljs-attribute">CGO_ENABLED</span>=0 \<br>    <span class="hljs-attribute">GOOS</span>=linux \<br>    <span class="hljs-attribute">GOARCH</span>=amd64<br><br><span class="hljs-comment"># 移动到工作目录：/build</span><br>WORKDIR /build<br><br><span class="hljs-comment"># 将代码复制到容器中</span><br>COPY . .<br><br><span class="hljs-comment"># 将我们的代码编译成二进制可执行文件app</span><br><span class="hljs-builtin-name">RUN</span> go build -o app .<br><br><span class="hljs-comment"># 移动到用于存放生成的二进制文件的 /dist 目录</span><br>WORKDIR /dist<br><br><span class="hljs-comment"># 将二进制文件从 /build 目录复制到这里</span><br><span class="hljs-builtin-name">RUN</span> cp /build/app .<br><br><span class="hljs-comment"># 声明服务端口</span><br>EXPOSE 8888<br><br><span class="hljs-comment"># 启动容器时运行的命令</span><br>CMD [<span class="hljs-string">&quot;/dist/app&quot;</span>]<br></code></pre></td></tr></table></figure>

<h5 id="Dockerfile解析"><a href="#Dockerfile解析" class="headerlink" title="Dockerfile解析"></a>Dockerfile解析</h5><h6 id="From"><a href="#From" class="headerlink" title="From"></a>From</h6><p><strong>我们正在使用基础镜像golang:alpine来创建我们的镜像。</strong><br>这和我们要创建的镜像一样是一个我们能够访问的存储在Docker仓库的基础镜像。<br>这个镜像运行的是alpine Linux发行版，该发行版的大小很小并且内置了Go，非常适合我们的用例。<br>有大量公开可用的Docker镜像，请查看<a target="_blank" rel="noopener" href="https://hub.docker.com/_/golang">https://hub.docker.com/_/golang</a></p>
<h6 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h6><p>用来设置我们编译阶段需要用的环境变量。</p>
<h6 id="WORKDIR，COPY，RUN"><a href="#WORKDIR，COPY，RUN" class="headerlink" title="WORKDIR，COPY，RUN"></a>WORKDIR，COPY，RUN</h6><p>这几个命令做的事都写在注释里了，很好理解。</p>
<h6 id="EXPORT，CMD"><a href="#EXPORT，CMD" class="headerlink" title="EXPORT，CMD"></a>EXPORT，CMD</h6><p>最后，我们声明服务端口，因为我们的应用程序监听的是这个端口并通过这个端口对外提供服务。并且我们还定义了在我们运行镜像的时候默认执行的命令CMD [“/dist/app”]。</p>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p>在项目目录下，执行下面的命令创建镜像，并指定镜像名称为goweb_app：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">docker build . -<span class="hljs-built_in">t</span> goweb_app<br></code></pre></td></tr></table></figure>
<p>等待构建过程结束，输出如下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">...<br>Successfully built 90d9283286b7<br>Successfully tagged goweb_app:latest<br></code></pre></td></tr></table></figure>

<p>现在我们已经准备好了镜像，但是目前它什么也没做。我们接下来要做的是运行我们的镜像，以便它能够处理我们的请求。运行中的镜像称为容器。</p>
<p>执行下面的命令来运行镜像：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8888</span>:<span class="hljs-number">8888</span> goweb_app<br></code></pre></td></tr></table></figure>

<p>标志位-p用来定义端口绑定。由于容器中的应用程序在端口8888上运行，我们将其绑定到主机端口也是8888。如果要绑定到另一个端口，则可以使用-p $HOST_PORT:8888。例如-p 5000:8888。</p>
<p>现在就可以测试下我们的web程序是否工作正常，打开浏览器输入<a href="http://127.0.0.1:8888就能看到我们事先定义的响应内容如下：">http://127.0.0.1:8888就能看到我们事先定义的响应内容如下：</a></p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">hello liwenzhou.com!<br></code></pre></td></tr></table></figure>
<h4 id="分阶段构建示例"><a href="#分阶段构建示例" class="headerlink" title="分阶段构建示例"></a>分阶段构建示例</h4><p>我们的Go程序编译之后会得到一个可执行的二进制文件，<strong>其实在最终的镜像中是不需要go编译器的，也就是说我们只需要一个运行最终二进制文件的容器即可。</strong></p>
<p>Docker的最佳实践之一是通过仅保留二进制文件来减小镜像大小，为此，我们将使用一种称为多阶段构建的技术，这意味着我们将通过多个步骤构建镜像。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">FROM golang:alpine AS builder<br><br># 为我们的镜像设置必要的环境变量<br>ENV GO111MODULE=on \<br>    CGO_ENABLED=<span class="hljs-number">0</span> \<br>    GOOS=linux \<br>    GOARCH=amd64<br><br># 移动到工作目录：/build<br>WORKDIR /build<br><br># 将代码复制到容器中<br>COPY . .<br><br># 将我们的代码编译成二进制可执行文件 app<br>RUN go build -o app .<br><br>###################<br># 接下来创建一个小镜像<br>###################<br>FROM scratch<br><br># 从builder镜像中把/dist/app 拷贝到当前目录<br>COPY --<span class="hljs-keyword">from</span>=builder /build/app /<br><br># 需要运行的命令<br>ENTRYPOINT [<span class="hljs-string">&quot;/app&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>使用这种技术，我们剥离了使用golang:alpine作为编译镜像来编译得到二进制可执行文件的过程，<strong>并基于scratch生成一个简单的</strong>、非常小的新镜像。</p>
<p>我们将二进制文件从命名为builder的第一个镜像中复制到新创建的scratch镜像中。有关scratch镜像的更多信息，请查看<a target="_blank" rel="noopener" href="https://hub.docker.com/_/scratch">https://hub.docker.com/_/scratch</a></p>
<h3 id="附带其他文件的部署示例"><a href="#附带其他文件的部署示例" class="headerlink" title="附带其他文件的部署示例"></a>附带其他文件的部署示例</h3><p>这里以我之前《Go Web视频教程》中的小清单项目为例，项目的Github仓库地址为：<a target="_blank" rel="noopener" href="https://github.com/Q1mi/bubble%E3%80%82">https://github.com/Q1mi/bubble。</a></p>
<p>如果项目中带有静态文件或配置文件，需要将其拷贝到最终的镜像文件中。</p>
<p>我们的bubble项目用到了静态文件和配置文件，具体目录结构如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">bubble<br>├── README.md<br>├── bubble<br>├── conf<br>│   └── config.ini<br>├── controller<br>│   └── controller.go<br>├── dao<br>│   └── mysql.go<br>├── example.png<br>├── go.mod<br>├── go.sum<br>├── <span class="hljs-selector-tag">main</span>.go<br>├── models<br>│   └── todo.go<br>├── routers<br>│   └── routers.go<br>├── setting<br>│   └── setting.go<br>├── static<br>│   ├── css<br>│   │   ├── app.<span class="hljs-number">8</span>eeeaf31.css<br>│   │   └── chunk-vendors.<span class="hljs-number">57</span>db8905.css<br>│   ├── fonts<br>│   │   ├── element-icons.<span class="hljs-number">535877</span>f5.woff<br>│   │   └── element-icons.<span class="hljs-number">732389</span>de.ttf<br>│   └── js<br>│       ├── app.<span class="hljs-number">007</span>f9690.js<br>│       └── chunk-vendors<span class="hljs-selector-class">.ddcb6f91</span>.js<br>└── templates<br>    ├── favicon.ico<br>    └── index.html<br></code></pre></td></tr></table></figure>
<p>我们需要将templates、static、conf三个文件夹中的内容拷贝到最终的镜像文件中。更新后的Dockerfile如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">FROM golang:alpine AS builder<br><br># 为我们的镜像设置必要的环境变量<br>ENV GO111MODULE=on \<br>    CGO_ENABLED=<span class="hljs-number">0</span> \<br>    GOOS=linux \<br>    GOARCH=amd64<br><br># 移动到工作目录：/build<br>WORKDIR /build<br><br># 复制项目中的 go.mod 和 go.sum文件并下载依赖信息<br>COPY go.mod .<br>COPY go.sum .<br>RUN go mod download<br><br># 将代码复制到容器中<br>COPY . .<br><br># 将我们的代码编译成二进制可执行文件 bubble<br>RUN go build -o bubble .<br><br>###################<br># 接下来创建一个小镜像<br>###################<br>FROM scratch<br><br>COPY ./templates /templates<br>COPY ./static /static<br>COPY ./conf /conf<br><br># 从builder镜像中把/dist/app 拷贝到当前目录<br>COPY --<span class="hljs-keyword">from</span>=builder /build/bubble /<br><br># 需要运行的命令<br>ENTRYPOINT [<span class="hljs-string">&quot;/bubble&quot;</span>, <span class="hljs-string">&quot;conf/config.ini&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>简单来说就是多了几步COPY的步骤，大家看一下Dockerfile中的注释即可。</p>
<!-- 
Tips： 这里把COPY静态文件的步骤放在上层，把COPY二进制可执行文件放在下层，争取多使用缓存。 -->
<h4 id="关联其他容器"><a href="#关联其他容器" class="headerlink" title="关联其他容器"></a>关联其他容器</h4><p>又因为我们的项目中使用了MySQL，我们可以选择使用如下命令启动一个MySQL容器，它的别名为mysql8019；root用户的密码为root1234；挂载容器中的/var/lib/mysql到本地的/Users/q1mi/docker/mysql目录；内部服务端口为3306，映射到外部的13306端口。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql<span class="hljs-number">8019</span> -p <span class="hljs-number">13306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=root<span class="hljs-number">1234</span> -v /Users/q<span class="hljs-number">1</span>mi/docker/mysql:/var/lib/mysql -d mysql:<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure>

<p>这里需要修改一下我们程序中配置的MySQL的host地址为容器别名，使它们在内部通过别名（此处为mysql8019）联通。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysql]</span><br><span class="hljs-attr">user</span> = root<br><span class="hljs-attr">password</span> = root1234<br><span class="hljs-attr">host</span> = mysql8019<br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">db</span> = bubble<br></code></pre></td></tr></table></figure>
<p>修改后记得重新构建bubble_app镜像：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">docker build . -<span class="hljs-built_in">t</span> bubble_app<br></code></pre></td></tr></table></figure>
<p>我们这里运行bubble_app容器的时候需要使用–link的方式与上面的mysql8019容器关联起来，具体命令如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --link=mysql<span class="hljs-number">8019</span>:mysql<span class="hljs-number">8019</span> -p <span class="hljs-number">8888</span>:<span class="hljs-number">8888</span> bubble_app<br></code></pre></td></tr></table></figure>
<h4 id="Docker-Compose模式"><a href="#Docker-Compose模式" class="headerlink" title="Docker Compose模式"></a>Docker Compose模式</h4><p>除了像上面一样使用–link的方式来关联两个容器之外，我们还可以使用Docker Compose来定义和运行多个容器。</p>
<p>Compose是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，你可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>使用Compose基本上是一个三步过程：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">使用Dockerfile定义你的应用环境以便可以在任何地方复制。<br><br>定义组成应用程序的服务，docker-compose<span class="hljs-selector-class">.yml</span> 以便它们可以在隔离的环境中一起运行。<br><br>执行 docker-compose up命令来启动并运行整个应用程序。<br></code></pre></td></tr></table></figure>
<p>我们的项目需要两个容器分别运行mysql和bubble_app，我们编写的docker-compose.yml文件内容如下：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># yaml 配置</span><br><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  mysql8019:</span><br><span class="hljs-symbol">    image:</span> <span class="hljs-string">&quot;mysql:8.0.19&quot;</span><br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;33061:3306&quot;</span><br><span class="hljs-symbol">    command:</span> <span class="hljs-string">&quot;--default-authentication-plugin=mysql_native_password --init-file /data/application/init.sql&quot;</span><br><span class="hljs-symbol">    environment:</span><br><span class="hljs-symbol">      MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&quot;root1234&quot;</span><br><span class="hljs-symbol">      MYSQL_DATABASE:</span> <span class="hljs-string">&quot;bubble&quot;</span><br><span class="hljs-symbol">      MYSQL_PASSWORD:</span> <span class="hljs-string">&quot;root1234&quot;</span><br><span class="hljs-symbol">    volumes:</span><br>      - ./init.sql:<span class="hljs-meta-keyword">/data/</span>application/init.sql<br><span class="hljs-symbol">  bubble_app:</span><br><span class="hljs-symbol">    build:</span> .<br><span class="hljs-symbol">    command:</span> sh -c <span class="hljs-string">&quot;./wait-for.sh mysql8019:3306 -- ./bubble ./conf/config.ini&quot;</span><br><span class="hljs-symbol">    depends_on:</span><br>      - mysql8019<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;8888:8888&quot;</span><br></code></pre></td></tr></table></figure>

<p>这个 Compose 文件定义了两个服务：bubble_app 和 mysql8019。其中：</p>
<h5 id="bubble-app"><a href="#bubble-app" class="headerlink" title="bubble_app"></a>bubble_app</h5><p>使用当前目录下的Dockerfile文件构建镜像，并通过depends_on指定依赖mysql8019服务，声明服务端口8888并绑定对外8888端口。</p>
<h5 id="mysql8019"><a href="#mysql8019" class="headerlink" title="mysql8019"></a>mysql8019</h5><p>mysql8019 服务使用 Docker Hub 的公共 mysql:8.0.19 镜像，内部端口3306，外部端口33061。</p>
<p>这里需要注意一个问题就是，<strong>我们的bubble_app容器需要等待mysql8019容器正常启动之后再尝试启动，因为我们的web程序在启动的时候会初始化MySQL连接。</strong>这里共有两个地方要更改，第一个就是我们Dockerfile中要把最后一句注释掉：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Dockerfile</span><br>...<br><span class="hljs-meta"># 需要运行的命令（注释掉这一句，因为需要等MySQL启动之后再启动我们的Web程序）</span><br><span class="hljs-meta"># ENTRYPOINT [&quot;/bubble&quot;, &quot;conf/config.ini&quot;]</span><br></code></pre></td></tr></table></figure>

<p>第二个地方是在bubble_app下面添加如下命令，使用提前编写的wait-for.sh脚本检测mysql8019:3306正常后再执行后续启动Web应用程序的命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">command</span>: <span class="hljs-keyword">sh</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;./wait-for.sh mysql8019:3306 -- ./bubble ./conf/config.ini&quot;</span><br></code></pre></td></tr></table></figure>
<p>当然，因为我们现在要在bubble_app镜像中执行sh命令，所以不能在使用scratch镜像构建了，这里改为使用debian:stretch-slim，同时还要安装wait-for.sh脚本用到的netcat，最后不要忘了把wait-for.sh脚本文件COPY到最终的镜像中，并赋予可执行权限哦。更新后的Dockerfile内容如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">FROM golang:alpine AS builder<br><br># 为我们的镜像设置必要的环境变量<br>ENV GO111MODULE=on \<br>    CGO_ENABLED=<span class="hljs-number">0</span> \<br>    GOOS=linux \<br>    GOARCH=amd64<br><br># 移动到工作目录：/build<br>WORKDIR /build<br><br># 复制项目中的 go.mod 和 go.sum文件并下载依赖信息<br>COPY go.mod .<br>COPY go.sum .<br>RUN go mod download<br><br># 将代码复制到容器中<br>COPY . .<br><br># 将我们的代码编译成二进制可执行文件 bubble<br>RUN go build -o bubble .<br><br>###################<br># 接下来创建一个小镜像<br>###################<br>FROM debian:stretch-slim<br><br>COPY ./wait-for.sh /<br>COPY ./templates /templates<br>COPY ./static /static<br>COPY ./conf /conf<br><br><br># 从builder镜像中把/dist/app 拷贝到当前目录<br>COPY --<span class="hljs-keyword">from</span>=builder /build/bubble /<br><br>RUN set -eux; \<br>	apt-get update; \<br>	apt-get install -y \<br>		--no-install-recommends \<br>		netcat; \<br>        chmod <span class="hljs-number">755</span> wait-for.sh<br><br># 需要运行的命令<br># ENTRYPOINT [<span class="hljs-string">&quot;/bubble&quot;</span>, <span class="hljs-string">&quot;conf/config.ini&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>所有的条件都准备就绪后，就可以执行下面的命令跑起来了：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up</span><br></code></pre></td></tr></table></figure>
<p>完整版代码示例，请查看我的github仓库：<a target="_blank" rel="noopener" href="https://github.com/Q1mi/deploy_bubble_using_docker%E3%80%82">https://github.com/Q1mi/deploy_bubble_using_docker。</a></p>
<p>总结<br>使用Docker容器能够极大简化我们在配置依赖环境方面的操作，但同时也对我们的技术储备提了更高的要求。对于Docker不管你是熟悉抑或是不熟悉，技术发展的车轮都滚滚向前。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://levelup.gitconnected.com/complete-guide-to-create-docker-container-for-your-golang-application-80f3fb59a15e">https://levelup.gitconnected.com/complete-guide-to-create-docker-container-for-your-golang-application-80f3fb59a15e</a></p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2021/07/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9golang%EF%BC%88%E5%8D%81%EF%BC%89/">
        <div class="last">
            <span>上一篇</span>
            <p>为什么选择golang（十）</p>
        </div>
    </a>
    

    
    <a href="/2021/07/13/golang%E7%9A%84%E8%B0%83%E8%AF%95%E6%B5%8B%E8%AF%95%EF%BC%88%E5%85%AB%EF%BC%89/">
        <div class="next">
            <span>下一篇</span>
            <p>golang的调试测试（八）</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2021 By Russshare. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>