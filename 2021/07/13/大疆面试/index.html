<!DOCTYPE html>
<html>

	<head>
		
<title>大疆面试-Russshare</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">


<meta name="keywords" content="面试,C语言,嵌入式,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4b5fe1472f22fa";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">
</head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Russshare</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg ">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/面试">面试</a></li>
            
            <li><a href="/tags/C语言">C语言</a></li>
            
            <li><a href="/tags/嵌入式">嵌入式</a></li>
            
            
        </ul>
        <h1>大疆面试</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                    <g>
                        <path fill="#12183A"
                            d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                        </path>
                    </g>
                </svg>
                
                <span> <a href="">Russshare</a></span>
                <p>2021-07-13 14:35:43</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h3 id="关键字volatile"><a href="#关键字volatile" class="headerlink" title="关键字volatile"></a>关键字volatile</h3><p><strong>表示一个变量也许会被后台程序改变</strong>，关键字 volatile 是与 const 绝对对立的。它指示一个变量也许会被某种方式修改，这种方式按照正常程序流程分析是无法预知的（例如，一个变量也许会被一个中断服务程序所修改）。这个关键字使用下列语法定义：volatile data-definition。</p>
<p>变量如果加了 volatile 修饰，则会从内存重新装载内容，而不是直接从寄存器拷贝内容。 <strong>volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</strong></p>
<p>volatile应用比较多的场合，在中断服务程序和cpu相关寄存器的定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//示例一</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">int</span> a = i; <span class="hljs-comment">//优化</span><br>	<span class="hljs-keyword">int</span> b = i;<br> <br>	<span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;i = %d\n&quot;</span>, b);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//示例二</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">int</span> a = i; <span class="hljs-comment">//未优化</span><br>	<span class="hljs-keyword">int</span> b = i;<br> <br>	<span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;i = %d\n&quot;</span>, b);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 volatile 的代码编译未优化。</p>
<p>volatile 指出 i 是随时可能发生变化的，<strong>每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。</strong></p>
<p>而优化做法是，<strong>由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。</strong></p>
<p><strong>这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。</strong></p>
<p>volatile 使用：</p>
<p>1.并行设备的硬件寄存器（如：状态寄存器）；2.一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)；3.多线程应用中被几个任务共享的变量。</p>
<h3 id="关键字-inline"><a href="#关键字-inline" class="headerlink" title="关键字 inline"></a>关键字 inline</h3><p>大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(<strong>注意是定义而非声明</strong>，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。</p>
<h4 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.  内联函数"></a>1.  内联函数</h4><p>在C++中我们通常定义以下函数来求两个整数的最大值：</p>
<p>复制代码代码如下:</p>
<p>int max(int a, int b)<br>{<br> return a &gt; b ? a : b;<br>}</p>
<p>为这么一个小的操作定义一个函数的好处有：</p>
<p><strong>①</strong> 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多</p>
<p><strong>②</strong> 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多</p>
<p><strong>③</strong> 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现</p>
<p><strong>④</strong> 函数可以重用，不必为其他应用程序重写代码</p>
<p>虽然有这么多好处，但是写成函数有一个潜在的缺点：<strong>调用函数比求解等价表达式要慢得多。</strong>在大多数的机器上，调用函数都要做很多工作：<strong>调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行</strong></p>
<p>C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>则调用： cout&lt;&lt;max(a, b)&lt;&lt;endl;</p>
<p><strong>在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;</strong></p>
<p><strong>从而消除了把 max写成函数的额外执行开销</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/46261.html">参考链接</a></p>
<ol start="3">
<li> 将内联函数放入头文件</li>
</ol>
<p>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数 Foo 不能成为内联函数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><br>inline void <span class="hljs-constructor">Foo(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span>;   <span class="hljs-comment">// inline 仅与函数声明放在一起   </span><br>void <span class="hljs-constructor">Foo(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span><br>&#123;<br> ...<br>&#125; <br><br></code></pre></td></tr></table></figure>
<p>而如下风格的函数 Foo 则成为内联函数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><br>void <span class="hljs-constructor">Foo(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span>;   <br>inline void <span class="hljs-constructor">Foo(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span>   <span class="hljs-comment">// inline 与函数定义体放在一起</span><br>&#123;<br> ...<br>&#125; <br><br></code></pre></td></tr></table></figure>
<p>所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<p>但是编译器是否将它真正内联则要看 Foo函数如何定义</p>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<h3 id="C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用"><a href="#C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用" class="headerlink" title="C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用"></a>C语言编译过程中，volatile关键字和extern关键字分别在哪个阶段起作用</h3><p>volatile应该是在编译阶段，extern在链接阶段。<br>       volatile关键字的作用是防止变量被编译器优化，而优化是处于编译阶段，所以volatile关键字是在编译阶段起作用。</p>
<h3 id="C语言的四个阶段"><a href="#C语言的四个阶段" class="headerlink" title="C语言的四个阶段"></a>C语言的四个阶段</h3><p><strong>预处理阶段</strong>。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中，结果就得到了另一个C程序，通常是以.i作为文件扩展名。</p>
<p><strong>编译阶段</strong>。编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令。</p>
<p><strong>汇编阶段</strong>。汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开hello.o文件，看到的将是一堆乱码。</p>
<p><strong>链接阶段</strong>。链接器（ld）负责处理合并目标代码，生成一个可执行目标文件，可以被加载到内存中，由系统执行。</p>
<h3 id="GCC和G-的区别和联系："><a href="#GCC和G-的区别和联系：" class="headerlink" title="GCC和G++的区别和联系："></a>GCC和G++的区别和联系：</h3><p>gcc和g++都是GNU（一个组织）的编译器。</p>
<p>1、对于.c后缀的文件，gcc把它当做是C程序；g++当做是C++程序；</p>
<p>2、对于.cpp后缀的文件，gcc和g++都会当做c++程序。</p>
<p>3、编译阶段，g++会调用gcc；</p>
<p>4、连接阶段，通常会用g++来完成，这是因为gcc命令不能自动和c++程序使用的库连接。</p>
<h3 id="请你说一下源码到可执行文件的过程"><a href="#请你说一下源码到可执行文件的过程" class="headerlink" title="请你说一下源码到可执行文件的过程"></a>请你说一下源码到可执行文件的过程</h3><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。<br>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件<br>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件<br>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件<br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/c01.png"></p>
<h4 id="1）预编译"><a href="#1）预编译" class="headerlink" title="1）预编译"></a>1）预编译</h4><pre><code>   主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下
</code></pre>
<p>1、删除所有的#define，展开所有的宏定义。<br>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。<br>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。<br>4、删除所有的注释，“//”和“/**/”。<br>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。<br>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<h4 id="2）编译"><a href="#2）编译" class="headerlink" title="2）编译"></a>2）编译</h4><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。<br>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。<br>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。<br>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。<br>4、优化：源代码级别的一个优化过程。<br>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。<br>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<h4 id="3）汇编"><a href="#3）汇编" class="headerlink" title="3）汇编"></a>3）汇编</h4><pre><code>   将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。
</code></pre>
<h4 id="4）链接"><a href="#4）链接" class="headerlink" title="4）链接"></a>4）链接</h4><pre><code>   将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

 1、静态链接：
   函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
   空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
   更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
   运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
 2、动态链接：
   动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
   共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
   更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
   性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
</code></pre>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><h4 id="1-如果是数组"><a href="#1-如果是数组" class="headerlink" title="1.如果是数组"></a>1.如果是数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">printf</span>(“<span class="hljs-keyword">sizeof</span>数组名=%d\n”,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br><span class="hljs-built_in">printf</span>(“<span class="hljs-keyword">sizeof</span> *数组名=%d\n”,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*a));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果<br>sizeof数组名=20<br>sizeof *数组名=4</p>
<h4 id="2-如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。"><a href="#2-如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。" class="headerlink" title="2.如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。"></a>2.如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *p = “sadasdasd”;<br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( p):<span class="hljs-number">4</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*p):<span class="hljs-number">1</span><span class="hljs-comment">//指向一个char类型的</span><br></code></pre></td></tr></table></figure>

<h3 id="struct与union数据内存对齐，内存对齐的作用。"><a href="#struct与union数据内存对齐，内存对齐的作用。" class="headerlink" title="struct与union数据内存对齐，内存对齐的作用。"></a>struct与union数据内存对齐，内存对齐的作用。</h3><p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/c02.png"></p>
<h4 id="结构体struct内存对齐的3大规则"><a href="#结构体struct内存对齐的3大规则" class="headerlink" title="结构体struct内存对齐的3大规则:"></a>结构体struct内存对齐的3大规则:</h4><p>1.对于结构体的各个成员，<strong>第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍；</strong><br>2.结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，<strong>保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍；</strong><br>3.如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(1)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fun</span>&#123;</span><br>	<span class="hljs-keyword">int</span> i;<br>	<span class="hljs-keyword">double</span> d;<br>	<span class="hljs-keyword">char</span> c;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>sizeof(fun) = 13</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> <span class="hljs-built_in">CAT_s</span><br>&#123;<br>    <span class="hljs-keyword">int</span> ld;<br>    <span class="hljs-keyword">char</span> Color;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> Age;<br>    <span class="hljs-keyword">char</span> *Name;<br>    <span class="hljs-keyword">void</span>(*Jump)(<span class="hljs-keyword">void</span>);<br>&#125;Garfield;<br><br></code></pre></td></tr></table></figure>

<p> 按照上面的3大规则直接来进行分析：<br>1.使用32位编译，int占4， char 占1， unsigned short 占2，char* 占4，函数指针占4个，由于是32位编译是4字节对齐，所以该结构体占16个字节。（说明：按几字节对齐，是根据结构体的最长类型决定的，这里是int是最长的字节，所以按4字节对齐）；</p>
<p>2.使用64位编译 ，int占4， char 占1， unsigned short 占2，char* 占8，函数指针占8个，由于是64位编译是8字节对齐，（说明：按几字节对齐，是根据结构体的最长类型决定的，这里是函数指针是最长的字节，所以按8字节对齐）所以该结构体占24个字节。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//64位</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> </span><br><span class="hljs-class">&#123;</span> <br>	<span class="hljs-keyword">double</span> t;   <span class="hljs-comment">//8   1111 1111</span><br>	<span class="hljs-keyword">char</span> b;  <span class="hljs-comment">//1      1</span><br>	<span class="hljs-keyword">int</span> a;   <span class="hljs-comment">//4      0001111  </span><br>	<span class="hljs-keyword">short</span> c;  <span class="hljs-comment">//2     11000000</span><br>&#125;;  <br> <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(C) = <span class="hljs-number">24</span>;  <span class="hljs-comment">//注意：1 4 2 不能拼在一起  因为类型的地址必须是自己的倍数</span><br><br></code></pre></td></tr></table></figure>
<p><strong>sizeof(C) = 24;  //注意：1 4 2 不能拼在一起  因为类型的地址必须是自己的倍数</strong></p>
<h3 id="联合体union内存对齐的2大规则"><a href="#联合体union内存对齐的2大规则" class="headerlink" title="联合体union内存对齐的2大规则:"></a>联合体union内存对齐的2大规则:</h3><p>1.找到占用字节最多的成员；</p>
<p>2.union的字节数必须是占用字节最多的成员的字节的倍数，而且需要能够容纳其他的成员.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//x64</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">long</span> i;<br>    <span class="hljs-keyword">int</span> k[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">char</span> c;<br>&#125;D<br></code></pre></td></tr></table></figure>
<p>要计算union的大小,首先要找到占用字节最多的成员,本例中是long,占用8个字节,int k[5]中都是int类型,仍然是占用4个字节的，然后union的字节数必须是占用字节最多的成员的字节的倍数,而且需要能够容纳其他的成员,为了要容纳k(20个字节),就必须要保证是8的倍数的同时还要大于20个字节,所以是24个字节。<br>8+24+8</p>
<h3 id="内存对齐作用："><a href="#内存对齐作用：" class="headerlink" title="内存对齐作用："></a>内存对齐作用：</h3><p>1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</p>
<h3 id="结构体占用内存"><a href="#结构体占用内存" class="headerlink" title="结构体占用内存"></a>结构体占用内存</h3><p>在32位系统中有如下定义，则sizeof（data_t）的值是（）<br>A.15 B.19 C.11 D.8</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> struct_data&#123;<br>	<span class="hljs-keyword">char</span> m:<span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">char</span> n:<span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">short</span> s;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>		<span class="hljs-keyword">int</span> a;<br>		<span class="hljs-keyword">char</span> b;<br>	&#125;;<br>   <span class="hljs-keyword">int</span> h;<br>&#125;_attribute_((packed)) <span class="hljs-keyword">data_t</span>;<br></code></pre></td></tr></table></figure>
<p>sizeof(data_t) = 11;<br><strong>attribute</strong>((packed))的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数对齐，union联合体里面的变量是共享一个地址空间的，以及结构体的位段操作知识点。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42957923/article/details/88052888">结构体、位段与联合体</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013193026/article/details/39367825"><em>attribute</em>_((packed))详解</a></p>
<p>char m,n位段算1个字节，short 2个字节，union算4个字节，int是4个字节，一起是11个.</p>
<h3 id="片上系统中，常用来在片内做数据传输的总线是"><a href="#片上系统中，常用来在片内做数据传输的总线是" class="headerlink" title="片上系统中，常用来在片内做数据传输的总线是"></a>片上系统中，常用来在片内做数据传输的总线是</h3><p>A. UART B .<strong>I2C</strong> C.AXI D SPI</p>
<h3 id="几种总线接口的通信方式"><a href="#几种总线接口的通信方式" class="headerlink" title="几种总线接口的通信方式"></a>几种总线接口的通信方式</h3><p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/c03.png"></p>
<h3 id="ARM指令和Thumb指令"><a href="#ARM指令和Thumb指令" class="headerlink" title="ARM指令和Thumb指令"></a>ARM指令和Thumb指令</h3><p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/itismine/article/details/4753701]">https://blog.csdn.net/itismine/article/details/4753701]</a></p>
<h3 id="请简述linux或RTOS中，栈空间最大使用率和栈溢出检测方法。"><a href="#请简述linux或RTOS中，栈空间最大使用率和栈溢出检测方法。" class="headerlink" title="请简述linux或RTOS中，栈空间最大使用率和栈溢出检测方法。"></a>请简述linux或RTOS中，栈空间最大使用率和栈溢出检测方法。</h3><p>方法一：在任务切换时检测任务指针是否过界了，如果过界了，在任务切换的时候会触发栈溢出的钩子函数。</p>
<p>方法二：任务创建的时候将任务栈所有的数据初始化为0xa5，任务切换时进行任务栈检测的时候会检测末尾的16个字节是否都是0xa5，通过这种方式来检测任务栈是否溢出了。</p>
<h3 id="抢占式内核中，任务调度实际有哪些"><a href="#抢占式内核中，任务调度实际有哪些" class="headerlink" title="抢占式内核中，任务调度实际有哪些"></a>抢占式内核中，任务调度实际有哪些</h3><h3 id="一个程序中含有以下代码块，请说明其中各个变量的生命周期，作用域和存储位置（提示：存储位置可以选泽-‘text’-‘data’-‘bss’-‘heap’-‘stack’）"><a href="#一个程序中含有以下代码块，请说明其中各个变量的生命周期，作用域和存储位置（提示：存储位置可以选泽-‘text’-‘data’-‘bss’-‘heap’-‘stack’）" class="headerlink" title="一个程序中含有以下代码块，请说明其中各个变量的生命周期，作用域和存储位置（提示：存储位置可以选泽 ‘text’ ‘data’ ‘bss’ ‘heap’ ‘stack’）"></a>一个程序中含有以下代码块，请说明其中各个变量的生命周期，作用域和存储位置（提示：存储位置可以选泽 ‘text’ ‘data’ ‘bss’ ‘heap’ ‘stack’）</h3><p>  <img src="https://gitee.com/psycho1900/miss-reddle/raw/master/c05.png"></p>
<p> 一个程序本质上都是由BSS段、data段、text段（代码区）三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<p><strong>BSS段</strong>（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
<p><strong>数据段</strong>：数据段也属于静态内存分配。该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</p>
<p><strong>代码段</strong>：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
<p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
<p><strong>bss段</strong>（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
<p><strong>data段</strong>（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p>
<p><strong>数据段包含经过初始化的全局变量以及它们的值</strong>。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p><strong>可执行程序在运行时又多出两个区域：栈区和堆区。</strong></p>
<p><strong>栈区</strong>：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。<strong>栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</strong></p>
<p><strong>堆区</strong>：<strong>用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。</strong> <strong>频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</strong><br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/c6.png"></p>
<h3 id="请用c语言直接编写以下四个宏"><a href="#请用c语言直接编写以下四个宏" class="headerlink" title="请用c语言直接编写以下四个宏"></a>请用c语言直接编写以下四个宏</h3><p>1、ALGN_DOWN(x，a)将数值x按照a的整数倍向下取整，例如ALGN_DOWN(65，3)—&gt;63<br>2、ALGN_UP(x，a) 将数值x按照a的整数倍向上取整，例如ALGN_UP(65，3)—&gt;66<br>3、ALGN_2N_DOWN(x，a) 将数值x按照a的整数倍向下取整，a是2的n次幂，例如ALGN_2N_DOWN(65，4)—&gt;64.<br>4、ALGN_2N__UP(x，a) 将数值x按照a的整数倍向上取整，a是2的n次幂，例如ALGN_2N_UP(65，4)—&gt;68.<br>备注：数值位unsigned int；对2的n次幂的情况只要利用这个特性用更高效的方法实现。<br>问题3.4执行运算符右移操作，右移就是原数除2</p>
<h3 id="C语言编程"><a href="#C语言编程" class="headerlink" title="C语言编程"></a>C语言编程</h3><p>已知某外设有两个32—bit的寄存器<br>数据寄存器，内存映射地址为0x80000000<br>状态寄存器，内存映射地址0x80000004<br>状态寄存器的bit31为A功能的标志位<br>请补充完成以下结构体描述两个寄存器，<br>Typedef struct{<br>………<br>}A_regs_t;<br>请用c语言实现如下函数；<br>/*<br>*read A data if A status is 1,and then clear the A status bit.<br>*@param[in] a_regs;pointer to registers of A function<br>*@param[out] result;data read from register<br>@retval 0:successs;&lt;0:error code<br>*/<br>Int32_t_get_A_result(A_regs_t a_regs,uint32 _tresult);<br>并写出调用这个函数的代码。</p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2021/07/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9golang%EF%BC%88%E5%8D%81%EF%BC%89/">
        <div class="last">
            <span>上一篇</span>
            <p>为什么选择golang（十）</p>
        </div>
    </a>
    

    
    <a href="/2021/06/28/LRU%E7%AE%97%E6%B3%95%E6%8B%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
        <div class="next">
            <span>下一篇</span>
            <p>LRU算法拆解与实现</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2022 By Russshare. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>