<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="每天一道算法题：螺旋矩阵"/>




  <meta name="keywords" content="面试,算法," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/07/28/每天一道算法题：螺旋矩阵/"/>


<meta name="description" content="给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 12345678910111213141516171819示例 1:输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]示例 2:输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,">
<meta property="og:type" content="article">
<meta property="og:title" content="每天一道算法题：螺旋矩阵">
<meta property="og:url" content="https://riddlego.github.io/2021/07/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 12345678910111213141516171819示例 1:输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]示例 2:输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/psycho1900/miss-reddle/raw/master/matrix02.png">
<meta property="og:image" content="https://gitee.com/psycho1900/miss-reddle/raw/master/matrix01.png">
<meta property="article:published_time" content="2021-07-28T15:59:41.000Z">
<meta property="article:modified_time" content="2021-07-29T15:12:23.345Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/psycho1900/miss-reddle/raw/master/matrix02.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 每天一道算法题：螺旋矩阵 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          每天一道算法题：螺旋矩阵
        
      </h1>

      <time class="post-time">
          7月 28 2021
      </time>
    </header>



    
            <div class="post-content">
            <p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/matrix02.png"><br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/matrix01.png"></p>
<p>如果一条边从头遍历到底，则下一条边遍历的起点随之变化</p>
<p>选择不遍历到底，可以减小横向、竖向遍历之间的影响</p>
<p>一轮迭代结束时，4条边的两端同时收窄 1</p>
<p>一轮迭代所做的事情很清晰：遍历一个“圈”，遍历的范围收缩为内圈</p>
<p>一层层向里处理，按顺时针依次遍历：上、右、下、左。</p>
<p>不再形成“环”了，就会剩下一行或一列，然后单独判断</p>
<p>(作者：xiao_ben_zhu<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-kan-/">https://leetcode-cn.com/problems/spiral-matrix/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-kan-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。)</p>
<p><strong>四个边界</strong><br>上边界 top : 0<br>下边界 bottom : matrix.length - 1<br>左边界 left : 0<br>右边界 right : matrix[0].length - 1</p>
<p><strong>矩阵不一定是方阵</strong><br>top &lt; bottom &amp;&amp; left &lt; right 是循环的条件</p>
<p>无法构成“环”了，就退出循环，退出时可能是这 3 种情况之一：<br>top == bottom &amp;&amp; left &lt; right —— 剩一行<br>top &lt; bottom &amp;&amp; left == right —— 剩一列<br>top == bottom &amp;&amp; left == right —— 剩一项（也是一行/列）</p>
<p><strong>处理剩下的单行或单列</strong><br>因为是按顺时针推入结果数组的，所以<br>剩下的一行，从左至右 依次推入结果数组<br>剩下的一列，从上至下 依次推入结果数组</p>
<p><strong>代码</strong><br>每个元素访问一次，时间复杂度 O(m<em>n)，m、n 分别是矩阵的行数和列数<br>空间复杂度 O(m</em>n)<br>Runtime: 0 ms, faster than 100.00% of Go online submissions for Spiral Matrix.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func spiralOrder(matrix [][]int) []int &#123;</span><br><span class="line">    if len(matrix) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        return []int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res :&#x3D; []int&#123;&#125;</span><br><span class="line">    top, bottom, left, right :&#x3D; 0, len(matrix)-1, 0, len(matrix[0])-1</span><br><span class="line">    </span><br><span class="line">    for top &lt; bottom &amp;&amp; left &lt; right &#123;</span><br><span class="line">        for i :&#x3D; left; i &lt; right; i++ &#123; res &#x3D; append(res, matrix[top][i]) &#125;</span><br><span class="line">        for i :&#x3D; top; i &lt; bottom; i++ &#123; res &#x3D; append(res, matrix[i][right]) &#125;</span><br><span class="line">        for i :&#x3D; right; i &gt; left; i-- &#123; res &#x3D; append(res, matrix[bottom][i]) &#125;</span><br><span class="line">        for i :&#x3D; bottom; i &gt; top; i-- &#123; res &#x3D; append(res, matrix[i][left]) &#125;</span><br><span class="line">        right--</span><br><span class="line">        top++</span><br><span class="line">        bottom--</span><br><span class="line">        left++ </span><br><span class="line">    &#125;</span><br><span class="line">    if top &#x3D;&#x3D; bottom &#123;</span><br><span class="line">        for i :&#x3D; left; i &lt;&#x3D; right; i++ &#123; res &#x3D; append(res, matrix[top][i]) &#125;</span><br><span class="line">    &#125; else if left &#x3D;&#x3D; right &#123;</span><br><span class="line">        for i :&#x3D; top; i &lt;&#x3D; bottom; i++ &#123; res &#x3D; append(res, matrix[i][left]) &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>换一种遍历的策略：遍历到底</strong></p>
<p>循环的条件改为： top &lt;= bottom &amp;&amp; left &lt;= right</p>
<p>每遍历一条边，下一条边遍历的起点被“挤占”，要更新相应的边界</p>
<p>值得注意的是，可能出现 在循环中途，不再满足循环的条件 ，即出现 top &gt; bottom || left &gt; right ，其中一对边界彼此交错了</p>
<p>这意味着此时所有项都遍历完了，如果没有及时 break ，就会重复遍历</p>
<p><strong>解决办法</strong><br>每遍历完一条边，更新完相应的边界后，都加一条判断 if (top &gt; bottom || left &gt; right) break，避免遍历完成时没有及时退出，导致重复遍历。</p>
<p>但你发现，遍历完成要么发生在遍历完“上边”，要么发生在遍历完“右边”</p>
<p>所以只需在这两步操作之后，加 if (top &gt; bottom || left &gt; right) break 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func spiralOrder(matrix [][]int) []int &#123;</span><br><span class="line">    if len(matrix) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        return []int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res :&#x3D; []int&#123;&#125;</span><br><span class="line">    top, bottom, left, right :&#x3D; 0, len(matrix)-1, 0, len(matrix[0])-1</span><br><span class="line">    </span><br><span class="line">    for top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right &#123;</span><br><span class="line">        for i :&#x3D; left; i &lt;&#x3D; right; i++ &#123; res &#x3D; append(res, matrix[top][i]) &#125;</span><br><span class="line">        top++</span><br><span class="line">        for i :&#x3D; top; i &lt;&#x3D; bottom; i++ &#123; res &#x3D; append(res, matrix[i][right]) &#125;</span><br><span class="line">        right--</span><br><span class="line">        if top &gt; bottom || left &gt; right &#123; break &#125; </span><br><span class="line">        for i :&#x3D; right; i &gt;&#x3D; left; i-- &#123; res &#x3D; append(res, matrix[bottom][i]) &#125;</span><br><span class="line">        bottom--</span><br><span class="line">        for i :&#x3D; bottom; i &gt;&#x3D; top; i-- &#123; res &#x3D; append(res, matrix[i][left]) &#125;</span><br><span class="line">        left++ </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
		  
			<a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/07/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">每天一道算法题：斐波那契数列</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/07/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">
        <span class="next-text nav-default">每天一道算法题：反转字符串</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
