<!DOCTYPE html>
<html>

	<head>
		
<title>TCP的三次握手与四次挥手-Russshare</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">


<meta name="keywords" content="面试,TCP/IP,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4b5fe1472f22fa";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">
</head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/profile.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Russshare</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg ">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/面试">面试</a></li>
            
            <li><a href="/tags/TCP/IP">TCP/IP</a></li>
            
            
        </ul>
        <h1>TCP的三次握手与四次挥手</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                    <g>
                        <path fill="#12183A"
                            d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                        </path>
                    </g>
                </svg>
                
                <span> <a href="">Russshare</a></span>
                <p>2021-07-18 17:41:59</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h3 id="白话版"><a href="#白话版" class="headerlink" title="白话版"></a>白话版</h3><p><strong>先整点评论区的精彩通俗白话文</strong></p>
<p><strong>三次握手</strong><br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/tcpip01.gif"></p>
<p>tcp的三次握手是很有意思的，基本思想就是“<strong>让我知道你已经知道</strong>”了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">服务器监听请求<br><br>客户端发起连接请求（第一次连接），<br><br>请求在路上可能存在丢失的风险，所以当请求到了服务器后如果服务器同意建立连接会给客户端一个回信（第二次连接），告诉它：我已经收到请求，可以连接。<br><br>但是回信也存在一个问题，那就是回信能不能到客户端？<br><br>它需要客户端给他一个回信说我已经收到批准通知了，如果客户端一直不回复的话意味着客户端没有收到批准通知。<br><br>因此客户端一收到批准通知就立马回复（第三次握手）：OK老铁我收到你的批准通知了。<br><br>至此，三次握手结束。 <br></code></pre></td></tr></table></figure>

<p>一个很类似的例子就是投简历：先投简历，然后对方公司会通知你通过简历筛选，你收到这个通知后一般会回复一下我知道了。 </p>
<p>这种“让我知道你已经知道了”的想法是一种约定俗成的可靠信息交互的基本方式，基于此想法构建的信息交互框架叫做协议。</p>
<p><strong>四次挥手</strong></p>
<p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/tcpip02.png"><br>释放连接的时候也是如此：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">客户端发起关闭连接的请求，关闭连接意味着客户端结束了自己的工作即发送数据，(第一次)<br><br>但此时仍然处于数据传输的过程中，服务器可能未数据传输完毕，因此当请求到服务器时服务器知道了这个请求，<br><br>但服务器数据传输未完成无法关闭连接，因此服务器先发送一个ack告诉客户端关闭请求已收到，但老子正忙，一会再关，你再等一会。（第二次）<br><br>等服务器工作完成了，就把fin信号发送给客户端，（第三次）<br><br>此时服务器要等着客户端给他一个回信，让服务器知道客户端已经知道了。因此客户端收到后就给服务器一个回信，（第四次）<br></code></pre></td></tr></table></figure>

<p>为了防止回信丢失，<strong>客户端就再等2MSL个时间</strong>，之所以是2个，是因为涉及到来回，<strong>第一个MSL中是回信在路上的最大时间</strong>，</p>
<p><strong>第二个MSL是万一回信没到服务端</strong>，服务端重发的FIN确认在路上的时间（不知道这样理解对不对）。</p>
<p><strong>举个例子</strong>：</p>
<p>A 和 B 打电话，通话即将结束后，</p>
<p>A 说“我没啥要说的了”，</p>
<p>B 回答“我知道了”，</p>
<p>但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，</p>
<p>A 回答“知道了”，这样通话才算结束。（复制于<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42">https://blog.csdn.net/qq_42</a>)</p>
<h3 id="理论版本"><a href="#理论版本" class="headerlink" title="理论版本"></a>理论版本</h3><h4 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h4><figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">应用程序	FTP	TFTP	TELNET	SMTP	DNS	HTTP	SSH	MYSQL<br>熟知端口	<span class="hljs-number">21,20	69	23</span>	<span class="hljs-number">25	53	80	22</span>	<span class="hljs-number">3306</span><br>传输层协议	TCP	UDP	TCP	TCP	UDP	TCP	TCP	TCP<br></code></pre></td></tr></table></figure>

<h4 id="TCP的概述"><a href="#TCP的概述" class="headerlink" title="TCP的概述"></a>TCP的概述</h4><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），</p>
<p>它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>
<h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><ul>
<li><p>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</p>
</li>
<li><p>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</p>
</li>
<li><p>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</p>
</li>
<li><p>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</p>
</li>
<li><p>保留，占6位，保留今后使用，但目前应都位0；</p>
</li>
<li><p>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p>
</li>
<li><p>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</p>
</li>
<li><p>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p>
</li>
<li><p>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p>
</li>
<li><p>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</p>
</li>
<li><p>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</p>
</li>
<li><p>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</p>
</li>
<li><p>检验和，占2字节，校验首部和数据这两部分；</p>
</li>
<li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p>
</li>
<li><p>选项，长度可变，定义一些其他的可选的参数。</p>
</li>
</ul>
<p><strong>三次握手</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">最开始的时候客户端和服务器都是处于<span class="hljs-keyword">CLOSED</span>状态。主动打开连接的为客户端，被动打开连接的是服务器。<br></code></pre></td></tr></table></figure>

<p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</p>
<p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p>
<p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p>
<p>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p>
<p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>
<p><strong>为什么TCP客户端最后还要发送一次确认呢</strong>？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br><br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。<br><br>此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br><br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。<br></code></pre></td></tr></table></figure>

<p><strong>四次挥手</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭<br></code></pre></td></tr></table></figure>

<ul>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
</li>
<li><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
</li>
<li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
</li>
<li><p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
</li>
</ul>
<p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/tcpip03.png"></p>
<p><strong>为什么客户端最后还要等待2MSL</strong>？</p>
<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。</strong>客户端发送完最后一个确认报文后，<strong>在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</strong></p>
<p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p>
<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br><strong>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，</strong> 所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong><br>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/tcp03.gif"><br>（图片来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yaopeng_2005/article/details/7064869%EF%BC%89">https://blog.csdn.net/yaopeng_2005/article/details/7064869）</a></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="1-为什么要传回-SYN"><a href="#1-为什么要传回-SYN" class="headerlink" title="1 为什么要传回 SYN"></a>1 为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">SYN</span> 是 TCP/<span class="hljs-built_in">IP</span> 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。<br></code></pre></td></tr></table></figure>

<h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。<br></code></pre></td></tr></table></figure>


<h4 id="在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h4><p>打开一个网页，整个过程会使用哪些协议?</p>
<p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/http17.png"></p>
<p>总体来说分为以下几个过程:</p>
<ul>
<li><p>DNS解析</p>
</li>
<li><p>TCP连接</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>服务器处理请求并返回HTTP报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>连接结束</p>
</li>
</ul>
<h4 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h4><p><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/http18.png"></p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2021/07/18/TCP-IP%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/">
        <div class="last">
            <span>上一篇</span>
            <p>TCP-IP详解：快速重传与快速恢复</p>
        </div>
    </a>
    

    
    <a href="/2021/07/18/TCP-IP%E5%8D%8F%E8%AE%AE%E7%AB%9F%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E6%BC%8F%E6%B4%9E/">
        <div class="next">
            <span>下一篇</span>
            <p>TCP.IP协议竟然有这么多漏洞</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2021 By Russshare. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>