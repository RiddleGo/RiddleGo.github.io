<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Go-如何利用-Linux-内核的负载均衡能力"/>




  <meta name="keywords" content="Linux,golang," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/08/31/Go-如何利用-Linux-内核的负载均衡能力/"/>


<meta name="description" content="点击这里进入前辈原文 在测试 HTTP 服务时，如果该进程我们忘记关闭，而重新尝试启动一个新的服务进程，那么将会遇到类似以下的错误信息： 12$ go run main.golisten tcp :8000: bind: address already in use  这是由于默认情况下，操作系统不允许我们打开具有相同源地址和端口的套接字 socket。但如果我们想开启多个服务进程去监听同一个端口">
<meta property="og:type" content="article">
<meta property="og:title" content="Go-如何利用-Linux-内核的负载均衡能力">
<meta property="og:url" content="https://riddlego.github.io/2021/08/31/Go-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-Linux-%E5%86%85%E6%A0%B8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%83%BD%E5%8A%9B/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="点击这里进入前辈原文 在测试 HTTP 服务时，如果该进程我们忘记关闭，而重新尝试启动一个新的服务进程，那么将会遇到类似以下的错误信息： 12$ go run main.golisten tcp :8000: bind: address already in use  这是由于默认情况下，操作系统不允许我们打开具有相同源地址和端口的套接字 socket。但如果我们想开启多个服务进程去监听同一个端口">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/psycho1900/miss-reddle/raw/master/process/go-linux.png">
<meta property="article:published_time" content="2021-08-31T13:44:41.000Z">
<meta property="article:modified_time" content="2021-08-31T15:33:54.508Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/psycho1900/miss-reddle/raw/master/process/go-linux.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Go-如何利用-Linux-内核的负载均衡能力 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Go-如何利用-Linux-内核的负载均衡能力
        
      </h1>

      <time class="post-time">
          8月 31 2021
      </time>
    </header>



    
            <div class="post-content">
            <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lnOTaraGKINxaqbrMHPP5Q">点击这里进入前辈原文</a></p>
<p>在测试 HTTP 服务时，如果该进程我们忘记关闭，而重新尝试启动一个新的服务进程，那么将会遇到类似以下的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">listen tcp :8000: bind: address already in use</span><br></pre></td></tr></table></figure>

<p>这是由于默认情况下，操作系统不允许我们打开具有相同源地址和端口的套接字 socket。但如果我们想开启多个服务进程去监听同一个端口，这可以吗？如果可以，这又能给我们带来什么？</p>
<h2 id="socket-五元组"><a href="#socket-五元组" class="headerlink" title="socket 五元组"></a>socket 五元组</h2><p>socket 编程是每位程序员都应该掌握的基础知识。因此，大家应该知道，socket 连接通过五元组唯一标识。任意两条连接，它的五元组不能完全相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;&#125;</span><br></pre></td></tr></table></figure>


<p>protocol 指的是传输层 TCP/UDP 协议，它在 socket 被创建时就已经确定。src addr/port 与 dest addr/port  分别标识着请求方与服务方的地址信息。</p>
<p>因此，只要请求方的 dest addr/port 信息不相同，那么服务方即使是同样的 src addr/port ，它仍然可以标识唯一的 socket 连接。</p>
<p>基于这个理论基础，那实际上，我们可以在同一个网络主机复用相同的 IP 地址和端口号。</p>
<h2 id="Linux-SO-REUSEPORT"><a href="#Linux-SO-REUSEPORT" class="headerlink" title="Linux SO_REUSEPORT"></a>Linux SO_REUSEPORT</h2><p>为了满足复用端口的需求，Linux 3.9 内核引入了 SO_REUSEPORT选项（实际在此之前有一个类似的选项 SO_REUSEADDR，但它没有做到真正的端口复用，详细可见参考链接1）。</p>
<p>SO_REUSEPORT 支持多个进程或者线程绑定到同一端口，用于提高服务器程序的性能。它的特性包含以下几点：</p>
<ul>
<li><p>允许多个套接字 bind 同一个TCP/UDP 端口<br>每一个线程拥有自己的服务器套接字</p>
<p>在服务器套接字上没有了锁的竞争</p>
</li>
<li><p>内核层面实现负载均衡</p>
</li>
<li><p>安全层面，监听同一个端口的套接字只能位于同一个用户下（same effective UID）</p>
</li>
</ul>
<p>有了 SO_RESUEPORT 后，每个进程可以 bind 相同的地址和端口，各自是独立平等的。</p>
<p>让多进程监听同一个端口，各个进程中 accept socket fd 不一样，有新连接建立时，内核只会调度一个进程来 accept，并且保证调度的均衡性。</p>
<p>其工作示意图如下<br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/process/go-linux.png"></p>
<p>有了 SO_REUSEADDR 的支持，我们不仅可以创建多个具有相同 IP:PORT 的套接字能力，而且我们还得到了一种内核模式下的负载均衡能力。</p>
<h2 id="Go-如何设置-SO-REUSEPORT"><a href="#Go-如何设置-SO-REUSEPORT" class="headerlink" title="Go 如何设置 SO_REUSEPORT"></a>Go 如何设置 SO_REUSEPORT</h2><p>Linux 经典的设计哲学：一切皆文件。当然，socket 也不例外，它也是一种文件。</p>
<p>如果我们想在 Go 程序中，利用上 linux 的 SO_REUSEPORT 选项，那就需要有修改内核 socket 连接选项的接口，而这可以依赖于 golang.org/x/sys/unix 库来实现，具体就在以下这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import “&quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot;”</span><br><span class="line">...</span><br><span class="line">unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)</span><br></pre></td></tr></table></figure>
<p>因此，一个持有 SO_REUSEPORT 特性的完整 Go 服务代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;context&quot;</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;net&quot;</span><br><span class="line"> &quot;net&#x2F;http&quot;</span><br><span class="line"> &quot;os&quot;</span><br><span class="line"> &quot;syscall&quot;</span><br><span class="line"></span><br><span class="line"> &quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var lc &#x3D; net.ListenConfig&#123;</span><br><span class="line"> Control: func(network, address string, c syscall.RawConn) error &#123;</span><br><span class="line">  var opErr error</span><br><span class="line">  if err :&#x3D; c.Control(func(fd uintptr) &#123;</span><br><span class="line">   opErr &#x3D; unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)</span><br><span class="line">  &#125;); err !&#x3D; nil &#123;</span><br><span class="line">   return err</span><br><span class="line">  &#125;</span><br><span class="line">  return opErr</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> pid :&#x3D; os.Getpid()</span><br><span class="line"> l, err :&#x3D; lc.Listen(context.Background(), &quot;tcp&quot;, &quot;127.0.0.1:8000&quot;)</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"> server :&#x3D; &amp;http.Server&#123;&#125;</span><br><span class="line"> http.HandleFunc(&quot;&#x2F;&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">  w.WriteHeader(http.StatusOK)</span><br><span class="line">  fmt.Fprintf(w, &quot;Client [%s] Received msg from Server PID: [%d] \n&quot;, r.RemoteAddr, pid)</span><br><span class="line"> &#125;)</span><br><span class="line"> fmt.Printf(&quot;Server with PID: [%d] is running \n&quot;, pid)</span><br><span class="line"> _ &#x3D; server.Serve(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其编译为 linux 可执行文件 main</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED&#x3D;0 GOOS&#x3D;linux GOARCH&#x3D;amd64 go build main.go</span><br></pre></td></tr></table></figure>

<p>在 linux 主机上开启三个同时监听 8000 端口的进程，我们可以看到三个服务进程的 PID 分别是 32687 、32691 和 32697。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~ $ .&#x2F;main</span><br><span class="line">Server with PID: [32687] is running</span><br><span class="line">~ $ .&#x2F;main</span><br><span class="line">Server with PID: [32691] is running</span><br><span class="line">~ $ .&#x2F;main</span><br><span class="line">Server with PID: [32697] is running</span><br></pre></td></tr></table></figure>
<p>最后，通过 curl 命令，模拟多次 http 客户端请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">~ $ for i in &#123;1..20&#125;; do curl localhost:8000; done</span><br><span class="line">Client [127.0.0.1:56876] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56880] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56884] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56888] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56892] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56896] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56900] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56904] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56908] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56912] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56916] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56920] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56924] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56928] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56932] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56936] Received msg from Server PID: [32697]</span><br><span class="line">Client [127.0.0.1:56940] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56944] Received msg from Server PID: [32691]</span><br><span class="line">Client [127.0.0.1:56948] Received msg from Server PID: [32687]</span><br><span class="line">Client [127.0.0.1:56952] Received msg from Server PID: [32697]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，20 个客户端请求被均衡地打到了三个服务进程上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>linux 内核自 3.9 提供的 SO_REUSEPORT 选项，可以让多进程监听同一个端口。</p>
<p>这种机制带来了什么：</p>
<ul>
<li><p>提高服务器程序的吞吐性能：我们可以运行多个应用程序实例，充分利用多核 CPU 资源，避免出现单核在处理数据包，其他核却闲着的问题。</p>
</li>
<li><p>内核级负载均衡：我们不需要在多个实例前面添加一层服务代理，因为内核已经提供了简单的负载均衡。</p>
</li>
<li><p>不停服更新：当我们需要更新服务时，可以启动新的服务实例来接受请求，再优雅地关闭掉旧服务实例。</p>
</li>
</ul>
<p>如果你们的 Go 项目，一到高峰期就有请求堆积问题，这个时候就可以考虑采用 SO_REUSEPORT 选项。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p>【1. How do SO_REUSEADDR and SO_REUSEPORT differ?】<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ">https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ</a></p>
<p>【2. SO_REUSEPORT 性能测试】 <a target="_blank" rel="noopener" href="http://www.blogjava.net/yongboy/archive/2015/02/12/422893.html">http://www.blogjava.net/yongboy/archive/2015/02/12/422893.html</a></p>
<p>【3. linux socket man-page】<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Linux/">Linux</a>
		  
			<a href="/tags/golang/">golang</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/08/31/%E7%BC%96%E5%86%99%E4%B8%8E%E4%BC%98%E5%8C%96Go%E4%BB%A3%E7%A0%81-I/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">编写与优化Go代码---I</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/08/29/%E5%9C%A8Go%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%A5%BD%E5%A4%84/">
        <span class="next-text nav-default">在Go中使用微服务架构的好处</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
