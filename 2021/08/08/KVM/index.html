<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="KVM"/>




  <meta name="keywords" content="KVM,虚拟化,云计算," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/08/08/KVM/"/>


<meta name="description" content="一、KVM1. 基本理论什么是虚拟化？就是将一台物理机虚拟成多台虚拟机，虚拟机之前互不干扰。 为什么要用虚拟化？充分利用物理资源，提供冗余性、向云计算演进的必要基础。 常见的虚拟化软件？vmware、kvm 查看当前系统是使用哪家的虚拟化？lscpu kvm的三个组件及作用：libvirt（用来管理虚拟机）、virt（安装和克隆虚拟机）、qemu（管理虚拟机磁盘的） 磁盘的类型（raw&#x2F;qcow2">
<meta property="og:type" content="article">
<meta property="og:title" content="KVM">
<meta property="og:url" content="https://riddlego.github.io/2021/08/08/KVM/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="一、KVM1. 基本理论什么是虚拟化？就是将一台物理机虚拟成多台虚拟机，虚拟机之前互不干扰。 为什么要用虚拟化？充分利用物理资源，提供冗余性、向云计算演进的必要基础。 常见的虚拟化软件？vmware、kvm 查看当前系统是使用哪家的虚拟化？lscpu kvm的三个组件及作用：libvirt（用来管理虚拟机）、virt（安装和克隆虚拟机）、qemu（管理虚拟机磁盘的） 磁盘的类型（raw&#x2F;qcow2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-08T11:42:38.000Z">
<meta property="article:modified_time" content="2021-08-08T11:44:49.621Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="KVM">
<meta property="article:tag" content="虚拟化">
<meta property="article:tag" content="云计算">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> KVM - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          KVM
        
      </h1>

      <time class="post-time">
          8月 08 2021
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="一、KVM"><a href="#一、KVM" class="headerlink" title="一、KVM"></a>一、KVM</h2><h3 id="1-基本理论"><a href="#1-基本理论" class="headerlink" title="1. 基本理论"></a>1. 基本理论</h3><p>什么是虚拟化？就是将一台物理机虚拟成多台虚拟机，虚拟机之前互不干扰。</p>
<p>为什么要用虚拟化？充分利用物理资源，提供冗余性、向云计算演进的必要基础。</p>
<p>常见的虚拟化软件？vmware、kvm</p>
<p>查看当前系统是使用哪家的虚拟化？lscpu</p>
<p>kvm的三个组件及作用：libvirt（用来管理虚拟机）、virt（安装和克隆虚拟机）、qemu（管理虚拟机磁盘的）</p>
<p>磁盘的类型（raw/qcow2），raw不支持快照但性能好，常用的是qcom2支持快照，性能相比差一点。</p>
<p>第一个虚拟要默认是侦听在5900这个端口。</p>
<p>桥接的工作原理</p>
<h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. 常用操作</h3><p>virsh list 查看正在运行的虚拟机</p>
<p>virsh list all 查看所有虚拟机</p>
<p>virsh start centos7 开机</p>
<p>virsh shutdown centos7 关机</p>
<p>查看虚拟机的端口：virsh vncdisply centos7</p>
<p>kvm开机启动：virsh autostart centos7.1</p>
<p>所谓的导出虚拟是指将磁盘文件和配置文件拿走就可以了</p>
<h3 id="云计算中的虚拟机管理程序及其类型"><a href="#云计算中的虚拟机管理程序及其类型" class="headerlink" title="云计算中的虚拟机管理程序及其类型?"></a>云计算中的虚拟机管理程序及其类型?</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43695104/article/details/88554443?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.base">KVM虚拟化</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40274679/article/details/105925870">一文带你速懂虚拟化KVM和XEN</a></p>
<p><strong>访客虚拟机直接在主机硬件上运行</strong>，比如Xen和VMWare ESXI。</p>
<p><strong>访客虚拟机通过主机操作系统在硬件上运行</strong>，比如KVM和Oracle VirtualBox。</p>
<p>KVM拥有更好的生态，更多的开源支持。而XEN诞生时间较长，也是目前最成熟的虚拟化技术。</p>
<h3 id="1，框架"><a href="#1，框架" class="headerlink" title="1，框架"></a>1，框架</h3><p>KVM 分为了两个模块，一个是KVM Driver, 另一个是QEMU。前者负责CPU和内存的虚拟化，后者负责IO的虚拟化。用户空间的QEMU调用一系列的ioctl() 函数进入内核空间，然后内核控件再调用一系列函数进入Guest OS客户空间运行虚拟机。<br>问题：为什么分为两部分? IO设备用KVM不能被虚拟化么？<br>因为KVM是linux内核加载的一个模块，modprobe kvm执行之后呢，kernel马上就变成了Hypervisor。这里kvm能利用linux本身的系统调用，内存管理等进程管理的办法，提升了很大的效率，也很简便。<br>IO设备一般都是用QEMU来虚拟的，在不支持硬件虚拟化的机器上，QEMU也可以用来虚拟CPU，只是采用二进制动态翻译效率不是很好。远不及KVM.</p>
<h3 id="2，kvm各模式说明"><a href="#2，kvm各模式说明" class="headerlink" title="2，kvm各模式说明"></a>2，kvm各模式说明</h3><p>有三种模式：用户模式，内核模式，客户模式。 QEMU运行在用户模式，用户模式就是一般意义上运行的进程的模式，QEMU调用一系列的ioctl就可以进入内核模式，这里内核模式再调用kvm_create等函数就可以进入客户模式，客户模式也就是虚拟机运行的模式。</p>
<p>但是如果虚拟机出现了异常或者常见的缺页中断或者IO操作的时候呢，他是没有权限对全局资源进行操作的，这样就会被VMM，这里也就是KVM进行捕获，然后捕获之后呢再跳转到用户模式调用QEMU进行IO操作。所以说内核模式其实是个中间变量，专门用来进行错误发现的时候的转换的。</p>
<h3 id="3，CPU虚拟化"><a href="#3，CPU虚拟化" class="headerlink" title="3，CPU虚拟化"></a>3，CPU虚拟化</h3><p>CPU的虚拟化本质上是时间分片。这里我们用的是KVM来虚拟的。流程如下：<br>QEMU调用ioctl进入内核，内核读取VMCS，（这里先解释下VMCS，VMCS是异常处理的关键结构，里面存储了客户机，宿主机，陷入退出的各种状态。）把客户机的状态装在到CPU的CS:EIP，然后执行 kvm_exit_handler. 如果是IO引起的，则进入用户模式，执行QEMU.</p>
<h3 id="4，内存虚拟化"><a href="#4，内存虚拟化" class="headerlink" title="4，内存虚拟化"></a>4，内存虚拟化</h3><p>一般的内存虚拟化都经过了两次的页表转换。 客户机线性地址到 客户机物理地址， 然后再到宿主机物理地址。 这样经过了两次转换，效率很难提高。于是就出现了影子页表。<br>这里就不得不说影子页表了。 这里有一张hash表，维护者物理机和客户机的内存地址映射表。 那么如何被建立的呢？</p>
<p>当发生页故障的时候，VMM搜索客户页表，如果不存在客户线性地址VGA 到 客户机物理地址 GPA的转换，那么则返回给虚拟机异常，由虚拟机处理页故障。<br>如果存在映射关系，则先去寻找QEMU地址空间的主机线性地址 HVA， 如果不存在 HVA 映射到 HPA， 那么kernel 去分配物理地址。 然后VMM可以使用该HPA构建影子页表。 至此，影子页表建立完成。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/KVM/">KVM</a>
		  
			<a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a>
		  
			<a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/08/10/%E9%9D%A2%E8%AF%95%EF%BC%9Agolang-I/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">面试：golang-I</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/08/08/k8s%E6%BA%90%E7%A0%81/">
        <span class="next-text nav-default">k8s源码</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
