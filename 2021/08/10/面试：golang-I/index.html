<!DOCTYPE html>
<html>

	<head>
		
<title>面试：golang-I-Russshare</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">


<meta name="keywords" content="golang,面试,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4b5fe1472f22fa";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">
</head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Russshare</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg ">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/golang">golang</a></li>
            
            <li><a href="/tags/面试">面试</a></li>
            
            
        </ul>
        <h1>面试：golang-I</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                    <g>
                        <path fill="#12183A"
                            d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                        </path>
                    </g>
                </svg>
                
                <span> <a href="">Russshare</a></span>
                <p>2021-08-10 22:37:20</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34128839/article/details/94488565">golang 面试题(从基础到高级)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35406909/article/details/103818364?utm_medium=distribute.pc_relevant.none-task-blog-2~default~searchFromBaidu~default-2.pc_relevant_baidujshouduan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~searchFromBaidu~default-2.pc_relevant_baidujshouduan">Golang进阶面试题整理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/No_Game_No_Life_/article/details/118309813?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-11.pc_relevant_baidujshouduan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-11.pc_relevant_baidujshouduan">面试总结：Golang常见面试题汇总</a></p>
<p><a target="_blank" rel="noopener" href="https://yincheng.blog.csdn.net/article/details/80462619?utm_medium=distribute.pc_relevant.none-task-blog-2~default~searchFromBaidu~default-4.pc_relevant_baidujshouduan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~searchFromBaidu~default-4.pc_relevant_baidujshouduan">Golang精编100题-搞定golang面试</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48655626/article/details/108797759?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.pc_relevant_baidujshouduan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.pc_relevant_baidujshouduan">2020 腾讯社招 Golang后端 面试题解析</a></p>
<h2 id="golang面试题整理"><a href="#golang面试题整理" class="headerlink" title="golang面试题整理"></a>golang面试题整理</h2><h3 id="１、go的调度–GPM"><a href="#１、go的调度–GPM" class="headerlink" title="１、go的调度–GPM"></a>１、go的调度–GPM</h3><p>这个调度模型—<br>1、我先讲一下GPM分别代表什么，G就是我们所常说的goroutine对象，每次go调用的时候，都会创建一个G对象。P就是代表一个处理器，在我看的书中，也可以把P比作一个运送货物的调度工人。M就是一个线程，G任务就是在M上运行。</p>
<p>2、每次我创建一个G对象时候，就好把这个G对面加入到创建这个G对象所在的队列，本地队列。当本地队列加满了的时候，就会加入到全局队列。当一个本地队列处理完毕，就从全局队列一次性转移P个G到本地队列，当全局队列也满的时候，就从其他的本地队列一次性偷一半过来。</p>
<p>3、现在我们在看看M，我们知道M是G的真正执行者，创建一个M，我们从golang的官方图知道P-M应该连接的，所以创建一个M先找到一个空闲的P，如果有空闲的我们就调用系统api。windos就是CreateThread，linux就是clone，这样来创建，我们在gogroupmax设置了P的数量，当没空闲的P我们可能只返回去，因为我们要保证不同的线程之间的并行。</p>
<p>4、其实原本的是进程之间是并发的，随着这种多集成，处理器上出现了多核，可以是进程创建多个的线程进行并行处理，而golang这样的调度模型，在原本的并行的线程上又封装了一次，通过processor调度，实现了在同一个线程的协程处理并发，不同线程的协程队里并行。</p>
<p>5、那么我们就可以看出来，golang协程就不依赖于操作系统和其提供的线程，变成了某种意义上的用户态线程，在用户态的线程进行切换不需要时钟控制、系统调用<br>等机制，我可能记得不准了，我记得线程切换是需要16个寄存器，但是协程只需要3个，所以切换的效率很高。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>6、协程占用的内存很小，<br>执行go协程只需要极少的栈内存（大概是4～5KB），默认情况下，而线程栈的大小为1MB。goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，。</p>
<h3 id="２、go-struct能不能比较"><a href="#２、go-struct能不能比较" class="headerlink" title="２、go struct能不能比较"></a>２、go struct能不能比较</h3><p>因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型</p>
<h3 id="３、go-defer（for-defer），先进后出，后进先出"><a href="#３、go-defer（for-defer），先进后出，后进先出" class="headerlink" title="３、go defer（for defer），先进后出，后进先出"></a>３、go defer（for defer），先进后出，后进先出</h3><p>func b() {<br>    for i := 0; i &lt; 4; i++ {<br>        defer fmt.Print(i)<br>    }<br>}</p>
<h3 id="４、select可以用于什么，常用语gorotine的完美退出"><a href="#４、select可以用于什么，常用语gorotine的完美退出" class="headerlink" title="４、select可以用于什么，常用语gorotine的完美退出"></a>４、select可以用于什么，常用语gorotine的完美退出</h3><p>早期的select函数是用来监控一系列的文件句柄，一旦其中一个文件句柄发生IO操作，该select调用就会被返回。golang在语言级别直接支持select，用于处理异步IO问题。使用的时候要注意，如果没有default，select 会一直等待等到某个 case 语句完成，否则一直阻塞。</p>
<p>基于这种机制，可以使用select实现channel读取超时的机制。</p>
<h3 id="５、context包的用途"><a href="#５、context包的用途" class="headerlink" title="５、context包的用途"></a>５、context包的用途</h3><p>Context通常被译作上下文，它是一个比较抽象的概念，其本质，是【上下上下】存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine。</p>
<p>在复杂的网络高并发环境，channel是难以满足我们的使用要求，需要用到context。</p>
<p>golang 中的创建一个新的 goroutine , 并不会返回像c语言类似的pid，所有我们不能从外部杀死某个goroutine，所有我就得让它自己结束，之前我们用 channel ＋ select 的方式，来解决这个问题，但是有些场景实现起来比较麻烦，例如由一个请求衍生出的各个 goroutine 之间需要满足一定的约束关系，以实现一些诸如有效期，中止routine树，传递请求全局变量之类的功能。于是google 就为我们提供一个解决方案，开源了 context 包。使用 context 实现上下文功能约定需要在你的方法的传入参数的第一个传入一个 context.Context 类型的变量。</p>
<p>context包可以提供一个请求从API请求边界到各goroutine的请求域数据传递、取消信号及截至时间等能力。</p>
<p>  Done() &lt;-chan struct{}</p>
<p>   Err() error</p>
<p>   Deadline() (deadline time.Time, ok bool)</p>
<p>   Value(key interface{}) interface{}</p>
<h3 id="６、client如何实现长连接"><a href="#６、client如何实现长连接" class="headerlink" title="６、client如何实现长连接"></a>６、client如何实现长连接</h3><p>server是设置超时时间，for循环遍历的<br>和短链接基本一样，只需要循环读取server端返回的response即可。</p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/10654">golang中如何使用http长链接（client端）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MyUniverse/p/11621169.html">golang长连接和短连接的学习</a></p>
<h3 id="７、主协程如何等其余协程完再操作"><a href="#７、主协程如何等其余协程完再操作" class="headerlink" title="７、主协程如何等其余协程完再操作"></a>７、主协程如何等其余协程完再操作</h3><p>使用channel进行通信，context,select</p>
<h3 id="８、slice，len，cap，共享，扩容"><a href="#８、slice，len，cap，共享，扩容" class="headerlink" title="８、slice，len，cap，共享，扩容"></a>８、slice，len，cap，共享，扩容</h3><p>append函数，因为slice底层数据结构是，由数组、len、cap组成，所以，在使用append扩容时，会查看数组后面有没有连续内存快，有就在后面添加，没有就重新生成一个大的素组</p>
<h3 id="９、map如何顺序读取"><a href="#９、map如何顺序读取" class="headerlink" title="９、map如何顺序读取"></a>９、map如何顺序读取</h3><p>map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。</p>
<h3 id="１０、实现set"><a href="#１０、实现set" class="headerlink" title="１０、实现set"></a>１０、实现set</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> inter <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[inter]<span class="hljs-keyword">bool</span><br>    sync.RWMutex<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Set</span></span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;Set&#123;<br>    m: <span class="hljs-keyword">map</span>[inter]<span class="hljs-keyword">bool</span>&#123;&#125;,<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span> <span class="hljs-title">Add</span><span class="hljs-params">(item inter)</span></span> &#123;<br>    s.Lock()<br>    <span class="hljs-keyword">defer</span> s.Unlock()<br>    s.m[item] = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="１１、实现消息队列（多生产者，多消费者）"><a href="#１１、实现消息队列（多生产者，多消费者）" class="headerlink" title="１１、实现消息队列（多生产者，多消费者）"></a>１１、实现消息队列（多生产者，多消费者）</h3><p>OPQ</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39397165/article/details/108686391">手把手教姐姐写消息队列（golang）- 使用channel实现消息队列</a></p>
<h3 id="１２、大文件排序"><a href="#１２、大文件排序" class="headerlink" title="１２、大文件排序"></a>１２、大文件排序</h3><p>归并排序，分而治之,拆分为小文件，在排序</p>
<h3 id="１３、基本排序，哪些是稳定的"><a href="#１３、基本排序，哪些是稳定的" class="headerlink" title="１３、基本排序，哪些是稳定的"></a>１３、基本排序，哪些是稳定的</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示）</a></p>
<p>插入排序、冒泡排序、归并排序、计数排序、桶排序、基数排序</p>
<h3 id="１４、http-get跟head"><a href="#１４、http-get跟head" class="headerlink" title="１４、http get跟head"></a>１４、http get跟head</h3><p>HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p>
<h3 id="１５、http-401-403"><a href="#１５、http-401-403" class="headerlink" title="１５、http 401,403"></a>１５、http 401,403</h3><p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>
<h3 id="１６、http-keep-alive"><a href="#１６、http-keep-alive" class="headerlink" title="１６、http keep-alive"></a>１６、http keep-alive</h3><p>client发出的HTTP请求头需要增加Connection:keep-alive字段<br>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接</p>
<h3 id="１７、http能不能一次连接多次请求，不等后端返回"><a href="#１７、http能不能一次连接多次请求，不等后端返回" class="headerlink" title="１７、http能不能一次连接多次请求，不等后端返回"></a>１７、http能不能一次连接多次请求，不等后端返回</h3><p>http本质上是使用socket连接，因此发送请求，接写入tcp缓冲，是可以多次进行的，这也是http是无状态的原因</p>
<h3 id="１８、tcp与udp区别，udp优点，适用场景"><a href="#１８、tcp与udp区别，udp优点，适用场景" class="headerlink" title="１８、tcp与udp区别，udp优点，适用场景"></a>１８、tcp与udp区别，udp优点，适用场景</h3><h4 id="这个文章很好的"><a href="#这个文章很好的" class="headerlink" title="这个文章很好的"></a>这个文章很好的</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BK2H7JQIo6zOrXYg9RcbeA">一文搞定 UDP 和 TCP 高频面试题！</a></p>
<p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景</p>
<p>6.1 <strong>面向报文</strong><br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<p>6.2 <strong>面向字节流</strong><br>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<p>关于拥塞控制，流量控制</p>
<p><strong>什么时候应该使用TCP</strong>？<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<p><strong>什么时候应该使用UDP</strong>？<br>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p>
<h3 id="18-1-Socket原理讲解"><a href="#18-1-Socket原理讲解" class="headerlink" title="18.1 Socket原理讲解"></a>18.1 Socket原理讲解</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pashanhu6402/article/details/96428887">Socket原理讲解</a></p>
<h3 id="１９、time-wait的作用"><a href="#１９、time-wait的作用" class="headerlink" title="１９、time-wait的作用"></a>１９、time-wait的作用</h3><p>time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。</p>
<p>然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，可为30s，1min或2min。2msl就是2倍的这个时间。工程上为2min，2msl就是4min。但一般根据实际的网络情况进行确定。</p>
<p>原因1：为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报，那么服务器就不能按正常步骤进入close状态。</p>
<p>原因2：在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。</p>
<p><strong>详细</strong>—<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51961509">原文</a><br>然后，为什么要持续这么长的时间呢？</p>
<p>原因1：为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。</p>
<p>原因2：在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。也就是防止我们上一篇文章 为什么tcp是三次握手而不是两次握手？ 中说的：已经失效的连接请求报文段出现在本次连接中。如果没有的话就可能这样：这次连接一挥手完马上就结束了，没有timewait。这次连接中有个迷失在网络中的syn包，然后下次连接又马上开始，下个连接发送syn包，迷失的syn包忽然又到达了对面，所以对面可能同时收到或者不同时间收到请求连接的syn包，然后就出现问题了。</p>
<h3 id="２０、数据库如何建索引"><a href="#２０、数据库如何建索引" class="headerlink" title="２０、数据库如何建索引"></a>２０、数据库如何建索引</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_24813315/article/details/80145540?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6">深入了解-数据库建索引</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weberhuangxingbo/article/details/83894153">数据库创建索引的几种方法</a></p>
<h3 id="２１、孤儿进程，僵尸进程"><a href="#２１、孤儿进程，僵尸进程" class="headerlink" title="２１、孤儿进程，僵尸进程"></a>２１、孤儿进程，僵尸进程</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yadongliang/p/13407666.html">孤儿进程与僵尸进程[总结]</a></p>
<h3 id="２２、死锁条件，如何避免"><a href="#２２、死锁条件，如何避免" class="headerlink" title="２２、死锁条件，如何避免"></a>２２、死锁条件，如何避免</h3><h3 id="２３、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"><a href="#２３、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程" class="headerlink" title="２３、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"></a>２３、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</h3><p><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/76891781364/">LINUX中如何查看某个端口是否被占用</a><br>netstat  -anp  |grep  3306</p>
<p>top查看机器负载<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/76891781364/">linux top命令详解（负载、任务、cpu、内存）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanchunsi/article/details/79295801?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6">Linux下查看CPU、内存占用率</a></p>
<p>dstat<br>每秒cpu使用率情况获取</p>
<p>iostat</p>
<h3 id="２４、git文件版本，使用顺序，merge跟rebase"><a href="#２４、git文件版本，使用顺序，merge跟rebase" class="headerlink" title="２４、git文件版本，使用顺序，merge跟rebase"></a>２４、git文件版本，使用顺序，merge跟rebase</h3><p>Git merge是用来合并两个分支的。</p>
<p>git merge b      # 将b分支合并到当前分支</p>
<p>git rebase b        也是把 b分支合并到当前分支</p>
<p><strong>什么是 rebase?</strong></p>
<p><strong>git rebase 你其实可以把它理解成是“重新设置基线”，将你的当前分支重新设置开始点。</strong></p>
<p>这个时候才能知道你当前分支于你需要比较的分支之间的差异。</p>
<p>原理很简单：rebase需要基于一个分支来设置你当前的分支的基线，这基线就是当前分支的开始时间轴向后移动到最新的跟踪分支的最后面，这样你的当前分支就是最新的跟踪分支。</p>
<p>这里的操作是基于文件事务处理的，所以你不用怕中间失败会影响文件的一致性。在中间的过程中你可以随时取消rebase 事务。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#--------------------</span><br>git checkout <span class="hljs-literal">master</span><br>git pull<br>git checkout local<br><span class="hljs-comment">#切换到local分支后， 就是修改代码</span><br><span class="hljs-comment">#修改完了， 就正常提交代码-------git commit</span><br><span class="hljs-comment">#如果有多次local分支的提交，就合并，只有一次可以不合并</span><br>git rebase -i HEAD~<span class="hljs-number">2</span>  //合并提交 --- <span class="hljs-number">2</span>表示合并两个<br><span class="hljs-comment">#将master内容合并到local</span><br>git rebase <span class="hljs-literal">master</span>----&gt;解决冲突---&gt;git rebase --continue<br><span class="hljs-comment">#再起切换到master或其他目标分支</span><br>git checkout <span class="hljs-literal">master</span><br><span class="hljs-comment">#将local合并到master</span><br>git merge local<br><span class="hljs-comment">#推送到远程仓库</span><br>git push<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012150179/article/details/14047183?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control">Git使用之——冲突解决一（git merge conflict）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35770969/article/details/79925261?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6">Git冲突与解决冲突</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xxooff/article/details/79423767?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">git解决冲突</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4079284dd970">git rebase 还是 merge的使用场景最通俗的解释</a></p>
<h3 id="２６、Slice与数组区别，Slice底层结构"><a href="#２６、Slice与数组区别，Slice底层结构" class="headerlink" title="２６、Slice与数组区别，Slice底层结构"></a>２６、Slice与数组区别，Slice底层结构</h3><p>在golang中有数组和Slice两种数据结构，Slice是基于数组的实现，是长度动态不固定的数据结构，本质上是一个对数组字序列的引用，提供了对数组的轻量级访问。</p>
<p>slice是一个特殊的引用类型,但是它自身也是个结构体</p>
<p>属性len表示可用元素数量,读写操作不能超过这个限制,不然就会panic</p>
<p>属性cap表示最大扩张容量,当然这个扩张容量也不是无限的扩张,它是受到了底层数组array的长度限制,超出了底层array的长度就会panic</p>
<p>切片追加append()</p>
<p>(1)go是有数组的,只是平时用切片比较多。数组大小一旦创建就不能改变,数组长度大于元素个数的时候会用0补位，这跟其他语言是相通的。</p>
<p>(2)切片slice可以看作是对数组的一切操作,它是一个引用数据类型,其数据结构包括底层数组的地址,以及元素可操作长度len或可扩容长度cap。</p>
<p>(3)要想突破slice的扩容cap限制进行无限扩容就需要使用append()函数进行操作。如果append追加的元素后slice的总长度不超过底层数组的总长度，那么slice引用的地址不会发生改变,反之引用地址会变成新的数组的地址。</p>
<p>(4)slice是一个抽象的概念,它存在的意义在于方便对一个顺序结构进行一些方便操作,例如查找,排序,追加等等,这个类似于python的list。</p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/181336.htm">Golang中的Slice与数组及区别详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunlongl/article/details/115998466">golang中slice扩容机制</a></p>
<h3 id="２９、Go的反射包怎么找到对应的方法（这里忘记怎么问的，直接说不会，只用了DeepEqual，简单讲了DeepEqual）"><a href="#２９、Go的反射包怎么找到对应的方法（这里忘记怎么问的，直接说不会，只用了DeepEqual，简单讲了DeepEqual）" class="headerlink" title="２９、Go的反射包怎么找到对应的方法（这里忘记怎么问的，直接说不会，只用了DeepEqual，简单讲了DeepEqual）"></a>２９、Go的反射包怎么找到对应的方法（这里忘记怎么问的，直接说不会，只用了DeepEqual，简单讲了DeepEqual）</h3><p><a target="_blank" rel="noopener" href="https://chenjiehua.me/golang/golang-call-method-by-reflection.html">Golang利用反射reflect动态调用方法 </a></p>
<p>reflect.ValueOf() 返回值</p>
<p>reflect.TypeOf() 返回值类型</p>
<p>reflect.Value.Elem() 的作用已经在前面稍微提到了，主要就是返回一个 interface 或者 pointer 的值：</p>
<p><strong>可以根据 v.MethodByName(name)获取方法</strong></p>
<p>比较map<br>由于reflect.DeepEqual需要经过反射操作，效率比我们自己写的函数差的多了<br>在一般情况下，这点儿性能损失不算什么，尤其在不确定类型需要反射的时候，更是我们不可不用的强大工具。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">注册方法<br>我们再定义一个保存 M 所有方法的 map struct ：<br><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">Handler</span> struct &#123;<br>	Func   reflect.<span class="hljs-keyword">Value</span><br>	<span class="hljs-keyword">In</span>     reflect.<span class="hljs-keyword">Type</span><br>	NumIn  <span class="hljs-type">int</span><br>	<span class="hljs-keyword">Out</span>    reflect.<span class="hljs-keyword">Type</span><br>	NumOut <span class="hljs-type">int</span><br>&#125;<br><br>然后我们就可以来遍历结构体 M 的所有方法了：<br><br>func main() &#123;<br>	handlers := make(map[string]*<span class="hljs-keyword">Handler</span>)<br>	v := reflect.ValueOf(&amp;M&#123;&#125;)<br>	t := reflect.TypeOf(&amp;M&#123;&#125;)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;<br>		<span class="hljs-type">name</span> := t.<span class="hljs-keyword">Method</span>(i).Name<br>		// 可以根据 i 来获取实例的方法，也可以用 v.MethodByName(<span class="hljs-type">name</span>) 获取 <br>		m := v.<span class="hljs-keyword">Method</span>(i)<br>		// 这个例子我们只获取第一个输入参数和第一个返回参数<br>		<span class="hljs-keyword">in</span> := m.<span class="hljs-keyword">Type</span>().<span class="hljs-keyword">In</span>(<span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">out</span> := m.<span class="hljs-keyword">Type</span>().<span class="hljs-keyword">Out</span>(<span class="hljs-number">0</span>)<br>		handlers[<span class="hljs-type">name</span>] = &amp;<span class="hljs-keyword">Handler</span>&#123;<br>			Func:   m,<br>			<span class="hljs-keyword">In</span>:     <span class="hljs-keyword">in</span>,<br>			NumIn:  m.<span class="hljs-keyword">Type</span>().NumIn(),<br>			<span class="hljs-keyword">Out</span>:    <span class="hljs-keyword">out</span>,<br>			NumOut: m.<span class="hljs-keyword">Type</span>().NumOut(),<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="３０、Redis基本数据结构"><a href="#３０、Redis基本数据结构" class="headerlink" title="３０、Redis基本数据结构"></a>３０、Redis基本数据结构</h3><p>Redis有5种基本数据结构：String(字符串)、list(列表)、set(集合)、hash(哈希)、zset(有序集合)</p>
<p>[这篇文章挺好，就是那个关于ziplist节省空间的理由看的有点不太顺畅，当然主要是因为我]</p>
<p>原文：从图可以看出快速列表其实就是由压缩列表和双向的指针组成，不过我们知道链表是两个指针的，也就是prev和next执行，这就是快速列表和linklist的一个不同点了。PS：然后redis设计时，为什么改成双向指针？假如和链表一样，用两个指针prev、next，同样可以实现遍<strong>历，不过双向指针有一个很明显的优点，就是占用的内存空间就相对少了。</strong>（这里应该是压缩链表明显优点）</p>
<p>我觉得应该是：因为双向链表占用的内存比压缩列表要多， 所以当创建新的列表键时， 列表会优先考虑使用压缩列表， 并且在有需要的时候， 才从压缩列表实现转换到双向链表实现。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mzq123/p/9710608.html">Redis学习笔记之Redis基本数据结构</a></p>
<h3 id="３１、Redis的List用过吗？底层怎么实现的？"><a href="#３１、Redis的List用过吗？底层怎么实现的？" class="headerlink" title="３１、Redis的List用过吗？底层怎么实现的？"></a>３１、Redis的List用过吗？底层怎么实现的？</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102422311">Redis列表list 底层原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Fly_as_tadpole/article/details/88212436">redis:list的底层实现–压缩列表</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javazhiyin/p/11063944.html">面试官：你看过Redis数据结构底层实现吗？</a></p>
<p>ziplist 是一个特殊的双向链表<br>特殊之处在于：没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。<br>牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度 更费内存。这是典型的“时间换空间”。</p>
<p>ziplist使用局限性<br>字段、值比较小，才会用ziplist。</p>
<p>压缩列表ziplist存储结构<br>ziplist使用连续的内存块，每一个节点（entry）都是连续存储的；ziplist 存储分布如下：</p>
<h3 id="3-1-1、Redis有序集内部实现原理分析"><a href="#3-1-1、Redis有序集内部实现原理分析" class="headerlink" title="3 1.1、Redis有序集内部实现原理分析"></a>3 1.1、Redis有序集内部实现原理分析</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/WJ5888/p/4516782.html">Redis有序集内部实现原理分析</a></p>
<p>跳表</p>
<h3 id="３２、Mysql的索引有几种，时间复杂度"><a href="#３２、Mysql的索引有几种，时间复杂度" class="headerlink" title="３２、Mysql的索引有几种，时间复杂度"></a>３２、Mysql的索引有几种，时间复杂度</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41583e87c061">MySQL中的几种索引介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mrzhouxiaofei/article/details/79940958?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.baidujsUnder6">MySQL 之全文索引</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weiliangliang111/article/details/51333169?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">数据库索引到底是什么，是怎样工作的？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/b_x_p/article/details/86434387?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.baidujsUnder6">深入理解MySQL索引之B+Tree</a></p>
<h3 id="３３、InnoDb是表锁还是行锁，为什么（这里答不出来为什么，只说了行锁）"><a href="#３３、InnoDb是表锁还是行锁，为什么（这里答不出来为什么，只说了行锁）" class="headerlink" title="３３、InnoDb是表锁还是行锁，为什么（这里答不出来为什么，只说了行锁）"></a>３３、InnoDb是表锁还是行锁，为什么（这里答不出来为什么，只说了行锁）</h3><p>innodb的行级锁是依赖于索引实现的，where条件后的字段有索引字段才能应用行级锁定，否则还会是表级锁。innodb对没索引的字段起不了作用（知乎某前辈看到的）。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/workharder/p/12810647.html">innodb是行锁还是表锁</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mingxuan/archive/2011/10/11/2207560.html">关于MYSQL Innodb 锁行还是锁表</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35642036/article/details/82820178">MyISAM与InnoDB 的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27607965/article/details/79925288">mysql中innodb和myisam对比及索引原理区别</a></p>
<h3 id="３４、Go的channel（有缓冲和无缓冲）"><a href="#３４、Go的channel（有缓冲和无缓冲）" class="headerlink" title="３４、Go的channel（有缓冲和无缓冲）"></a>３４、Go的channel（有缓冲和无缓冲）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010853261/article/details/85231944">Golang-Channel原理解析</a></p>
<h3 id="３５、退出程序时怎么防止channel没有消费完，这里一开始有点没清楚面试官问的，然后说了监听中断信号，做退出前的处理，然后面试官说不是这个意思，然后说发送前先告知长度，长度要是不知道呢？close-channel下游会受到0值，可以利用这点（这里也有点跟面试官说不明白）"><a href="#３５、退出程序时怎么防止channel没有消费完，这里一开始有点没清楚面试官问的，然后说了监听中断信号，做退出前的处理，然后面试官说不是这个意思，然后说发送前先告知长度，长度要是不知道呢？close-channel下游会受到0值，可以利用这点（这里也有点跟面试官说不明白）" class="headerlink" title="３５、退出程序时怎么防止channel没有消费完，这里一开始有点没清楚面试官问的，然后说了监听中断信号，做退出前的处理，然后面试官说不是这个意思，然后说发送前先告知长度，长度要是不知道呢？close channel下游会受到0值，可以利用这点（这里也有点跟面试官说不明白）"></a>３５、退出程序时怎么防止channel没有消费完，这里一开始有点没清楚面试官问的，然后说了监听中断信号，做退出前的处理，然后面试官说不是这个意思，然后说发送前先告知长度，长度要是不知道呢？close channel下游会受到0值，可以利用这点（这里也有点跟面试官说不明白）</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1186452">如何优雅的关闭Go Channel</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4327542/blog/3373426">退出程序时，防止无缓存的channel没有消费完的方法</a></p>
<h3 id="３６、用过什么消息中间件之类吗？"><a href="#３６、用过什么消息中间件之类吗？" class="headerlink" title="３６、用过什么消息中间件之类吗？"></a>３６、用过什么消息中间件之类吗？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wqc19920906/article/details/82193316/">消息中间件（一）MQ详解及四大MQ比较</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wqc19920906/article/details/82193593?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-17.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-17.baidujsUnder6">消息中间件（二）MQ使用场景</a></p>
<p>一般RocketMQ可以的，Kafka偏向日志采集</p>
<h3 id="３８、生产者消费者模式，手写代码（Go直接使用channel实现很简单，还想着面试官会不会不让用channel实现，不用channel的可以使用数组加条件变量），channel缓冲长度怎么决定，怎么控制上游生产速度过快，这里没说出解决方案，只是简单说了channel长度可以与上下游的速度比例成线性关系，面试官说这是一种解决方案"><a href="#３８、生产者消费者模式，手写代码（Go直接使用channel实现很简单，还想着面试官会不会不让用channel实现，不用channel的可以使用数组加条件变量），channel缓冲长度怎么决定，怎么控制上游生产速度过快，这里没说出解决方案，只是简单说了channel长度可以与上下游的速度比例成线性关系，面试官说这是一种解决方案" class="headerlink" title="３８、生产者消费者模式，手写代码（Go直接使用channel实现很简单，还想着面试官会不会不让用channel实现，不用channel的可以使用数组加条件变量），channel缓冲长度怎么决定，怎么控制上游生产速度过快，这里没说出解决方案，只是简单说了channel长度可以与上下游的速度比例成线性关系，面试官说这是一种解决方案"></a>３８、生产者消费者模式，手写代码（Go直接使用channel实现很简单，还想着面试官会不会不让用channel实现，不用channel的可以使用数组加条件变量），channel缓冲长度怎么决定，怎么控制上游生产速度过快，这里没说出解决方案，只是简单说了channel长度可以与上下游的速度比例成线性关系，面试官说这是一种解决方案</h3><p><strong>第一步理解这个模式</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luego/p/12048857.html">生产者/消费者模式的理解及实现（整理)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chentingk/p/6497107.html">生产者消费者模式-Java实现</a></p>
<p><strong>第二部golang实现</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/secondtonone1/p/11843269.html">golang实现生产者消费者模型</a></p>
<h3 id="３９、手写循环队列"><a href="#３９、手写循环队列" class="headerlink" title="３９、手写循环队列"></a>３９、手写循环队列</h3><p><a target="_blank" rel="noopener" href="https://www.coder55.com/article/7350">循环队列实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/9527s/p/14211228.html">golang实现循环队列</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31122953">Go 原子操作</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/3557">Go语言atomic原子操作</a></p>
<h3 id="４０、写的循环队列是不是线程安全，不是，怎么保证线程安全，加锁，效率有点低啊，然后面试官就提醒Go推崇原子操作和channel"><a href="#４０、写的循环队列是不是线程安全，不是，怎么保证线程安全，加锁，效率有点低啊，然后面试官就提醒Go推崇原子操作和channel" class="headerlink" title="４０、写的循环队列是不是线程安全，不是，怎么保证线程安全，加锁，效率有点低啊，然后面试官就提醒Go推崇原子操作和channel"></a>４０、写的循环队列是不是线程安全，不是，怎么保证线程安全，加锁，效率有点低啊，然后面试官就提醒Go推崇原子操作和channel</h3><h3 id="４１、写完代码面试官说后面问的问题回答就可以，不知道的话没关系"><a href="#４１、写完代码面试官说后面问的问题回答就可以，不知道的话没关系" class="headerlink" title="４１、写完代码面试官说后面问的问题回答就可以，不知道的话没关系"></a>４１、写完代码面试官说后面问的问题回答就可以，不知道的话没关系</h3><h3 id="４２、Linux会不会，只会几个命令，面试官就说一共也就一百多个命令"><a href="#４２、Linux会不会，只会几个命令，面试官就说一共也就一百多个命令" class="headerlink" title="４２、Linux会不会，只会几个命令，面试官就说一共也就一百多个命令"></a>４２、Linux会不会，只会几个命令，面试官就说一共也就一百多个命令</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23329167/article/details/83856430/">Linux常用命令</a></p>
<h3 id="４３、TimeWait和CloseWait原因"><a href="#４３、TimeWait和CloseWait原因" class="headerlink" title="４３、TimeWait和CloseWait原因"></a>４３、TimeWait和CloseWait原因</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzhongcy/article/details/38851271?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.baidujsUnder6">端口状态 LISTENING、ESTABLISHED、TIME_WAIT及CLOSE_WAIT详解，以及三次握手，滑动窗口</a></p>
<p><a target="_blank" rel="noopener" href="https://libaineu2004.blog.csdn.net/article/details/78886182?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">CLOSE_WAIT状态的原因与解决方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/10936657.html#_label0">服务器出现大量close_wait，我们来说说到底是怎么回事？（以tomcat为例）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yucdsn/article/details/81092679">服务器出现TIME_WAIT和CLOSE_WAIT的原因以及解决方法</a></p>
<p>短连接—2MSL</p>
<p>出现了大量CLOSE_WAIT的影响—综上所述close_wait对系统影响：</p>
<ol>
<li>占用系统内存</li>
<li>如果连接数满了就不能对相应的对段端口创建连接了</li>
<li>假设你的程序会去连接另一个服务，而未正常关闭，那么可能导致你的程序超过最大连接数的时候报异常，引起连锁反应甚至导致程序崩溃</li>
</ol>
<h3 id="４４、线段树了解吗？不了解，字典树？了解"><a href="#４４、线段树了解吗？不了解，字典树？了解" class="headerlink" title="４４、线段树了解吗？不了解，字典树？了解"></a>４４、线段树了解吗？不了解，字典树？了解</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zearot/article/details/48299459">线段树详解 （原理，实现与应用）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39778570/article/details/81990417">字典树(前缀树)</a></p>
<h3 id="４５、看过啥源码，nsq（Go的消息中间件），简单问了我里面的waitgroup包证明我看过"><a href="#４５、看过啥源码，nsq（Go的消息中间件），简单问了我里面的waitgroup包证明我看过" class="headerlink" title="４５、看过啥源码，nsq（Go的消息中间件），简单问了我里面的waitgroup包证明我看过"></a>４５、看过啥源码，nsq（Go的消息中间件），简单问了我里面的waitgroup包证明我看过</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunfeng482/article/details/72856762?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">Kafka、RabbitMQ、RocketMQ等消息中间件的介绍和对比</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lldouble/article/details/82021861">nsq 优秀的消息队列</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/li-peng/p/11435083.html">剖析nsq消息队列(一) 简介及去中心化实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013735511/article/details/82555419?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.baidujsUnder6">NSQ消息发送机制</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pkueecser/article/details/50613989?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.baidujsUnder6">消息队列选型<a href="%E5%A4%87%E9%80%89:RabbitMQ/NSQ/RocketMQ/disque/Kafka">首选Kafka</a></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010214802/article/details/89539572?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6">消息队列kafka和NSQ的区别与比较</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35063002/article/details/89446761?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">NATS 分布式消息队列系统</a></p>
<h3 id="４６、sync-Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？不清楚，没看过这个的源码"><a href="#４６、sync-Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？不清楚，没看过这个的源码" class="headerlink" title="４６、sync.Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？不清楚，没看过这个的源码"></a>４６、sync.Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？不清楚，没看过这个的源码</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunsky303/p/9706210.html">深入Golang之sync.Pool详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhc/article/details/111032332">Golang之sync.Pool对象池对象重用机制总结</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/erlib/article/details/51153474?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-4.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-4.baidujsUnder6">一个简单的例子阐述Go的对象复用思想</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yongjian_lian/article/details/42058893?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-14.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-14.baidujsUnder6">go语言的官方包sync.Pool的实现原理和适用场景</a></p>
<h3 id="４７、有什么问题吗？评价？基础不错，Linux尚缺，Go的理解不够深入，高级数据结构不了解，优点是看源码"><a href="#４７、有什么问题吗？评价？基础不错，Linux尚缺，Go的理解不够深入，高级数据结构不了解，优点是看源码" class="headerlink" title="４７、有什么问题吗？评价？基础不错，Linux尚缺，Go的理解不够深入，高级数据结构不了解，优点是看源码"></a>４７、有什么问题吗？评价？基础不错，Linux尚缺，Go的理解不够深入，高级数据结构不了解，优点是看源码</h3><h3 id="４８、后面面试官讲了他们做的东西，主要是广告部分，说日均数据量至少百万以上，多达上亿，高并发使用Go支撑，有微服务，服务治理，说我需要学的东西挺多的"><a href="#４８、后面面试官讲了他们做的东西，主要是广告部分，说日均数据量至少百万以上，多达上亿，高并发使用Go支撑，有微服务，服务治理，说我需要学的东西挺多的" class="headerlink" title="４８、后面面试官讲了他们做的东西，主要是广告部分，说日均数据量至少百万以上，多达上亿，高并发使用Go支撑，有微服务，服务治理，说我需要学的东西挺多的"></a>４８、后面面试官讲了他们做的东西，主要是广告部分，说日均数据量至少百万以上，多达上亿，高并发使用Go支撑，有微服务，服务治理，说我需要学的东西挺多的</h3><h3 id="４９、证明二叉树的叶子节点跟度数为2的节点的关系"><a href="#４９、证明二叉树的叶子节点跟度数为2的节点的关系" class="headerlink" title="４９、证明二叉树的叶子节点跟度数为2的节点的关系"></a>４９、证明二叉树的叶子节点跟度数为2的节点的关系</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ttss/p/4148720.html">二叉树的叶子节点与度为2的节点的关系</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Xieyang-blog/p/8532954.html">关于二叉树中度为0与度为2节点数关系证明</a></p>
<h3 id="５０、唯一索引和主键索引"><a href="#５０、唯一索引和主键索引" class="headerlink" title="５０、唯一索引和主键索引"></a>５０、唯一索引和主键索引</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38750084/article/details/84885565?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">sql：主键（primary key）和唯一索引（unique index）区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jmx_bigdata/article/details/88873268?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-8.baidujsUnder6">MYSQL的索引(主键索引、唯一索引、普通索引、全文索引)</a></p>
<h3 id="５１、智能指针"><a href="#５１、智能指针" class="headerlink" title="５１、智能指针"></a>５１、智能指针</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/flowing_wind/article/details/81301001">【C++】智能指针详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xt_xiaotian/article/details/5714477?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.baidujsUnder6">C++ 智能指针详解</a></p>
<h3 id="５２、字符串解析为数字（考虑浮点型）"><a href="#５２、字符串解析为数字（考虑浮点型）" class="headerlink" title="５２、字符串解析为数字（考虑浮点型）"></a>５２、字符串解析为数字（考虑浮点型）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qwdafedv/article/details/80453511?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.baidujsUnder6">golang string、int、int64 float 互相转换</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_34322082/article/details/81106091?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">golang 数据类型之间的转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wt645631686/p/9645752.html">Golang字符串解析成数字</a></p>
<h3 id="５３、单点登录，tcp粘包"><a href="#５３、单点登录，tcp粘包" class="headerlink" title="５３、单点登录，tcp粘包"></a>５３、单点登录，tcp粘包</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ywlaker/p/6113927.html">单点登录原理与简单实现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41047704/article/details/85340311">什么是TCP粘包？怎么解决这个问题</a></p>
<h3 id="５４、手写洗牌"><a href="#５４、手写洗牌" class="headerlink" title="５４、手写洗牌"></a>５４、手写洗牌</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/benben_2015/article/details/79996849?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6">Go随机打乱数组</a></p>
<h3 id="５５、处理粘包断包实现，面试官以为是negle算法有关，解释了下negle跟糊涂窗口综合征有关，然后面试官觉得其他项目是crud就没问了"><a href="#５５、处理粘包断包实现，面试官以为是negle算法有关，解释了下negle跟糊涂窗口综合征有关，然后面试官觉得其他项目是crud就没问了" class="headerlink" title="５５、处理粘包断包实现，面试官以为是negle算法有关，解释了下negle跟糊涂窗口综合征有关，然后面试官觉得其他项目是crud就没问了"></a>５５、处理粘包断包实现，面试官以为是negle算法有关，解释了下negle跟糊涂窗口综合征有关，然后面试官觉得其他项目是crud就没问了</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whucs2/article/details/83692648?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">Go 实现洗牌算法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wo198711203217/article/details/72900742?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.baidujsUnder6">GOLANG随机数生成方法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011304970/article/details/72721747?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.baidujsUnder6">Go生成随机数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whucs2/article/details/83692648?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">通过rand把数组顺序随机打乱</a></p>
<h3 id="５６、goroutine调度用了什么系统调用，这个不会，面试官想从go问到操作系统，然后以为操作系统基础不好，就问了操作系统问题"><a href="#５６、goroutine调度用了什么系统调用，这个不会，面试官想从go问到操作系统，然后以为操作系统基础不好，就问了操作系统问题" class="headerlink" title="５６、goroutine调度用了什么系统调用，这个不会，面试官想从go问到操作系统，然后以为操作系统基础不好，就问了操作系统问题"></a>５６、goroutine调度用了什么系统调用，这个不会，面试官想从go问到操作系统，然后以为操作系统基础不好，就问了操作系统问题</h3><p><a href="https://riddlego.github.io/2021/07/13/golang%E7%9A%84GPM%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%83%EF%BC%89/">golang的GPM调度模型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/inception6-lxc/p/9073983.html">操作系统常见面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/78304294?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.baidujsUnder6">操作系统面试问题集锦</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014796694/article/details/82150070">C++面试之Linux操作系统</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaohong_bo/article/details/89552188?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">进程间通讯的7种方式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wm12345645/article/details/82381407?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.baidujsUnder6">面试题：进程间通信的方式</a></p>
<h3 id="５７、进程虚拟空间分布，全局变量放哪里？答上来了，操作系统就不问了"><a href="#５７、进程虚拟空间分布，全局变量放哪里？答上来了，操作系统就不问了" class="headerlink" title="５７、进程虚拟空间分布，全局变量放哪里？答上来了，操作系统就不问了"></a>５７、进程虚拟空间分布，全局变量放哪里？答上来了，操作系统就不问了</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Joezzz/p/9803344.html">进程的虚拟地址空间分布</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bullbat/article/details/7318269">进程虚拟地址空间之数据分区存放</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangxiaolong_china/article/details/6844325?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.baidujsUnder6">进程地址空间分布</a></p>
<h3 id="５８、有没有网络编程，有，怎么看连接状态？netstat，有哪些？ESTABLISHED，LISTEN等等，有异常情况吗？TIME-WAIT很多，为什么？大量短链接"><a href="#５８、有没有网络编程，有，怎么看连接状态？netstat，有哪些？ESTABLISHED，LISTEN等等，有异常情况吗？TIME-WAIT很多，为什么？大量短链接" class="headerlink" title="５８、有没有网络编程，有，怎么看连接状态？netstat，有哪些？ESTABLISHED，LISTEN等等，有异常情况吗？TIME_WAIT很多，为什么？大量短链接"></a>５８、有没有网络编程，有，怎么看连接状态？netstat，有哪些？ESTABLISHED，LISTEN等等，有异常情况吗？TIME_WAIT很多，为什么？大量短链接</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42182501/article/details/100577186?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6">linux查看tcp连接状态</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjunli/article/details/89321202?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.baidujsUnder6">解决Linux TIME_WAIT过多造成的问题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangzhao_jay/article/details/50546898?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujsUnder6">TCP连接状态详解及TIME_WAIT过多的解决方法</a></p>
<h3 id="５９、几种基本排序算法说一下，问了堆的时间复杂度，稳定性，为什么不稳定"><a href="#５９、几种基本排序算法说一下，问了堆的时间复杂度，稳定性，为什么不稳定" class="headerlink" title="５９、几种基本排序算法说一下，问了堆的时间复杂度，稳定性，为什么不稳定"></a>５９、几种基本排序算法说一下，问了堆的时间复杂度，稳定性，为什么不稳定</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示）</a></p>
<h3 id="６０、-topk问题，海量数据topk（回答成切分多次加载内存，然后用维持k长度的有序链表，然后被说时间复杂度不好，提示说还是用堆，然后哦哦哦对）"><a href="#６０、-topk问题，海量数据topk（回答成切分多次加载内存，然后用维持k长度的有序链表，然后被说时间复杂度不好，提示说还是用堆，然后哦哦哦对）" class="headerlink" title="６０、 topk问题，海量数据topk（回答成切分多次加载内存，然后用维持k长度的有序链表，然后被说时间复杂度不好，提示说还是用堆，然后哦哦哦对）"></a>６０、 topk问题，海量数据topk（回答成切分多次加载内存，然后用维持k长度的有序链表，然后被说时间复杂度不好，提示说还是用堆，然后哦哦哦对）</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qlky/p/7512199.html">海量数据中找出前k大数（topk问题）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010601183/article/details/56481868?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujsUnder6">怎么在海量数据中找出重复次数最多的一个</a></p>
<h3 id="最长连续字串和，这里我说的解决方案没用dp（对dp不熟），面试官一直引导我dp，还是不会"><a href="#最长连续字串和，这里我说的解决方案没用dp（对dp不熟），面试官一直引导我dp，还是不会" class="headerlink" title="最长连续字串和，这里我说的解决方案没用dp（对dp不熟），面试官一直引导我dp，还是不会"></a>最长连续字串和，这里我说的解决方案没用dp（对dp不熟），面试官一直引导我dp，还是不会</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/i6223671/article/details/89789503">动态规划（2）：最大连续字串和</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/QQ245671051/article/details/72162320?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">golang动态规划求解最大连续子数组和</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">func <span class="hljs-title">MaxSum</span><span class="hljs-params">(arr <span class="hljs-keyword">int</span>[])</span> <span class="hljs-keyword">int</span></span>&#123;<br>  <span class="hljs-comment">//当前位置的和</span><br>  curSum := <span class="hljs-number">0</span><br>  <span class="hljs-comment">//最大的和</span><br>  max := <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> _,v := range arr&#123;<br>    <span class="hljs-keyword">if</span> curSum &gt; <span class="hljs-number">0</span>&#123;<br>      curSum=curSum+v<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      curSum = v<br>    &#125;<br>    <span class="hljs-comment">//更新最大值</span><br>    <span class="hljs-keyword">if</span> curSum &gt; max&#123;<br>      max = curSum<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/30728">Golang 无重复字符的最长子串</a></p>
<h3 id="６１、什么是主键"><a href="#６１、什么是主键" class="headerlink" title="６１、什么是主键"></a>６１、什么是主键</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013235478/article/details/50625677?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control">MySQL索引原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013308490/article/details/83001060?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control">MySQL索引实现原理分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/harbor1981/article/details/53449435">关于数据库主键和外键（终于弄懂啦）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40456829/article/details/83409937?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-16.control">SQL数据库中主键和外键的应用实例</a></p>
<h3 id="６２、联合索引和唯一索引"><a href="#６２、联合索引和唯一索引" class="headerlink" title="６２、联合索引和唯一索引"></a>６２、联合索引和唯一索引</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/y-rong/p/5908236.html">mysql 联合索引和唯一索引</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fan-yuan/p/7879353.html">DQL、DML、DDL、DCL的概念与区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdnlijingran/article/details/88629851">索引，主键，唯一索引，联合索引的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/winy_lm/article/details/49718193?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control">索引(index)_普通索引、唯一索引和复合索引.索引查询</a></p>
<h3 id="６２、越多的索引越好吗？"><a href="#６２、越多的索引越好吗？" class="headerlink" title="６２、越多的索引越好吗？"></a>６２、越多的索引越好吗？</h3><p>不是的，索引建立太多会消耗空间，严重拖慢记录的更新以及行记录的新增速度。</p>
<p>1.数据量小的表不需要建立索引，建立索引会增加额外开销；<br>2.数据变更需要维护索引，更多的索引要更多维护成本；<br>3.更多的索引需要更多的空间，因为索引需要空间来存放；</p>
<p><a target="_blank" rel="noopener" href="https://javaedge.blog.csdn.net/article/details/117432959?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">数据库索引，真的越建越好吗?</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weiliangliang111/article/details/51333169?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-12.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-12.control">数据库索引到底是什么，是怎样工作的？</a></p>
<p><a target="_blank" rel="noopener" href="https://yangy.blog.csdn.net/article/details/103816128?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-15.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-15.control">【数据库索引Index系列】数据库索引，这一篇就够了</a></p>
<h3 id="６３、建立索引要注意什么？"><a href="#６３、建立索引要注意什么？" class="headerlink" title="６３、建立索引要注意什么？"></a>６３、建立索引要注意什么？</h3><p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/242479/blog/1553371">什么时候适合建索引？建索引要注意什么？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gavinsp/p/5513536.html">数据库索引详解</a></p>
<h3 id="６４、进程和线程区别？"><a href="#６４、进程和线程区别？" class="headerlink" title="６４、进程和线程区别？"></a>６４、进程和线程区别？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kuangsonghan/article/details/80674777?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.baidujsUnder6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.baidujsUnder6">进程和线程的主要区别（总结）(面试回答用)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/102021274">进程和线程的区别(超详细)</a></p>
<h3 id="６５、死锁？"><a href="#６５、死锁？" class="headerlink" title="６５、死锁？"></a>６５、死锁？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hd12370/article/details/82814348">死锁面试题（什么是死锁，产生死锁的原因及必要条件）</a></p>
<h3 id="６６、tcp三次握手"><a href="#６６、tcp三次握手" class="headerlink" title="６６、tcp三次握手"></a>６６、tcp三次握手</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whuslei/article/details/6667471?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control">TCP协议中的三次握手和四次挥手(图解)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38950316/article/details/81087809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">TCP的三次握手与四次挥手理解及面试题（很全面）</a></p>
<h3 id="６７、http，https"><a href="#６７、http，https" class="headerlink" title="６７、http，https"></a>６７、http，https</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP和HTTPS协议，看一篇就够了</a></p>
<h3 id="６８、状态码401-301-302-201"><a href="#６８、状态码401-301-302-201" class="headerlink" title="６８、状态码401,301,302,201"></a>６８、状态码401,301,302,201</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TankXiao/archive/2013/01/08/2818542.html">HTTP协议 (六) 状态码详解</a></p>
<h3 id="６９、项目我说只有一台机子，所以用的单机部署，面试官说单机也可以部署多个，有什么方法吗？我说docker，问docker有哪些网络，不熟，dockerfile关键字，只答几个。顺便扯了下nginx转发。"><a href="#６９、项目我说只有一台机子，所以用的单机部署，面试官说单机也可以部署多个，有什么方法吗？我说docker，问docker有哪些网络，不熟，dockerfile关键字，只答几个。顺便扯了下nginx转发。" class="headerlink" title="６９、项目我说只有一台机子，所以用的单机部署，面试官说单机也可以部署多个，有什么方法吗？我说docker，问docker有哪些网络，不熟，dockerfile关键字，只答几个。顺便扯了下nginx转发。"></a>６９、项目我说只有一台机子，所以用的单机部署，面试官说单机也可以部署多个，有什么方法吗？我说docker，问docker有哪些网络，不熟，dockerfile关键字，只答几个。顺便扯了下nginx转发。</h3><p><a href="https://riddlego.github.io/2021/08/06/%E9%9D%A2%E8%AF%95%EF%BC%9ADocker/">docker</a></p>
<p><a href="https://riddlego.github.io/2021/08/06/%E9%9D%A2%E8%AF%95%EF%BC%9AK8s/">k8s</a></p>
<h3 id="７０、数据库隔离级别，提交读会造成什么"><a href="#７０、数据库隔离级别，提交读会造成什么" class="headerlink" title="７０、数据库隔离级别，提交读会造成什么"></a>７０、数据库隔离级别，提交读会造成什么</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012712087/article/details/46402433?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control">更改MySQL的默认事务隔离级别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.control">数据库的事务隔离级别总结</a></p>
<h3 id="７１、go调度"><a href="#７１、go调度" class="headerlink" title="７１、go调度"></a>７１、go调度</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangzhiyang/article/details/52669851?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">golang的goroutine调度机制</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/9610">Golang调度器</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/20991">一文摸清 Go 的并发调度模型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/db0aea4d60ed">Go 语言调度（一）: 系统调度</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb6881a2661d">Go 语言调度（二）: goroutine 调度器</a></p>
<h3 id="７２、-goroutine泄漏有没有处理，设置timeout，select加定时器"><a href="#７２、-goroutine泄漏有没有处理，设置timeout，select加定时器" class="headerlink" title="７２、 goroutine泄漏有没有处理，设置timeout，select加定时器"></a>７２、 goroutine泄漏有没有处理，设置timeout，select加定时器</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74090074">Go 笔记之如何防止 goroutine 泄露</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/elihe2011/article/details/109141811">Golang Select &amp; 定时器</a></p>
<h3 id="７３、mysql高可用的方案"><a href="#７３、mysql高可用的方案" class="headerlink" title="７３、mysql高可用的方案"></a>７３、mysql高可用的方案</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/robbinluobo/p/8294782.html">MYSQL(高可用方案)</a></p>
<h3 id="７６、怎么学习go"><a href="#７６、怎么学习go" class="headerlink" title="７６、怎么学习go"></a>７６、怎么学习go</h3><h3 id="７８、io模型，同步阻塞，同步非阻塞，异步"><a href="#７８、io模型，同步阻塞，同步非阻塞，异步" class="headerlink" title="７８、io模型，同步阻塞，同步非阻塞，异步"></a>７８、io模型，同步阻塞，同步非阻塞，异步</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36573828/article/details/89149057?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">同步、异步、阻塞、非阻塞IO总结（IO模型总结）</a></p>
<h3 id="７９、cookie和session"><a href="#７９、cookie和session" class="headerlink" title="７９、cookie和session"></a>７９、cookie和session</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/l199616j/p/11195667.html">cookie和session</a></p>
<h3 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h3 id="同学的评价"><a href="#同学的评价" class="headerlink" title="同学的评价"></a>同学的评价</h3><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><h3 id="有什么offer"><a href="#有什么offer" class="headerlink" title="有什么offer"></a>有什么offer</h3><h3 id="８０、接口kps测试"><a href="#８０、接口kps测试" class="headerlink" title="８０、接口kps测试"></a>８０、接口kps测试</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/happyliuyi/p/10617039.html">性能测试入门（一）性能测试之QPS、TPS、并发量、系统吞吐量的概念</a></p>
<h3 id="８１、redis排行榜数据结构（跳跃表），查询时间复杂度"><a href="#８１、redis排行榜数据结构（跳跃表），查询时间复杂度" class="headerlink" title="８１、redis排行榜数据结构（跳跃表），查询时间复杂度"></a>８１、redis排行榜数据结构（跳跃表），查询时间复杂度</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haoprogrammer/p/11065461.html">Redis(一)、Redis五种数据结构</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universe_ant/article/details/51134020?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">Redis中的跳跃表</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41622183/article/details/91126155">面试准备 – Redis 跳跃表</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WhereIsHeroFrom/article/details/84997418?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">Redis底层详解（六） 跳跃表</a></p>
<h3 id="８２、redis分布式，如何减少同步延迟"><a href="#８２、redis分布式，如何减少同步延迟" class="headerlink" title="８２、redis分布式，如何减少同步延迟"></a>８２、redis分布式，如何减少同步延迟</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yockie/article/details/79929739">降低redis内存使用与减少请求延迟</a></p>
<h3 id="８３、mysql能实现redis的功能吗"><a href="#８３、mysql能实现redis的功能吗" class="headerlink" title="８３、mysql能实现redis的功能吗"></a>８３、mysql能实现redis的功能吗</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rinack/p/9667457.html">如何使用Redis做MySQL的缓存</a></p>
<h3 id="８４、平时怎么学习？"><a href="#８４、平时怎么学习？" class="headerlink" title="８４、平时怎么学习？"></a>８４、平时怎么学习？</h3><h3 id="８５、看什么书？"><a href="#８５、看什么书？" class="headerlink" title="８５、看什么书？"></a>８５、看什么书？</h3><h3 id="８６、兴趣爱好"><a href="#８６、兴趣爱好" class="headerlink" title="８６、兴趣爱好"></a>８６、兴趣爱好</h3><h3 id="８７、看过google三篇分布式论文吗，没看过"><a href="#８７、看过google三篇分布式论文吗，没看过" class="headerlink" title="８７、看过google三篇分布式论文吗，没看过"></a>８７、看过google三篇分布式论文吗，没看过</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pingyuyue/archive/2012/03/11/2390518.html?utm_source=tuicool">浅析google的分布式三篇论文</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijy83/article/details/6637126">Google的5篇经典论文，分布式必读！</a></p>
<h3 id="８９、cap理论，举例"><a href="#８９、cap理论，举例" class="headerlink" title="８９、cap理论，举例"></a>８９、cap理论，举例</h3><p><a target="_blank" rel="noopener" href="https://zhanghaoxin.blog.csdn.net/article/details/113928354?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">2021-2-22：请你说下 CAP 理论并举例</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w372426096/article/details/80437198?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.control">[分布式]：分布式系统的CAP理论</a></p>
<p><a target="_blank" rel="noopener" href="https://leehao.blog.csdn.net/article/details/81051631?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control">CAP 理论解释 —— 以“记忆公司”开展业务为例</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chen77716/article/details/30635543?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-4.control">CAP理论</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013058742/article/details/83541905?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-13.control">CAP理论/AP架构/CP架构</a></p>
<h3 id="９０、LRU算法，LFU"><a href="#９０、LRU算法，LFU" class="headerlink" title="９０、LRU算法，LFU"></a>９０、LRU算法，LFU</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jake_li/article/details/50659868">两种常见的缓存淘汰算法LFU&amp;LRU</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/constant_zyh188/article/details/73350576?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control">关于常见的几种缓存算法</a></p>
<p><a target="_blank" rel="noopener" href="https://javastack.blog.csdn.net/article/details/78989956?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.control">常用缓存淘汰算法（LFU、LRU、ARC、FIFO、MRU）</a></p>
<h3 id="９１、讲讲怎么理解网络编程"><a href="#９１、讲讲怎么理解网络编程" class="headerlink" title="９１、讲讲怎么理解网络编程"></a>９１、讲讲怎么理解网络编程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/NorthCan/article/details/7270023?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.control">谈一谈网络编程学习经验（陈硕）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cangqinglang/p/10879324.html">从TCP到Socket，彻底理解网络编程是怎么回事</a></p>
<h3 id="９２、go使用踩过什么坑（for-range，数据库连接defer-close）"><a href="#９２、go使用踩过什么坑（for-range，数据库连接defer-close）" class="headerlink" title="９２、go使用踩过什么坑（for range，数据库连接defer close）"></a>９２、go使用踩过什么坑（for range，数据库连接defer close）</h3><p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/18813">golang 踩过的坑</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baijiwei/article/details/84924605">golang http使用踩过的坑与应对</a></p>
<h3 id="９３、go优缺点"><a href="#９３、go优缺点" class="headerlink" title="９３、go优缺点"></a>９３、go优缺点</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40213018/article/details/96828369?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-13.control">golang的优势与不足</a></p>
<p><a target="_blank" rel="noopener" href="https://kenkao.blog.csdn.net/article/details/90412401?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">客观评价golang的优缺点</a></p>
<h3 id="９５、go的值传递和引用"><a href="#９５、go的值传递和引用" class="headerlink" title="９５、go的值传递和引用"></a>９５、go的值传递和引用</h3><p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/28537?fr=sidebar">golang中的值传递和引用传递</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013007900/article/details/85598170">golang传值和传引用</a></p>
<h3 id="９６、慢查询"><a href="#９６、慢查询" class="headerlink" title="９６、慢查询"></a>９６、慢查询</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7529a0fbf088">什么是慢查询？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35571554/article/details/82800463">常见Mysql的慢查询优化方式</a></p>
<h3 id="９７、为什么使用pg"><a href="#９７、为什么使用pg" class="headerlink" title="９７、为什么使用pg"></a>９７、为什么使用pg</h3><p><a target="_blank" rel="noopener" href="https://www.py.cn/db/postgresql/17423.html">为什么使用postgresql</a></p>
<h3 id="９９、所有左叶子节点的和"><a href="#９９、所有左叶子节点的和" class="headerlink" title="９９、所有左叶子节点的和"></a>９９、所有左叶子节点的和</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42138662/article/details/118074453?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control">二叉树（九）：左子叶之和</a></p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2021/08/15/%E9%9D%A2%E8%AF%95%EF%BC%9Agolang-II/">
        <div class="last">
            <span>上一篇</span>
            <p>面试：golang-II</p>
        </div>
    </a>
    

    
    <a href="/2021/08/08/KVM/">
        <div class="next">
            <span>下一篇</span>
            <p>KVM</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2021 By Russshare. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>