<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="使用reflect包在反射世界里读写各类型变量"/>




  <meta name="keywords" content="reflect,反射," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/08/22/使用reflect包在反射世界里读写各类型变量/"/>


<meta name="description" content="使用reflect包在反射世界里读写各类型变量Go在标准库中提供的reflect包[2]让Go程序具备运行时的反射能力(reflection)[3]，但这种反射能力也是一把“双刃剑”，它在解决一类特定问题方面具有优势，但也带来了逻辑不清晰、性能问题以及难于发现问题和调试等不足。不过从Go诞生伊始就随着Go一起发布的reflect包是Go不可或缺的重要能力，不管你是否使用，都要掌握使用reflect">
<meta property="og:type" content="article">
<meta property="og:title" content="使用reflect包在反射世界里读写各类型变量">
<meta property="og:url" content="https://riddlego.github.io/2021/08/22/%E4%BD%BF%E7%94%A8reflect%E5%8C%85%E5%9C%A8%E5%8F%8D%E5%B0%84%E4%B8%96%E7%95%8C%E9%87%8C%E8%AF%BB%E5%86%99%E5%90%84%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="使用reflect包在反射世界里读写各类型变量Go在标准库中提供的reflect包[2]让Go程序具备运行时的反射能力(reflection)[3]，但这种反射能力也是一把“双刃剑”，它在解决一类特定问题方面具有优势，但也带来了逻辑不清晰、性能问题以及难于发现问题和调试等不足。不过从Go诞生伊始就随着Go一起发布的reflect包是Go不可或缺的重要能力，不管你是否使用，都要掌握使用reflect">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-22T01:51:07.000Z">
<meta property="article:modified_time" content="2021-08-22T02:35:35.707Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="reflect">
<meta property="article:tag" content="反射">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 使用reflect包在反射世界里读写各类型变量 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          使用reflect包在反射世界里读写各类型变量
        
      </h1>

      <time class="post-time">
          8月 22 2021
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="使用reflect包在反射世界里读写各类型变量"><a href="#使用reflect包在反射世界里读写各类型变量" class="headerlink" title="使用reflect包在反射世界里读写各类型变量"></a>使用reflect包在反射世界里读写各类型变量</h2><p>Go在标准库中提供的reflect包[2]让Go程序具备运行时的反射能力(reflection)[3]，<strong>但这种反射能力也是一把“双刃剑”，它在解决一类特定问题方面具有优势，但也带来了逻辑不清晰、性能问题以及难于发现问题和调试等不足。</strong>不过从Go诞生伊始就随着Go一起发布的reflect包是Go不可或缺的重要能力，不管你是否使用，都要掌握使用reflect与类型系统交互的基本方法，比如在反射的世界里如何读写各类型变量。本文就来和大家快速过一遍使用reflect包读写Go基本类型变量、复合类型变量的方法以及它们的应用。</p>
<p>Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。</p>
<h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h2><hr>
<p>进入reflect世界的大门主要有两个：<strong>reflect.ValueOf</strong>和<strong>reflect.TypeOf</strong>。进入到反射世界，每个变量都能找到一个与自己的对应的reflect.Value，通过该Value我们可以读写真实世界的变量信息。这里主要和大家过一遍操作各类型变量值的方法，因此主要用到的是reflect.ValueOf。</p>
<p>Go原生基本类型(非复合类型)主要包括：</p>
<ul>
<li><p>整型(int, int8, int16, int32(rune), int64, uint, uint8(byte), uint16, uint32, uint64)</p>
</li>
<li><p>浮点型(float32, float64)</p>
</li>
<li><p>复数类型(complex64, complex128)</p>
</li>
<li><p>布尔类型(bool)</p>
</li>
<li><p>字符串类型(string)</p>
</li>
</ul>
<p>我们在反射的世界里如何获取这些类型变量的值，又或如何在反射的世界里修改这些变量的值呢？<strong>下面这个示例可以作为日常使用reflect读写Go基本类型变量的速查表：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; github.com&#x2F;bigwhite&#x2F;experiments&#x2F;blob&#x2F;master&#x2F;vars-in-reflect&#x2F;basic&#x2F;main.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> &#x2F;&#x2F; 整型</span><br><span class="line"> var i int &#x3D; 11</span><br><span class="line"> vi :&#x3D; reflect.ValueOf(i)                         &#x2F;&#x2F; reflect Value of i</span><br><span class="line"> fmt.Printf(&quot;i &#x3D; [%d], vi &#x3D; [%d]\n&quot;, i, vi.Int()) &#x2F;&#x2F; i &#x3D; [11], vi &#x3D; [11]</span><br><span class="line"> &#x2F;&#x2F; vi.SetInt(11 + 100) &#x2F;&#x2F; panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line"></span><br><span class="line"> vai :&#x3D; reflect.ValueOf(&amp;i) &#x2F;&#x2F; reflect Value of Address of i</span><br><span class="line"> vi &#x3D; vai.Elem()</span><br><span class="line"> fmt.Printf(&quot;i &#x3D; [%d], vi &#x3D; [%d]\n&quot;, i, vi.Int()) &#x2F;&#x2F; i &#x3D; [11], vi &#x3D; [11]</span><br><span class="line"> vi.SetInt(11 + 100)</span><br><span class="line"> fmt.Printf(&quot;after set, i &#x3D; [%d]\n&quot;, i) &#x2F;&#x2F; after set, i &#x3D; [111]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 整型指针</span><br><span class="line"> i &#x3D; 11</span><br><span class="line"> var pi *int &#x3D; &amp;i</span><br><span class="line"> vpi :&#x3D; reflect.ValueOf(pi) &#x2F;&#x2F; reflect Value of pi</span><br><span class="line"> vi &#x3D; vpi.Elem()</span><br><span class="line"> vi.SetInt(11 + 100)</span><br><span class="line"> fmt.Printf(&quot;after set, i &#x3D; [%d]\n&quot;, i) &#x2F;&#x2F; after set, i &#x3D; [111]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 浮点型</span><br><span class="line"> var f float64 &#x3D; 3.1415</span><br><span class="line"></span><br><span class="line"> vaf :&#x3D; reflect.ValueOf(&amp;f)</span><br><span class="line"> vf :&#x3D; vaf.Elem()</span><br><span class="line"> fmt.Printf(&quot;f &#x3D; [%f], vf &#x3D; [%f]\n&quot;, f, vf.Float()) &#x2F;&#x2F; f &#x3D; [3.141500], vf &#x3D; [3.141500]</span><br><span class="line"> vf.SetFloat(100 + 3.1415)</span><br><span class="line"> fmt.Printf(&quot;after set, f &#x3D; [%f]\n&quot;, f) &#x2F;&#x2F; after set, f &#x3D; [103.141500]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 复数型</span><br><span class="line"> var c &#x3D; complex(5.1, 6.2)</span><br><span class="line"></span><br><span class="line"> vac :&#x3D; reflect.ValueOf(&amp;c)</span><br><span class="line"> vc :&#x3D; vac.Elem()</span><br><span class="line"> fmt.Printf(&quot;c &#x3D; [%g], vc &#x3D; [%g]\n&quot;, f, vc.Complex()) &#x2F;&#x2F; c &#x3D; [103.1415], vc &#x3D; [(5.1+6.2i)]</span><br><span class="line"> vc.SetComplex(complex(105.1, 106.2))</span><br><span class="line"> fmt.Printf(&quot;after set, c &#x3D; [%g]\n&quot;, c) &#x2F;&#x2F; after set, c &#x3D; [(105.1+106.2i)]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 布尔类型</span><br><span class="line"> var b bool &#x3D; true</span><br><span class="line"></span><br><span class="line"> vab :&#x3D; reflect.ValueOf(&amp;b)</span><br><span class="line"> vb :&#x3D; vab.Elem()</span><br><span class="line"> fmt.Printf(&quot;b &#x3D; [%t], vb &#x3D; [%t]\n&quot;, b, vb.Bool()) &#x2F;&#x2F; b &#x3D; [true], vb &#x3D; [true]</span><br><span class="line"> vb.SetBool(false)</span><br><span class="line"> fmt.Printf(&quot;after set, b &#x3D; [%t]\n&quot;, b) &#x2F;&#x2F; after set, b &#x3D; [false]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 字符串类型</span><br><span class="line"> var s string &#x3D; &quot;hello, reflect&quot;</span><br><span class="line"></span><br><span class="line"> vas :&#x3D; reflect.ValueOf(&amp;s)</span><br><span class="line"> vs :&#x3D; vas.Elem()</span><br><span class="line"> fmt.Printf(&quot;s &#x3D; [%s], vs &#x3D; [%s]\n&quot;, s, vs.String()) &#x2F;&#x2F; s &#x3D; [hello, reflect], vs &#x3D; [hello, reflect]</span><br><span class="line"> vs.SetString(&quot;bye, reflect&quot;)</span><br><span class="line"> fmt.Printf(&quot;after set, s &#x3D; [%s]\n&quot;, s) &#x2F;&#x2F; after set, s &#x3D; [bye, reflect]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们看到：</p>
<p><strong>原生基本类型变量通过reflect.ValueOf进入反射世界，如果最终要在反射世界修改原变量的值，那么传给ValueOf的不应该是变量自身，而是该变量的地址，指针类型除外。</strong></p>
<p>进入反射世界后，利用reflect.Value的Elem方法获取指针/地址指向的真正存储变量值的Value实例，通过Value类型提供的各种“方法糖”读取变量的值，比如：reflect.Value.Int、reflect.Value.String、reflect.Value.Bool等。</p>
<p>同样，在反射世界中，我们通过reflect.Value的SetXXX系列方法在运行时设置相关变量的值，从而达到写变量的目的。</p>
<h2 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2. 复合类型"></a>2. 复合类型</h2><p>前面我们已经看到，使用reflect包在反射世界读写原生基本类型的变量还是相对容易的多的，接下来我们再来看看复合类型(Composite type)变量的读写。</p>
<p>Go中的复合类型包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组</span><br><span class="line">切片</span><br><span class="line">map</span><br><span class="line">结构体</span><br><span class="line">channel</span><br></pre></td></tr></table></figure>
<p>与基本类型变量不同，复合变量多由同构和异构的字段(field)或元素(element)组成，如何读写复合类型变量中的字段或元素的值才是我们需要考虑的问题。下面这个示例可作为日常使用reflect在反射世界里读写Go复合类型变量中字段或元素值的速查表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; github.com&#x2F;bigwhite&#x2F;experiments&#x2F;blob&#x2F;master&#x2F;vars-in-reflect&#x2F;composite&#x2F;main.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;reflect&quot;</span><br><span class="line"> &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Foo struct &#123;</span><br><span class="line"> Name string</span><br><span class="line"> age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> &#x2F;&#x2F; 数组</span><br><span class="line"> var a &#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"> vaa :&#x3D; reflect.ValueOf(&amp;a) &#x2F;&#x2F; reflect Value of Address of arr</span><br><span class="line"> va :&#x3D; vaa.Elem()</span><br><span class="line"> va0 :&#x3D; va.Index(0)</span><br><span class="line"> fmt.Printf(&quot;a0 &#x3D; [%d], va0 &#x3D; [%d]\n&quot;, a[0], va0.Int()) &#x2F;&#x2F; a0 &#x3D; [1], va0 &#x3D; [1]</span><br><span class="line"> va0.SetInt(100 + 1)</span><br><span class="line"> fmt.Printf(&quot;after set, a0 &#x3D; [%d]\n&quot;, a[0]) &#x2F;&#x2F; after set, a0 &#x3D; [101]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 切片</span><br><span class="line"> var s &#x3D; []int&#123;11, 12, 13&#125;</span><br><span class="line"> vs :&#x3D; reflect.ValueOf(s)</span><br><span class="line"> vs0 :&#x3D; vs.Index(0)</span><br><span class="line"> fmt.Printf(&quot;s0 &#x3D; [%d], vs0 &#x3D; [%d]\n&quot;, s[0], vs0.Int()) &#x2F;&#x2F; s0 &#x3D; [11], vs0 &#x3D; [11]</span><br><span class="line"> vs0.SetInt(100 + 11)</span><br><span class="line"> fmt.Printf(&quot;after set, s0 &#x3D; [%d]\n&quot;, s[0]) &#x2F;&#x2F; after set, s0 &#x3D; [111]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; map</span><br><span class="line"> var m &#x3D; map[int]string&#123;</span><br><span class="line">  1: &quot;tom&quot;,</span><br><span class="line">  2: &quot;jerry&quot;,</span><br><span class="line">  3: &quot;lucy&quot;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> vm :&#x3D; reflect.ValueOf(m)</span><br><span class="line"> vm_1_v :&#x3D; vm.MapIndex(reflect.ValueOf(1))                      &#x2F;&#x2F; the reflect Value of the value of key 1</span><br><span class="line"> fmt.Printf(&quot;m_1 &#x3D; [%s], vm_1 &#x3D; [%s]\n&quot;, m[1], vm_1_v.String()) &#x2F;&#x2F; m_1 &#x3D; [tom], vm_1 &#x3D; [tom]</span><br><span class="line"> vm.SetMapIndex(reflect.ValueOf(1), reflect.ValueOf(&quot;tony&quot;))</span><br><span class="line"> fmt.Printf(&quot;after set, m_1 &#x3D; [%s]\n&quot;, m[1]) &#x2F;&#x2F; after set, m_1 &#x3D; [tony]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 为map m新增一组key-value</span><br><span class="line"> vm.SetMapIndex(reflect.ValueOf(4), reflect.ValueOf(&quot;amy&quot;))</span><br><span class="line"> fmt.Printf(&quot;after set, m &#x3D; [%#v]\n&quot;, m) &#x2F;&#x2F; after set, m &#x3D; [map[int]string&#123;1:&quot;tony&quot;, 2:&quot;jerry&quot;, 3:&quot;lucy&quot;, 4:&quot;amy&quot;&#125;]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 结构体</span><br><span class="line"> var f &#x3D; Foo&#123;</span><br><span class="line">  Name: &quot;lily&quot;,</span><br><span class="line">  age:  16,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> vaf :&#x3D; reflect.ValueOf(&amp;f)</span><br><span class="line"> vf :&#x3D; vaf.Elem()</span><br><span class="line"> field1 :&#x3D; vf.FieldByName(&quot;Name&quot;)</span><br><span class="line"> fmt.Printf(&quot;the Name of f &#x3D; [%s]\n&quot;, field1.String()) &#x2F;&#x2F; the Name of f &#x3D; [lily]</span><br><span class="line"> field2 :&#x3D; vf.FieldByName(&quot;age&quot;)</span><br><span class="line"> fmt.Printf(&quot;the age of f &#x3D; [%d]\n&quot;, field2.Int()) &#x2F;&#x2F; the age of f &#x3D; [16]</span><br><span class="line"></span><br><span class="line"> field1.SetString(&quot;ally&quot;)</span><br><span class="line"> &#x2F;&#x2F; field2.SetInt(8) &#x2F;&#x2F; panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span><br><span class="line"> nAge :&#x3D; reflect.NewAt(field2.Type(), unsafe.Pointer(field2.UnsafeAddr())).Elem()</span><br><span class="line"> nAge.SetInt(8)</span><br><span class="line"> fmt.Printf(&quot;after set, f is [%#v]\n&quot;, f) &#x2F;&#x2F; after set, f is [main.Foo&#123;Name:&quot;ally&quot;, age:8&#125;]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 接口</span><br><span class="line"> var g &#x3D; Foo&#123;</span><br><span class="line">  Name: &quot;Jordan&quot;,</span><br><span class="line">  age:  40,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 接口底层动态类型为复合类型变量</span><br><span class="line"> var i interface&#123;&#125; &#x3D; &amp;g</span><br><span class="line"> vi :&#x3D; reflect.ValueOf(i)</span><br><span class="line"> vg :&#x3D; vi.Elem()</span><br><span class="line"></span><br><span class="line"> field1 &#x3D; vg.FieldByName(&quot;Name&quot;)</span><br><span class="line"> fmt.Printf(&quot;the Name of g &#x3D; [%s]\n&quot;, field1.String()) &#x2F;&#x2F; the Name of g &#x3D; [Jordan]</span><br><span class="line"> field2 &#x3D; vg.FieldByName(&quot;age&quot;)</span><br><span class="line"> fmt.Printf(&quot;the age of g &#x3D; [%d]\n&quot;, field2.Int()) &#x2F;&#x2F; the age of g &#x3D; [40]</span><br><span class="line"></span><br><span class="line"> nAge &#x3D; reflect.NewAt(field2.Type(), unsafe.Pointer(field2.UnsafeAddr())).Elem()</span><br><span class="line"> nAge.SetInt(50)</span><br><span class="line"> fmt.Printf(&quot;after set, g is [%#v]\n&quot;, g) &#x2F;&#x2F; after set, g is [main.Foo&#123;Name:&quot;Jordan&quot;, age:50&#125;]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 接口底层动态类型为基本类型变量</span><br><span class="line"> var n &#x3D; 5</span><br><span class="line"> i &#x3D; &amp;n</span><br><span class="line"> vi &#x3D; reflect.ValueOf(i).Elem()</span><br><span class="line"> fmt.Printf(&quot;i &#x3D; [%d], vi &#x3D; [%d]\n&quot;, n, vi.Int()) &#x2F;&#x2F; i &#x3D; [5], vi &#x3D; [5]</span><br><span class="line"> vi.SetInt(10)</span><br><span class="line"> fmt.Printf(&quot;after set, n is [%d]\n&quot;, n) &#x2F;&#x2F; after set, n is [10]</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; channel</span><br><span class="line"> var ch &#x3D; make(chan int, 100)</span><br><span class="line"> vch :&#x3D; reflect.ValueOf(ch)</span><br><span class="line"> vch.Send(reflect.ValueOf(22))</span><br><span class="line"></span><br><span class="line"> j :&#x3D; &lt;-ch</span><br><span class="line"> fmt.Printf(&quot;recv [%d] from channel\n&quot;, j) &#x2F;&#x2F; recv [22] from channel</span><br><span class="line"></span><br><span class="line"> ch &lt;- 33</span><br><span class="line"> vj, ok :&#x3D; vch.Recv()</span><br><span class="line"> fmt.Printf(&quot;recv [%d] ok[%t]\n&quot;, vj.Int(), ok) &#x2F;&#x2F; recv [33] ok[true]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述示例，我们可以得到如下一些信息：</p>
<ul>
<li><p>在反射的世界里，reflect包针对复合类型中的元素或字段的读写提供了相应的方法，比如针对数组、切片元素的Value.Index，针对map key-value的Value.MapIndex，针对结构体字段的Field、FieldByName，针对channel的Send和Recv。</p>
</li>
<li><p>切片、map和channel由于其底层实现为指针类型结构[4]，我们可以直接利用其在反射世界中对应的Value在反射世界中修改其内部元素；</p>
</li>
<li><p>对于结构体中的非导出字段(unexported field)，我们可以读取其值，但无法直接修改其值。在上面的示例中，我们通过下面的unsafe手段实现了对其的赋值：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nAge &#x3D; reflect.NewAt(field2.Type(), unsafe.Pointer(field2.UnsafeAddr())).Elem()</span><br><span class="line">nAge.SetInt(50)</span><br></pre></td></tr></table></figure>
<p>我们通过reflect.NewAt创建了一个新Value实例，该实例表示指向field2地址的指针。然后通过Elem方法，我们得到该指针Value指向的对象的Value：nAge，实际就是field2变量。然后通过nAge设置的新值也将反映在field2的值上。这和上面基本类型那个示例中的vpi和vi的功用类似。</p>
<h2 id="3-获取系统资源描述符的值"><a href="#3-获取系统资源描述符的值" class="headerlink" title="3. 获取系统资源描述符的值"></a>3. 获取系统资源描述符的值</h2><p>reflect包的一大功用就是获取一些被封装在底层的系统资源描述符的值，比如：socket描述符、文件描述符。</p>
<h3 id="a-文件描述符"><a href="#a-文件描述符" class="headerlink" title="a) 文件描述符"></a>a) 文件描述符</h3><p>os.File提供了Fd方法用于获取文件对应的os底层的文件描述符的值。我们也可以使用反射来实现同样的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; github.com&#x2F;bigwhite&#x2F;experiments&#x2F;blob&#x2F;master&#x2F;vars-in-reflect&#x2F;system-resource&#x2F;file_fd.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;os&quot;</span><br><span class="line"> &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fileFD(f *os.File) int &#123;</span><br><span class="line"> file :&#x3D; reflect.ValueOf(f).Elem().FieldByName(&quot;file&quot;).Elem()</span><br><span class="line"> pfdVal :&#x3D; file.FieldByName(&quot;pfd&quot;)</span><br><span class="line"> return int(pfdVal.FieldByName(&quot;Sysfd&quot;).Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> fileName :&#x3D; os.Args[1]</span><br><span class="line"> f, err :&#x3D; os.Open(fileName)</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> defer f.Close()</span><br><span class="line"></span><br><span class="line"> fmt.Printf(&quot;file descriptor is %d\n&quot;, f.Fd())</span><br><span class="line"> fmt.Printf(&quot;file descriptor in reflect is %d\n&quot;, fileFD(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$go build file_fd.go </span><br><span class="line">$.&#x2F;file_fd file_fd.go</span><br><span class="line">file descriptor is 3</span><br><span class="line">file descriptor in reflect is 3</span><br></pre></td></tr></table></figure>

<p>我们看到通过reflect获取到的fd值与通过Fd方法得到的值是一致的。</p>
<p>下面我们可以基于上面对读写基本类型和复合类型变量的理解来简单分析一下fileFD函数的实现：</p>
<p>os.File的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;os&#x2F;types.go</span><br><span class="line"></span><br><span class="line">type File struct &#123;</span><br><span class="line">        *file &#x2F;&#x2F; os specific</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了通过反射获取到未导出指针变量file，我们使用下面反射语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file :&#x3D; reflect.ValueOf(f).Elem().FieldByName(&quot;file&quot;).Elem()</span><br></pre></td></tr></table></figure>
<p>有了上面的Value实例file，我们就可以继续反射os.file结构了。os.file结构是因os而异的，以linux/mac的unix为例，os.file的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;os&#x2F;file_unix.go</span><br><span class="line"></span><br><span class="line">type file struct &#123;</span><br><span class="line">        pfd         poll.FD</span><br><span class="line">        name        string</span><br><span class="line">        dirinfo     *dirInfo &#x2F;&#x2F; nil unless directory being read</span><br><span class="line">        nonblock    bool     &#x2F;&#x2F; whether we set nonblocking mode</span><br><span class="line">        stdoutOrErr bool     &#x2F;&#x2F; whether this is stdout or stderr</span><br><span class="line">        appendMode  bool     &#x2F;&#x2F; whether file is opened for appending</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们继续反射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfdVal :&#x3D; file.FieldByName(&quot;pfd&quot;)</span><br></pre></td></tr></table></figure>

<p>而poll.FD的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;internal&#x2F;poll&#x2F;fd_unix.go</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; field of a larger type representing a network connection or OS file.</span><br><span class="line">type FD struct &#123;</span><br><span class="line">        &#x2F;&#x2F; Lock sysfd and serialize access to Read and Write methods.</span><br><span class="line">        fdmu fdMutex</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; System file descriptor. Immutable until Close.</span><br><span class="line">        Sysfd int</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; I&#x2F;O poller.</span><br><span class="line">        pd pollDesc</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Writev cache.</span><br><span class="line">        iovecs *[]syscall.Iovec </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Semaphore signaled when file is closed.</span><br><span class="line">        csema uint32</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Non-zero if this file has been set to blocking mode.</span><br><span class="line">        isBlocking uint32</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Whether this is a streaming descriptor, as opposed to a</span><br><span class="line">        &#x2F;&#x2F; packet-based descriptor like a UDP socket. Immutable.</span><br><span class="line">        IsStream bool</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Whether a zero byte read indicates EOF. This is false for a</span><br><span class="line">        &#x2F;&#x2F; message based socket connection.</span><br><span class="line">        ZeroReadIsEOF bool</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Whether this is a file rather than a network socket.</span><br><span class="line">        isFile bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中的Sysfd记录的就是系统的文件描述符的值，于是通过下面语句即可得到该文件描述符的值：</p>
<h3 id="b-socket描述符"><a href="#b-socket描述符" class="headerlink" title="b) socket描述符"></a>b) socket描述符</h3><p>unix下一切皆文件！socket描述符也是一个文件描述符，并且Go并没有在标准库中直接提供获取socket文件描述符的API。我们只能通过反射获取。看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; github.com&#x2F;bigwhite&#x2F;experiments&#x2F;blob&#x2F;master&#x2F;vars-in-reflect&#x2F;system-resource&#x2F;socket_fd.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;log&quot;</span><br><span class="line"> &quot;net&quot;</span><br><span class="line"> &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func socketFD(conn net.Conn) int &#123;</span><br><span class="line"> tcpConn :&#x3D; reflect.ValueOf(conn).Elem().FieldByName(&quot;conn&quot;)</span><br><span class="line"> fdVal :&#x3D; tcpConn.FieldByName(&quot;fd&quot;)</span><br><span class="line"> pfdVal :&#x3D; fdVal.Elem().FieldByName(&quot;pfd&quot;)</span><br><span class="line"> return int(pfdVal.FieldByName(&quot;Sysfd&quot;).Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line"> ln, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for &#123;</span><br><span class="line">  conn, err :&#x3D; ln.Accept()</span><br><span class="line">  if err !&#x3D; nil &#123;</span><br><span class="line">   if ne, ok :&#x3D; err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">    log.Printf(&quot;accept temp err: %v&quot;, ne)</span><br><span class="line">    continue</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Printf(&quot;accept err: %v&quot;, err)</span><br><span class="line">   return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;conn fd is [%d]\n&quot;, socketFD(conn))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看到socketFD的实现与fileFD的实现有些类似，我们从net.Conn一步步反射得到底层的Sysfd。</p>
<p>传给socketFD的实参实质是一个TCPConn实例，通过reflect.ValueOf(conn).Elem()我们可以获取到该实例在反射世界的Value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;net&#x2F;tcpsock.go</span><br><span class="line"></span><br><span class="line">type TCPConn struct &#123;</span><br><span class="line">        conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再通过FieldByName(“conn”)得到TCPConn结构中字段conn在反射世界中的Value。net.conn结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;net&#x2F;net.go</span><br><span class="line">type conn struct &#123;</span><br><span class="line">        fd *netFD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起哄的netFD是一个os相关的结构，以linux/mac为例，其结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $GOROOT&#x2F;src&#x2F;net&#x2F;fd_posix.go</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Network file descriptor.</span><br><span class="line">type netFD struct &#123;</span><br><span class="line">        pfd poll.FD</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; immutable until Close</span><br><span class="line">        family      int</span><br><span class="line">        sotype      int</span><br><span class="line">        isConnected bool &#x2F;&#x2F; handshake completed or use of association with peer</span><br><span class="line">        net         string</span><br><span class="line">        laddr       Addr</span><br><span class="line">        raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们又看到了poll.FD类型字段pfd，再往下的反射就和fileFD一致了。</p>
<p>本文涉及的源码可以在这里[5]下载：<a target="_blank" rel="noopener" href="https://github.com/bigwhite/experiments/blob/master/vars-in-reflect">https://github.com/bigwhite/experiments/blob/master/vars-in-reflect</a></p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651441623&idx=3&sn=01b89022a4a890549604d4946ac617c3&chksm=80bb1725b7cc9e3379997c0237fc2aae39f21846c6b6d1d06c051f23f00ac144464161b3759b&scene=21#wechat_redirect">花开并蒂—站在Go接口之上的反射分析</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651441088&idx=3&sn=0dfbe75033453fc9f6b093e981d1ca12&chksm=80bb1932b7cc9024b818c5a5fb99d234d02bd6918f793905f2ce27ed1c34a9162bbb95a2d52f&scene=21#wechat_redirect">接口Interface—塑造健壮与可扩展的Go应用程序</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]<br>本文永久链接: <a target="_blank" rel="noopener" href="https://tonybai.com/2021/04/19/variable-operation-using-reflection-in-go">https://tonybai.com/2021/04/19/variable-operation-using-reflection-in-go</a></p>
<p>[2]<br>reflect包: <a target="_blank" rel="noopener" href="https://www.imooc.com/read/87/article/2474">https://www.imooc.com/read/87/article/2474</a></p>
<p>[3]<br>运行时的反射能力(reflection): <a target="_blank" rel="noopener" href="https://www.imooc.com/read/87/article/2474">https://www.imooc.com/read/87/article/2474</a></p>
<p>[4]<br>其底层实现为指针类型结构: <a target="_blank" rel="noopener" href="https://www.imooc.com/read/87/article/2383">https://www.imooc.com/read/87/article/2383</a></p>
<p>[5]<br>这里: <a target="_blank" rel="noopener" href="https://github.com/bigwhite/experiments/blob/master/vars-in-reflect">https://github.com/bigwhite/experiments/blob/master/vars-in-reflect</a></p>
<p>[6]<br>改善Go语⾔编程质量的50个有效实践: <a target="_blank" rel="noopener" href="https://www.imooc.com/read/87">https://www.imooc.com/read/87</a></p>
<p>[7]<br>Kubernetes实战：高可用集群搭建、配置、运维与应用: <a target="_blank" rel="noopener" href="https://coding.imooc.com/class/284.html">https://coding.imooc.com/class/284.html</a></p>
<p>[8]<br>我爱发短信: <a target="_blank" rel="noopener" href="https://51smspush.com/">https://51smspush.com/</a></p>
<p>[9]<br>链接地址: <a target="_blank" rel="noopener" href="https://m.do.co/c/bff6eed92687">https://m.do.co/c/bff6eed92687</a></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/reflect/">reflect</a>
		  
			<a href="/tags/%E5%8F%8D%E5%B0%84/">反射</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/08/22/Go-interface-%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Go-interface-原理剖析--类型转换</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/08/22/Go%E8%AF%AD%E8%A8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-1-%E6%90%AD%E5%BB%BAgRPC-HTTP%E7%9A%84%E5%8F%8C%E9%87%8D%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">
        <span class="next-text nav-default">Go语言微服务框架-1.搭建gRPC+HTTP的双重网关服务</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
