<!DOCTYPE html>
<html>

	<head>
		
<title>LRU算法拆解与实现-Russshare</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">


<meta name="keywords" content="算法,面试题,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4b5fe1472f22fa";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">
</head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/profile.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Russshare</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg ">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/算法">算法</a></li>
            
            <li><a href="/tags/面试题">面试题</a></li>
            
            
        </ul>
        <h1>LRU算法拆解与实现</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                    <g>
                        <path fill="#12183A"
                            d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                        </path>
                    </g>
                </svg>
                
                <span> <a href="">Russshare</a></span>
                <p>2021-06-28 16:42:03</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <p>计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。</p>
<p>但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？</p>
<p>LRU 的全称是 Least Recently Used，<strong>也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。</strong></p>
<p>举个简单的例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：<br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/zigbeesecurity/01.jpg"></p>
<p>但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：<br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/LRU/02.jpg"></p>
<p>假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？</p>
<p>按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：<br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/LRU/03.jpg"><br>现在你应该理解 LRU（Least Recently Used）策略了。当然还有其他缓存淘汰策略，比如不要按访问的时序来淘汰，而是按访问频率（LFU 策略）来淘汰等等，各有应用场景。本文讲解 LRU 算法策略。</p>
<h3 id="一、LRU-算法描述"><a href="#一、LRU-算法描述" class="headerlink" title="一、LRU 算法描述"></a>一、LRU 算法描述</h3><p><strong>牛客</strong></p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能<br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(key, value)</span>：将记录<span class="hljs-params">(key, value)</span>插入该结构</span><br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(key)</span>：返回<span class="hljs-title">key</span>对应的<span class="hljs-title">value</span>值</span><br><span class="hljs-function">[要求]</span><br><span class="hljs-function"><span class="hljs-title">set</span>和<span class="hljs-title">get</span>方法的时间复杂度为O<span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">某个<span class="hljs-title">key</span>的<span class="hljs-title">set</span>或<span class="hljs-title">get</span>操作一旦发生，认为这个<span class="hljs-title">key</span>的记录成了最常使用的。</span><br><span class="hljs-function">当缓存的大小超过K时，移除最不经常使用的记录，即<span class="hljs-title">set</span>或<span class="hljs-title">get</span>最久远的。</span><br><span class="hljs-function">若<span class="hljs-title">opt</span>=1，接下来两个整数<span class="hljs-title">x</span>, <span class="hljs-title">y</span>，表示<span class="hljs-title">set</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function">若<span class="hljs-title">opt</span>=2，接下来一个整数<span class="hljs-title">x</span>，表示<span class="hljs-title">get</span><span class="hljs-params">(x)</span>，若<span class="hljs-title">x</span>未出现过或已被移除，则返回-1</span><br><span class="hljs-function">对于每个操作2，输出一个答案</span><br><span class="hljs-function"></span><br><span class="hljs-function">输入：</span><br><span class="hljs-function">[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3</span><br><span class="hljs-function"></span><br><span class="hljs-function">返回值：</span><br><span class="hljs-function">[1,-1]</span><br><span class="hljs-function"></span><br><span class="hljs-function">说明：</span><br><span class="hljs-function">第一次操作后：最常使用的记录为<span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">第二次操作后：最常使用的记录为<span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)</span>，<span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)</span>变为最不常用的</span><br><span class="hljs-function">第三次操作后：最常使用的记录为<span class="hljs-params">(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">2</span>)</span>，<span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)</span>还是最不常用的</span><br><span class="hljs-function">第四次操作后：最常用的记录为<span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)</span>，<span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)</span>变为最不常用的</span><br><span class="hljs-function">第五次操作后：大小超过了3，所以移除此时最不常使用的记录<span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)</span>，加入记录<span class="hljs-params">(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-number">4</span>)</span>，并且为最常使用的记录，然后<span class="hljs-params">(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">2</span>)</span>变为最不常使用的记录</span><br></code></pre></td></tr></table></figure>


<p><strong>力扣</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">146</span> 题「LRU缓存机制」就是让你设计数据结构：<br><br>首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 <span class="hljs-built_in">put</span>(<span class="hljs-built_in">key</span>, val) 方法存入键值对，另一个是 <span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>) 方法获取 <span class="hljs-built_in">key</span> 对应的 val，如果 <span class="hljs-built_in">key</span> 不存在则返回 -<span class="hljs-number">1</span>。<br><br>注意哦，<span class="hljs-built_in">get</span> 和 <span class="hljs-built_in">put</span> 方法必须都是 O(<span class="hljs-number">1</span>) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。<br></code></pre></td></tr></table></figure>
<p>先整个栗子看看LRU算法是怎么工作</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 缓存容量为 2 */</span><br>cache := &amp;LRUCache&#123;<span class="hljs-number">2</span>&#125;;<br><span class="hljs-regexp">//</span> 你可以把 cache 理解成一个队列<br><span class="hljs-regexp">//</span> 假设左边是队头，右边是队尾<br><span class="hljs-regexp">//</span> 最近使用的排在队头，久未使用的排在队尾<br><span class="hljs-regexp">//</span> 圆括号表示键值对 (key, val)<br><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><br>cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><br>cache.get(<span class="hljs-number">1</span>);       <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)]<br><span class="hljs-regexp">//</span> 解释：因为最近访问了键 <span class="hljs-number">1</span>，所以提前至队头<br><span class="hljs-regexp">//</span> 返回键 <span class="hljs-number">1</span> 对应的值 <span class="hljs-number">1</span><br><br>cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-regexp">//</span> 解释：缓存容量已满，需要删除内容空出位置<br><span class="hljs-regexp">//</span> 优先删除久未使用的数据，也就是队尾的数据<br><span class="hljs-regexp">//</span> 然后把新的数据插入队头<br><br>cache.get(<span class="hljs-number">2</span>);       <span class="hljs-regexp">//</span> 返回 -<span class="hljs-number">1</span> (未找到)<br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-regexp">//</span> 解释：cache 中不存在键为 <span class="hljs-number">2</span> 的数据<br><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);    <br><span class="hljs-regexp">//</span> cache = [(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)]<br><span class="hljs-regexp">//</span> 解释：键 <span class="hljs-number">1</span> 已存在，把原始值 <span class="hljs-number">1</span> 覆盖为 <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span> 不要忘了也要将键值对提前到队头<br></code></pre></td></tr></table></figure>
<h3 id="二、LRU-算法设计"><a href="#二、LRU-算法设计" class="headerlink" title="二、LRU 算法设计"></a>二、LRU 算法设计</h3><p>分析上面的操作过程，**要让 put 和 get 方法的时间复杂度为 O(1)**，我们可以总结出 cache 这个数据结构必要的条件：</p>
<p><strong>1</strong>、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</p>
<p><strong>2</strong>、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；</p>
<p><strong>3</strong>、<strong>每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。</strong></p>
<p>那么，什么数据结构同时符合上述条件呢？<strong>哈希表查找快，但是数据无固定顺序</strong>；<strong>链表有顺序之分，插入删除快，但是查找慢。</strong> 所以结合一下，形成一种新的数据结构：<strong>哈希链表 LinkedHashMap。</strong></p>
<p><strong>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</strong><br><img src="https://gitee.com/psycho1900/miss-reddle/raw/master/LRU/04.jpg"></p>
<p>借助这个结构，我们来逐一分析上面的 3 个条件：</p>
<p><strong>1</strong>、如果我们每次默认<strong>从链表尾部添加元素</strong>，<strong>那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</strong></p>
<p><strong>2</strong>、<strong>对于某一个 key，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 val。</strong></p>
<p><strong>3</strong>、<strong>链表显然是支持在任意位置快速插入和删除的，改改指针就行</strong>。<strong>只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，</strong>可以通过 key 快速映射到任意一个链表节点，然后进行插入和删除。</p>
<p>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存 key 和 val 呢，只存 val 不就行了？</p>
<p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～<br>(答案在后面东哥有说哦！！！)</p>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们先自己造轮子实现一遍 LRU 算法，然后再使用 Java 内置的 LinkedHashMap 来实现一遍。（如果你是golang，别想了，轮子什么都得造，什么轮子都得自己造。）</p>
<p>首先，我们把双链表的节点类写出来，为了简化，key 和 val 都认为是 int 类型：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">package main<br><br>type Node struct &#123;<br>	key  int<br>	val  int<br>	next *Node<br>	prev *Node<br>&#125;<br><br>func (node Node) NewNode(k, v int) &#123;<br>	node<span class="hljs-selector-class">.key</span> = k<br>	node<span class="hljs-selector-class">.val</span> = v<br>&#125;<br><br><span class="hljs-comment">//然后依靠我们的 Node 类型构建一个双链表，实现几个 LRU 算法必须的 API：</span><br><br>type DoubleList struct &#123;<br>	<span class="hljs-comment">//头尾虚节点</span><br>	head Node<br>	tail Node<br><br>	<span class="hljs-comment">//链表元素数</span><br>	size int<br>&#125;<br><br>func (<span class="hljs-selector-tag">dl</span> DoubleList) NewDoubleList() &#123;<br>	<span class="hljs-comment">//初始化双向链表的数据</span><br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.head</span> = Node&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nil, nil&#125;<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.tail</span> = Node&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nil, nil&#125;<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.head</span><span class="hljs-selector-class">.next</span> = &amp;<span class="hljs-selector-tag">dl</span>.tail<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.tail</span><span class="hljs-selector-class">.prev</span> = &amp;<span class="hljs-selector-tag">dl</span>.head<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.size</span> = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//在链表尾部添加节点x，时间O(1)</span><br>func (<span class="hljs-selector-tag">dl</span> DoubleList) addLast(x Node) &#123;<br>	<span class="hljs-comment">//先操作新加的元素的指针</span><br><br>	x<span class="hljs-selector-class">.prev</span> = <span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.tail</span>.prev<br>	x<span class="hljs-selector-class">.next</span> = &amp;<span class="hljs-selector-tag">dl</span>.tail<br><br>	<span class="hljs-comment">//添加在tail之前  在tail.prev的之后</span><br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.tail</span><span class="hljs-selector-class">.prev</span><span class="hljs-selector-class">.next</span> = &amp;x<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.tail</span><span class="hljs-selector-class">.prev</span> = &amp;x<br><br>	<span class="hljs-comment">//整个链表的长度+1</span><br>	<span class="hljs-selector-tag">dl</span>.size++<br>&#125;<br><br><span class="hljs-comment">// 删除链表中的 x 节点（x 一定存在）</span><br><span class="hljs-comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span><br>func (<span class="hljs-selector-tag">dl</span> DoubleList) remove(x Node) &#123;<br>	<span class="hljs-comment">//跳过结点</span><br>	x<span class="hljs-selector-class">.prev</span><span class="hljs-selector-class">.next</span> = x.next<br>	<span class="hljs-comment">//将后面的结点的前置节点  跳过该结点</span><br>	x<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.prev</span> = x.prev<br>	<span class="hljs-selector-tag">dl</span>.size--<br>&#125;<br><br><span class="hljs-comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span><br>func (<span class="hljs-selector-tag">dl</span> DoubleList) removeFirst() Node &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.head</span><span class="hljs-selector-class">.next</span> == nil &#123;<br>		return Node&#123;&#125;<br>	&#125;<br><br>	first := <span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.head</span>.next<br>	<span class="hljs-selector-tag">dl</span><span class="hljs-selector-class">.remove</span>(*first)<br><br>	return *first<br>&#125;<br><br><span class="hljs-comment">// 返回链表长度，时间 O(1)</span><br>func (<span class="hljs-selector-tag">dl</span> DoubleList) sizeLen() int &#123;<br>	return <span class="hljs-selector-tag">dl</span>.size<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里就能回答刚才「为什么必须要用双向链表」的问题了，<strong>因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</strong></p>
<p><strong>注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久为使用的。</strong></p>
<p>有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可，先搭出代码框架：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// key -&gt; Node(key, val)</span><br>	hashmap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]Node<br>	<span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>	cache DoubleList<br>	<span class="hljs-comment">//最大容量</span><br>	<span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc LRUCache)</span> <span class="hljs-title">NewLRUCache</span><span class="hljs-params">(<span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	lc.<span class="hljs-built_in">cap</span> = <span class="hljs-built_in">cap</span><br>	lc.hashmap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]Node)<br>	lc.cache = DoubleList&#123;&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>先不慌去实现 LRU 算法的 get 和 put 方法。由于我们要同时维护一个双链表 cache 和一个哈希表 map，<strong>很容易漏掉一些操作，比如说删除某个 key 时，在 cache 中删除了对应的 Node，但是却忘记在 map 中删除 key。</strong></p>
<p><strong>解决这种问题的有效方法是：在这两种数据结构之上提供一层抽象 API。</strong></p>
<p>说的有点玄幻，实际上很简单，<strong>就是尽量让 LRU 的主方法 get 和 put 避免直接操作 map 和 cache 的细节。</strong>我们可以先实现下面几个函数：<br>(我想这里的意思就是，我们上层的get和put方法是直接的调用，我们将多种的操作封装到底下的实现，这个就好比一个是我每次工作按十个按钮启动十个机器，但是我现在设置一个总线讲十个按钮连接（封装）到一个按钮，然后我按下这一个按钮好比按了十个按钮，这样也会避免我每次少按一个，这也是封装思想的一种体现。)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//封装的函数</span><br><span class="hljs-comment">/* 将某个 key 提升为最近使用的 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc LRUCache)</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	x := lc.hashmap[key]<br>	<span class="hljs-comment">//先从链表删除这个元素</span><br>	lc.cache.remove(x)<br>	<span class="hljs-comment">//重新加到队尾</span><br>	lc.cache.addLast(x)<br>&#125;<br><br><span class="hljs-comment">//添加最近使用的元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc LRUCache)</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(key, val <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	x := Node&#123;key, val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>	<span class="hljs-comment">// 链表尾部就是最近使用的元素</span><br>	lc.cache.addLast(x)<br>	<span class="hljs-comment">// 别忘了在 map 中添加 key 的映射</span><br>	lc.hashmap[key] = x<br>&#125;<br><br><span class="hljs-comment">/* 删除某一个 key */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc LRUCache)</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	x := lc.hashmap[key]<br>	<span class="hljs-comment">// 从链表中删除</span><br>	lc.cache.remove(x)<br>	<span class="hljs-comment">// 从 map 中删除</span><br>	<span class="hljs-built_in">delete</span>(lc.hashmap, key)<br>&#125;<br><br><span class="hljs-comment">/* 删除最久未使用的元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lc LRUCache)</span> <span class="hljs-title">removeLeastRecently</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 链表头部的第一个元素就是最久未使用的</span><br>	deletedNode := lc.cache.removeFirst()<br>	<span class="hljs-comment">// 同时别忘了从 map 中删除它的 key</span><br>	deletedKey := deletedNode.key<br>	<span class="hljs-built_in">delete</span>(lc.hashmap, deletedKey)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里就能回答之前的问答题「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，注意 removeLeastRecently 函数中，我们需要用 deletedNode 得到 deletedKey。</p>
<p><strong>也就是说，当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。</strong></p>
<p>上述方法就是简单的操作封装，调用这些函数可以避免直接操作 cache 链表和 map 哈希表，下面我先来实现 LRU 算法的 get 方法：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//LRU 算法的 get 方法</span><br>func (lc LRUCache) <span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span> <span class="hljs-built_in">int</span>) <span class="hljs-built_in">int</span> &#123;<br>	<span class="hljs-comment">//如果没有数据 就返回-1</span><br>	<span class="hljs-keyword">if</span> _, ok := lc.hashmap[<span class="hljs-built_in">key</span>]; !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br><br>	<span class="hljs-comment">//如果有该数据</span><br>	<span class="hljs-comment">//将该数据提升为最近使用的</span><br>	lc.makeRecently(<span class="hljs-built_in">key</span>)<br>	<span class="hljs-keyword">return</span> lc.hashmap[<span class="hljs-built_in">key</span>].val<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>

<p>put 方法稍微复杂一些，我们先来画个图搞清楚它的逻辑：</p>
<p>图片</p>
<p>这样我们可以轻松写出 put 方法的代码：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>LRU 算法的 put 方法<br><span class="hljs-keyword">func</span> (lc LRUCache) put(key, val int) &#123;<br>	<span class="hljs-regexp">//</span><br>	<span class="hljs-keyword">if</span> _, ok := lc.hashmap[key]; ok &#123;<br>		<span class="hljs-regexp">//</span>删除旧的数据<br>		lc.deleteKey(key)<br>		<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span> 新插入的数据为最近使用的数据<br>		lc.addRecently(key, val)<br>		return<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> lc.cap == lc.cache.sizeLen() &#123;<br>		<span class="hljs-regexp">//</span> 删除最久未使用的元素<br>		lc.removeLeastRecently()<br>	&#125;<br><br>	<span class="hljs-regexp">//</span> 添加为最近使用的元素<br>	lc.addRecently(key, val)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上算是实现了LRU，但是牛客网刷题没法用啊，但是到这里你应该已经懂了思想，所以接下来我们就整一个能直接使用的。<br>这里就直接上代码了哈，比较LRU这种思想是统一的，实现的大概也是相同的，就不解释了，不过该注释的地方我还是会注释的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>	key  <span class="hljs-keyword">int</span><br>	val  <span class="hljs-keyword">int</span><br>	next *Node<br>	prev *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node Node)</span> <span class="hljs-title">NewNode</span><span class="hljs-params">(k, v <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	node.key = k<br>	node.val = v<br>&#125;<br><br><span class="hljs-comment">//然后依靠我们的 Node 类型构建一个双链表，实现几个 LRU 算法必须的 API：</span><br><br><span class="hljs-keyword">type</span> DoubleList <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">//头尾虚节点</span><br>	head Node<br>	tail Node<br>	<span class="hljs-comment">//链表元素数</span><br>	size <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">NewDoubleList</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-comment">//初始化双向链表的数据</span><br>	dl.head = Node&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>	dl.tail = Node&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>	dl.head.next = &amp;dl.tail<br>	dl.tail.prev = &amp;dl.head<br>	dl.size = k<br>&#125;<br><br><span class="hljs-keyword">var</span> hashmap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]Node)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">LRU</span><span class="hljs-params">(operator [][]<span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>	dl.NewDoubleList(k)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(operator) &lt; <span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>	&#125;<br><br>	res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, k)<br><br>	<span class="hljs-keyword">for</span> _, op := <span class="hljs-keyword">range</span> operator &#123;<br>		<span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>			dl.set(op[<span class="hljs-number">1</span>], op[<span class="hljs-number">2</span>])<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> &#123;<br>			value := dl.get(op[<span class="hljs-number">1</span>])<br>			res = <span class="hljs-built_in">append</span>(res, value)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">//接下来就是实现set和get</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">set</span><span class="hljs-params">(key, val <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> _, ok := hashmap[key]; !ok &#123;<br>		<span class="hljs-comment">//第一步：先封装成node节点的格式</span><br>		node := Node&#123;key, val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>		<span class="hljs-comment">//第二部 映射到hashmap中</span><br>		hashmap[key] = node<br>		<span class="hljs-comment">//第三步 放入链表</span><br>		<span class="hljs-comment">//放入之前先检查</span><br>		<span class="hljs-keyword">if</span> dl.size &lt;= <span class="hljs-number">0</span> &#123;<br>			dl.removeLast()<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			dl.size--<br>		&#125;<br><br>		dl.insertFirst(node)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">//map中意见有了</span><br>		node := hashmap[key]<br>		node.val = val<br>		hashmap[key] = node<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>	ret := <span class="hljs-number">-1</span><br>	<span class="hljs-keyword">if</span> _, ok := hashmap[key]; ok &#123;<br>		ret = hashmap[key].val<br>		<span class="hljs-comment">//记得取了以后一点要把数据放到最前的位置</span><br>		dl.moveToHead(hashmap[key])<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-comment">//整个数据结构也是  最近访问的在头部  最后的在尾部</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(node Node)</span></span> &#123;<br>	<span class="hljs-comment">//如果本来就是最新的  就保持</span><br>	<span class="hljs-keyword">if</span> node.prev == &amp;dl.head &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-comment">//先把这个删了</span><br>	node.prev.next = node.next<br>	node.next.prev = node.prev<br><br>	<span class="hljs-comment">//再插进头部</span><br>	dl.insertFirst(node)<br>&#125;<br><br><span class="hljs-comment">//移除最后的  最久没有使用的  链表尾部的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">//删的时候 记得两个地方都需要删除</span><br>	<span class="hljs-comment">//一是map</span><br>	<span class="hljs-built_in">delete</span>(hashmap, dl.tail.key)<br><br>	<span class="hljs-comment">//二是链表</span><br>	dl.tail.prev.prev.next = &amp;dl.tail<br>	dl.tail.prev = dl.tail.prev.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dl DoubleList)</span> <span class="hljs-title">insertFirst</span><span class="hljs-params">(node Node)</span></span> &#123;<br>	node.prev = &amp;dl.head<br>	node.next = dl.head.next<br><br>	dl.head.next = &amp;node<br>	dl.head.next.prev = &amp;node<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>提交了牛客网 还是会报错，这个系统的报错是无法识别LRU，离谱。算了估计是这个环境的问题，但是通过以上相信肯定还是有所收获。</p>
<h3 id="打个总结"><a href="#打个总结" class="headerlink" title="打个总结"></a>打个总结</h3><p>提交个golang版本，其实这个主要是要学会构建list和map的新型数据结构，同时注意一下几个细节：<br>1、队尾是最久没有使用的，首是最新使用的（每个人可以自定义），通过位置表明体现LRU<br>2、每次的增改都要记得将数据放到最新使用的位置。<br>3、增加的时候记得判断是否容量到达了最大值<br>4、删除时记得map和list都需要删除<br>5、可以将细节封装到底层的函数，最后的put和get调用（这个在我编写嵌入式程序的时候也深有体会）<br>6、还有一些小细节记得小心，每次完成一个功能记得判断是否正确的实现了<br>无论是从底层小函数往上写，还是从上层函数往下写，其实都是可以的，看自己的思维模式。</p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2021/06/29/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%84%9F%E6%82%9F/">
        <div class="last">
            <span>上一篇</span>
            <p>golang中的数据类型使用小感悟</p>
        </div>
    </a>
    

    
    <a href="/2021/06/28/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/">
        <div class="next">
            <span>下一篇</span>
            <p>最小的k个数</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2021 By Russshare. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/RiddleGo">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>