<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="go语言的标准库container-2-heap"/>




  <meta name="keywords" content="堆,大顶堆,小顶堆,golang数据结构," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/05/31/go语言的标准库container-2-heap/"/>


<meta name="description" content="前言：前面写一个算法需要用到大小顶堆，用到了heap结构，是go包中的。蛮不错的，但是好奇heap.init函数就可以把一个数组变成堆得结构。于是这一篇文章就来看看这个源码，里面是什么。然后不小心找了一个前辈写好的注释，哈哈，就拿来学习一下。我们一起来看看哈哈。（其实有时候我也不知道现在我们在这个资源丰富的时代，吸取的都是别人解释好的东西，少了原始的过程，不知道是好是坏，算了算了，等哪天失眠的时候">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言的标准库container-2-heap">
<meta property="og:url" content="https://riddlego.github.io/2021/05/31/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93container-2-heap/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="前言：前面写一个算法需要用到大小顶堆，用到了heap结构，是go包中的。蛮不错的，但是好奇heap.init函数就可以把一个数组变成堆得结构。于是这一篇文章就来看看这个源码，里面是什么。然后不小心找了一个前辈写好的注释，哈哈，就拿来学习一下。我们一起来看看哈哈。（其实有时候我也不知道现在我们在这个资源丰富的时代，吸取的都是别人解释好的东西，少了原始的过程，不知道是好是坏，算了算了，等哪天失眠的时候">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-31T13:27:49.000Z">
<meta property="article:modified_time" content="2021-05-31T13:28:58.000Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="堆">
<meta property="article:tag" content="大顶堆">
<meta property="article:tag" content="小顶堆">
<meta property="article:tag" content="golang数据结构">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> go语言的标准库container-2-heap - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          go语言的标准库container-2-heap
        
      </h1>

      <time class="post-time">
          5月 31 2021
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>前面写一个算法需要用到大小顶堆，用到了heap结构，是go包中的。蛮不错的，但是好奇heap.init函数就可以把一个数组变成堆得结构。于是这一篇文章就来看看这个源码，里面是什么。<br>然后不小心找了一个前辈写好的注释，哈哈，就拿来学习一下。我们一起来看看哈哈。<br>（其实有时候我也不知道现在我们在这个资源丰富的时代，吸取的都是别人解释好的东西，少了原始的过程，不知道是好是坏，算了算了，等哪天失眠的时候再想吧。干）</p>
<p>这个前辈写的太详细了~~~<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huxianglin/p/6925119.html">原文</a></p>
<h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><h4 id="1-heap使用"><a href="#1-heap使用" class="headerlink" title="1. heap使用"></a>1. heap使用</h4><p>在go语言的标准库container中，实现了三中数据类型：heap,list,ring，list在前面一篇文章中已经写了，现在要写的是heap（堆）的源码剖析。</p>
<p>首先，学会怎么使用heap，第一步当然是导入包了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;container&#x2F;heap&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个堆使用的数据结构是<strong>最小二叉树</strong>，即根节点比左边子树和右边子树的所有值都小。源码里面只是实现了一个接口，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">	sort.Interface</span><br><span class="line">	Push(x interface&#123;&#125;) &#x2F;&#x2F; add x as element Len()</span><br><span class="line">	Pop() interface&#123;&#125;   &#x2F;&#x2F; remove and return element Len() - 1.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个接口可以看出，其继承了sort.Interface接口，那么sort.Interface的定义是什么呢？源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">	&#x2F;&#x2F; Len is the number of elements in the collection.</span><br><span class="line">	Len() int</span><br><span class="line">	&#x2F;&#x2F; Less reports whether the element with</span><br><span class="line">	&#x2F;&#x2F; index i should sort before the element with index j.</span><br><span class="line">	Less(i, j int) bool</span><br><span class="line">	&#x2F;&#x2F; Swap swaps the elements with indexes i and j.</span><br><span class="line">	Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，<strong>我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，</strong>需要实现的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len() int</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">Swap(i, j int)</span><br><span class="line">Push(x interface&#123;&#125;)</span><br><span class="line">Pop() interface&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type IntHeap []int  &#x2F;&#x2F; 定义一个类型</span><br><span class="line"></span><br><span class="line">func (h IntHeap) Len() int &#123; return len(h) &#125;  &#x2F;&#x2F; 绑定len方法,返回长度</span><br><span class="line">func (h IntHeap) Less(i, j int) bool &#123;  &#x2F;&#x2F; 绑定less方法</span><br><span class="line">	return h[i] &lt; h[j]  &#x2F;&#x2F; 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆</span><br><span class="line">&#125;</span><br><span class="line">func (h IntHeap) Swap(i, j int) &#123;  &#x2F;&#x2F; 绑定swap方法，交换两个元素位置</span><br><span class="line">	h[i], h[j] &#x3D; h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *IntHeap) Pop() interface&#123;&#125; &#123;  &#x2F;&#x2F; 绑定pop方法，从最后拿出一个元素并返回</span><br><span class="line">	old :&#x3D; *h</span><br><span class="line">	n :&#x3D; len(old)</span><br><span class="line">	x :&#x3D; old[n-1]</span><br><span class="line">	*h &#x3D; old[0 : n-1]</span><br><span class="line">	return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *IntHeap) Push(x interface&#123;&#125;) &#123;  &#x2F;&#x2F; 绑定push方法，插入新元素</span><br><span class="line">	*h &#x3D; append(*h, x.(int))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对IntHeap实现了这五个方法之后，我们就可以使用heap了，下面是具体使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	h :&#x3D; &amp;IntHeap&#123;2, 1, 5, 6, 4, 3, 7, 9, 8, 0&#125;  &#x2F;&#x2F; 创建slice</span><br><span class="line">	heap.Init(h)  &#x2F;&#x2F; 初始化heap</span><br><span class="line">	fmt.Println(*h)</span><br><span class="line">	fmt.Println(heap.Pop(h))  &#x2F;&#x2F; 调用pop</span><br><span class="line">	heap.Push(h, 6)  &#x2F;&#x2F; 调用push</span><br><span class="line">	fmt.Println(*h)</span><br><span class="line">	for len(*h) &gt; 0 &#123;</span><br><span class="line">		fmt.Printf(&quot;%d &quot;, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">[0 1 3 6 2 5 7 9 8 4]</span><br><span class="line">0</span><br><span class="line">[1 2 3 6 4 5 7 9 8 6]</span><br><span class="line">1 2 3 4 5 6 6 7 8 9 </span><br></pre></td></tr></table></figure>
<p>上面就是heap的使用了。</p>
<h4 id="2-heap提供的方法"><a href="#2-heap提供的方法" class="headerlink" title="2. heap提供的方法"></a>2. heap提供的方法</h4><p>heap提供的方法不多，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h :&#x3D; &amp;IntHeap&#123;3, 8, 6&#125;  &#x2F;&#x2F; 创建IntHeap类型的原始数据</span><br><span class="line">func Init(h Interface)  &#x2F;&#x2F; 对heap进行初始化，生成小根堆（或大根堆）</span><br><span class="line">func Push(h Interface, x interface&#123;&#125;)  &#x2F;&#x2F; 往堆里面插入内容</span><br><span class="line">func Pop(h Interface) interface&#123;&#125;  &#x2F;&#x2F; 从堆顶pop出内容</span><br><span class="line">func Remove(h Interface, i int) interface&#123;&#125;  &#x2F;&#x2F; 从指定位置删除数据，并返回删除的数据</span><br><span class="line">func Fix(h Interface, i int)  &#x2F;&#x2F; 从i位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法</span><br></pre></td></tr></table></figure>
<h4 id="3-heap源码剖析"><a href="#3-heap源码剖析" class="headerlink" title="3. heap源码剖析"></a>3. heap源码剖析</h4><p>heap的内部实现，<strong>是使用最小(最大)堆，</strong>索引排序从根节点开始，然后左子树，右子树的顺序方式。 内部实现的down和up分别表示对堆中的某个元素向下保证最小(最大)堆和向上保证最小(最大)堆。</p>
<p>当往堆中插入一个元素的时候，这个元素插入到最右子树的最后一个节点中，<strong>然后调用up向上保证最小(最大)堆。</strong></p>
<p>当要从堆中推出一个元素的时候，先把这个元素和右子树最后一个节点交换，然后弹出最后一个节点，<strong>然后对root调用down，向下保证最小(最大)堆。</strong></p>
<p>好了，开始分析源码：</p>
<p>首先，在使用堆之前，必须调用它的Init方法，初始化堆，生成小根(大根)堆。Init方法源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A heap must be initialized before any of the heap operations</span><br><span class="line">&#x2F;&#x2F; can be used. Init is idempotent with respect to the heap invariants</span><br><span class="line">&#x2F;&#x2F; and may be called whenever the heap invariants may have been invalidated.</span><br><span class="line">&#x2F;&#x2F; Its complexity is O(n) where n &#x3D; h.Len().</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">func Init(h Interface) &#123;</span><br><span class="line">	&#x2F;&#x2F; heapify</span><br><span class="line">	n :&#x3D; h.Len()  &#x2F;&#x2F; 获取数据的长度</span><br><span class="line">	for i :&#x3D; n&#x2F;2 - 1; i &gt;&#x3D; 0; i-- &#123;  &#x2F;&#x2F; 从长度的一半开始，一直到第0个数据，每个位置都调用down方法，down方法实现的功能是保证从该位置往下保证形成堆</span><br><span class="line">		down(h, i, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看down的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func down(h Interface, i0, n int) bool &#123;</span><br><span class="line">	i :&#x3D; i0  &#x2F;&#x2F; 中间变量，第一次存储的是需要保证往下需要形成堆的节点位置</span><br><span class="line">	for &#123;  &#x2F;&#x2F; 死循环</span><br><span class="line">		j1 :&#x3D; 2*i + 1  &#x2F;&#x2F; i节点的左子孩子</span><br><span class="line">		if j1 &gt;&#x3D; n || j1 &lt; 0 &#123; &#x2F;&#x2F; j1 &lt; 0 after int overflow  &#x2F;&#x2F; 保证其左子孩子没有越界</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		j :&#x3D; j1 &#x2F;&#x2F; left child  &#x2F;&#x2F; 中间变量j先赋值为左子孩子，之后j将被赋值为左右子孩子中最小（大）的一个孩子的位置</span><br><span class="line">		if j2 :&#x3D; j1 + 1; j2 &lt; n &amp;&amp; !h.Less(j1, j2) &#123;</span><br><span class="line">			j &#x3D; j2 &#x2F;&#x2F; &#x3D; 2*i + 2  &#x2F;&#x2F; right child</span><br><span class="line">		&#125;  &#x2F;&#x2F; 这之后，j被赋值为两个孩子中的最小（大）孩子的位置（最小或最大由Less中定义的决定）</span><br><span class="line">		if !h.Less(j, i) &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;  &#x2F;&#x2F; 若j大于（小于）i，则终止循环</span><br><span class="line">		h.Swap(i, j)  &#x2F;&#x2F; 否则交换i和j位置的值</span><br><span class="line">		i &#x3D; j  &#x2F;&#x2F; 令i&#x3D;j，继续循环，保证j位置的子数是堆结构</span><br><span class="line">	&#125;</span><br><span class="line">	return i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是建立堆的核心代码，其实，<strong>down并不能完全保证从某个节点往下每个节点都能保持堆的特性，只能保证某个节点的值如果不满足堆的性质，则将该值与其孩子交换，直到该值放到适合的位置，保证该值及其两个子孩子满足堆的性质。</strong></p>
<p>但是，如果是通过Init循环调用down将能保证初始化后所有的节点都保持堆的特性，这是因为循环开始的i := n/2 - 1的取值位置，将会取到最大的一个拥有孩子节点的节点，并且该节点最多只有两个孩子，并且其孩子节点是叶子节点，从该节点往前每个节点如果都能保证down的特性，则整个列表也就符合了堆的性质了。</p>
<p>同样，<strong>有down就有up，up保证的是某个节点如果向上没有保证堆的性质，则将其与父节点进行交换，直到该节点放到某个特定位置保证了堆的性质。</strong>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func up(h Interface, j int) &#123;</span><br><span class="line">	for &#123;  &#x2F;&#x2F; 死循环</span><br><span class="line">		i :&#x3D; (j - 1) &#x2F; 2 &#x2F;&#x2F; parent  &#x2F;&#x2F; j节点的父节点</span><br><span class="line">		if i &#x3D;&#x3D; j || !h.Less(j, i) &#123;  &#x2F;&#x2F; 如果越界，或者满足堆的条件，则结束循环</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)  &#x2F;&#x2F; 否则将该节点和父节点交换</span><br><span class="line">		j &#x3D; i  &#x2F;&#x2F; 对父节点继续进行检查直到根节点</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上两个方法就是最核心的方法了，所有暴露出来的方法无非就是对这两个方法进行的封装。</strong><br>我们来看看以下这些方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func Push(h Interface, x interface&#123;&#125;) &#123;</span><br><span class="line">	h.Push(x)  &#x2F;&#x2F; 将新插入进来的节点放到最后</span><br><span class="line">	up(h, h.Len()-1)  &#x2F;&#x2F; 确保新插进来的节点网上能保证堆结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Pop(h Interface) interface&#123;&#125; &#123;</span><br><span class="line">	n :&#x3D; h.Len() - 1  &#x2F;&#x2F; 把最后一个节点和第一个节点进行交换，之后，从根节点开始重新保证堆结构，最后把最后那个节点数据丢出并返回</span><br><span class="line">	h.Swap(0, n)</span><br><span class="line">	down(h, 0, n)</span><br><span class="line">	return h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Remove(h Interface, i int) interface&#123;&#125; &#123;</span><br><span class="line">	n :&#x3D; h.Len() - 1  pop只是remove的特殊情况，remove是把i位置的节点和最后一个节点进行交换，之后保证从i节点往下及往上都保证堆结构，最后把最后一个节点的数据丢出并返回</span><br><span class="line">	if n !&#x3D; i &#123;</span><br><span class="line">		h.Swap(i, n)</span><br><span class="line">		down(h, i, n)</span><br><span class="line">		up(h, i)</span><br><span class="line">	&#125;</span><br><span class="line">	return h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func Fix(h Interface, i int) &#123;</span><br><span class="line">	if !down(h, i, h.Len()) &#123;  &#x2F;&#x2F; i节点的数值发生改变后，需要保证堆的再平衡，先调用down保证该节点下面的堆结构，如果有位置交换，则需要保证该节点往上的堆结构，否则就不需要往上保证堆结构，一个小小的优化</span><br><span class="line">		up(h, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是go里面的heap所有的源码了，我也就不贴出完整版源码了，以上理解全部基于个人的理解，如有不当之处，还望批评指正。</p>
<h4 id="4-利用heap实现优先级队列"><a href="#4-利用heap实现优先级队列" class="headerlink" title="4. 利用heap实现优先级队列"></a>4. 利用heap实现优先级队列</h4><p>既然用到了heap，那就用heap实现一个优先级队列吧，这个功能是很好的一个功能。<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;container&#x2F;heap&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Item struct &#123;</span><br><span class="line">	value    string &#x2F;&#x2F; 优先级队列中的数据，可以是任意类型，这里使用string</span><br><span class="line">	priority int    &#x2F;&#x2F; 优先级队列中节点的优先级</span><br><span class="line">	index    int    &#x2F;&#x2F; index是该节点在堆中的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 优先级队列需要实现heap的interface</span><br><span class="line">type PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定Len方法</span><br><span class="line">func (pq PriorityQueue) Len() int &#123;</span><br><span class="line">	return len(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定Less方法，这里用的是小于号，生成的是小根堆</span><br><span class="line">func (pq PriorityQueue) Less(i, j int) bool &#123;</span><br><span class="line">	return pq[i].priority &lt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定swap方法</span><br><span class="line">func (pq PriorityQueue) Swap(i, j int) &#123;</span><br><span class="line">	pq[i], pq[j] &#x3D; pq[j], pq[i]</span><br><span class="line">	pq[i].index, pq[j].index &#x3D; i, j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定put方法，将index置为-1是为了标识该数据已经出了优先级队列了</span><br><span class="line">func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	old :&#x3D; *pq</span><br><span class="line">	n :&#x3D; len(old)</span><br><span class="line">	item :&#x3D; old[n-1]</span><br><span class="line">	*pq &#x3D; old[0 : n-1]</span><br><span class="line">	item.index &#x3D; -1</span><br><span class="line">	return item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定push方法</span><br><span class="line">func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123;</span><br><span class="line">	n :&#x3D; len(*pq)</span><br><span class="line">	item :&#x3D; x.(*Item)</span><br><span class="line">	item.index &#x3D; n</span><br><span class="line">	*pq &#x3D; append(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新修改了优先级和值的item在优先级队列中的位置</span><br><span class="line">func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123;</span><br><span class="line">	item.value &#x3D; value</span><br><span class="line">	item.priority &#x3D; priority</span><br><span class="line">	heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 创建节点并设计他们的优先级</span><br><span class="line">	items :&#x3D; map[string]int&#123;&quot;二毛&quot;: 5, &quot;张三&quot;: 3, &quot;狗蛋&quot;: 9&#125;</span><br><span class="line">	i :&#x3D; 0</span><br><span class="line">	pq :&#x3D; make(PriorityQueue, len(items)) &#x2F;&#x2F; 创建优先级队列，并初始化</span><br><span class="line">	for k, v :&#x3D; range items &#123;             &#x2F;&#x2F; 将节点放到优先级队列中</span><br><span class="line">		pq[i] &#x3D; &amp;Item&#123;</span><br><span class="line">			value:    k,</span><br><span class="line">			priority: v,</span><br><span class="line">			index:    i&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;pq) &#x2F;&#x2F; 初始化堆</span><br><span class="line">	item :&#x3D; &amp;Item&#123; &#x2F;&#x2F; 创建一个item</span><br><span class="line">		value:    &quot;李四&quot;,</span><br><span class="line">		priority: 1,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Push(&amp;pq, item)           &#x2F;&#x2F; 入优先级队列</span><br><span class="line">	pq.update(item, item.value, 6) &#x2F;&#x2F; 更新item的优先级</span><br><span class="line">	for len(pq) &gt; 0 &#123;</span><br><span class="line">		item :&#x3D; heap.Pop(&amp;pq).(*Item)</span><br><span class="line">		fmt.Printf(&quot;%.2d:%s index:%.2d\n&quot;, item.priority, item.value, item.index)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">03:张三 index:-01</span><br><span class="line">05:二毛 index:-01</span><br><span class="line">06:李四 index:-01</span><br><span class="line">09:狗蛋 index:-01</span><br></pre></td></tr></table></figure>

<p><strong>这个真的是好文章，瑞思拜</strong></p>
<p><em><strong>以上就是本次的全部内容，希望对你有所帮助！！！</strong></em></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/%E5%A0%86/">堆</a>
		  
			<a href="/tags/%E5%A4%A7%E9%A1%B6%E5%A0%86/">大顶堆</a>
		  
			<a href="/tags/%E5%B0%8F%E9%A1%B6%E5%A0%86/">小顶堆</a>
		  
			<a href="/tags/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">golang数据结构</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/05/31/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93container-1-list/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">go语言的标准库container-1-list</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/05/31/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93container-3-ring/">
        <span class="next-text nav-default">go语言的标准库container-3-ring</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
