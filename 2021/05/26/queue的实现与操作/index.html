<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="queue的实现与操作"/>




  <meta name="keywords" content="数据结构,队列," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/05/26/queue的实现与操作/"/>


<meta name="description" content="list的实现与操作前言：以前用C++与java实现数据结构，只需要直接声明构建即可，这是因为所谓的库函数内部已经帮咱们实现了。go是不存在这玩意的，不过好在有各种各样的包，我们可以引入直接使用，同时就算是不引用，我们也可以根据数据结构的特点进行自己构造。今天这篇文章就来讲讲在golang中怎么进行queue的实现与操作。 这段话来自labuladong的公众号，强烈推荐，值得一看，如果看过，请直">
<meta property="og:type" content="article">
<meta property="og:title" content="queue的实现与操作">
<meta property="og:url" content="https://riddlego.github.io/2021/05/26/queue%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="list的实现与操作前言：以前用C++与java实现数据结构，只需要直接声明构建即可，这是因为所谓的库函数内部已经帮咱们实现了。go是不存在这玩意的，不过好在有各种各样的包，我们可以引入直接使用，同时就算是不引用，我们也可以根据数据结构的特点进行自己构造。今天这篇文章就来讲讲在golang中怎么进行queue的实现与操作。 这段话来自labuladong的公众号，强烈推荐，值得一看，如果看过，请直">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-26T01:33:50.000Z">
<meta property="article:modified_time" content="2021-05-26T01:37:24.000Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="队列">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> queue的实现与操作 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          queue的实现与操作
        
      </h1>

      <time class="post-time">
          5月 26 2021
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="list的实现与操作"><a href="#list的实现与操作" class="headerlink" title="list的实现与操作"></a>list的实现与操作</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>以前用C++与java实现数据结构，只需要直接声明构建即可，这是因为所谓的库函数内部已经帮咱们实现了。go是不存在这玩意的，不过好在有各种各样的包，我们可以引入直接使用，同时就算是不引用，我们也可以根据数据结构的特点进行自己构造。<br>今天这篇文章就来讲讲在golang中怎么进行queue的实现与操作。</p>
<p><strong>这段话来自labuladong的公众号，强烈推荐，值得一看，如果看过，请直接下滑，内容在下面</strong><br>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。</p>
<p>这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？</p>
<p>我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。</p>
<p>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</p>
<p>「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p>
<p>「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p>
<p>「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</p>
<p>了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。</p>
<p>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：</p>
<p>数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</p>
<p>链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。<br>**</p>
<h4 id="1-队列介绍"><a href="#1-队列介绍" class="headerlink" title="1. 队列介绍"></a>1. 队列介绍</h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在<strong>表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>数据结构里的队列就是模仿现实中的排队。</p>
<p>1） 新来的都排在队尾；<br>2） 最前面的办理业务后离队，后面一个跟上。<br>根据特点，计算机砖家就归纳以下队列结构。</p>
<h4 id="2-Golang-实现"><a href="#2-Golang-实现" class="headerlink" title="2. Golang 实现"></a>2. Golang 实现</h4><h5 id="2-1-队列结构"><a href="#2-1-队列结构" class="headerlink" title="2.1. 队列结构"></a>2.1. 队列结构</h5><p>同前文的栈一样，在这里，我把队列拆分为两个部分，容器和链表，容器用结构体实现，链表用单链表，当然大家也可以用其他链表结构，甚至数组来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">type QueueNode struct &#123;</span><br><span class="line">    Data interface&#123;&#125;</span><br><span class="line">    Next *QueueNode</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;创建链列（数据）</span><br><span class="line">func (queue *QueueNode) Create(Data ...interface&#123;&#125;) &#123;</span><br><span class="line">    if queue &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if len(Data) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建链列</span><br><span class="line">    for _, v :&#x3D; range Data &#123;</span><br><span class="line">        newNode :&#x3D; new(QueueNode)</span><br><span class="line">        newNode.Data &#x3D; v</span><br><span class="line"> </span><br><span class="line">        queue.Next &#x3D; newNode</span><br><span class="line">        queue &#x3D; queue.Next</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;打印链列</span><br><span class="line">func (queue *QueueNode) Print() &#123;</span><br><span class="line">    if queue &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    for queue !&#x3D; nil &#123;</span><br><span class="line">        if queue.Data !&#x3D; nil &#123;</span><br><span class="line">            fmt.Print(queue.Data, &quot; &quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue &#x3D; queue.Next</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;链列个数</span><br><span class="line">func (queue *QueueNode) Length() int &#123;</span><br><span class="line">    if queue &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    for queue.Next !&#x3D; nil &#123;</span><br><span class="line">        i++</span><br><span class="line">        queue &#x3D; queue.Next</span><br><span class="line">    &#125;</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;入列(insert)</span><br><span class="line">func (queue *QueueNode) Push(Data interface&#123;&#125;) &#123;</span><br><span class="line">    &#x2F;&#x2F;放在队列的末尾</span><br><span class="line"> </span><br><span class="line">    if queue &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if Data &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;找到队列末尾</span><br><span class="line">    for queue.Next !&#x3D; nil &#123;</span><br><span class="line">        queue &#x3D; queue.Next</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建新节点 将新节点加入队列末尾</span><br><span class="line">    newNode :&#x3D; new(QueueNode)</span><br><span class="line">    newNode.Data &#x3D; Data</span><br><span class="line"> </span><br><span class="line">    queue.Next &#x3D; newNode</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;出队(delete)</span><br><span class="line">func (queue *QueueNode) Pop() &#123;</span><br><span class="line">    &#x2F;&#x2F;队头出列</span><br><span class="line">    if queue &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;记录列队第一个的节点</span><br><span class="line">    &#x2F;&#x2F;node:&#x3D;queue.Next</span><br><span class="line">    &#x2F;&#x2F;queue.Next&#x3D;node.Next</span><br><span class="line"> </span><br><span class="line">    queue.Next &#x3D; queue.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>以上就是本次所有内容，希望对你有所帮助！！！</strong></em></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
		  
			<a href="/tags/%E9%98%9F%E5%88%97/">队列</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/05/26/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8(%E7%95%AA%E5%A4%96%E7%AF%87)/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">go设计模式-迭代器(番外篇)</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/05/26/list%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%93%8D%E4%BD%9C/">
        <span class="next-text nav-default">“list的实现与操作”</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
