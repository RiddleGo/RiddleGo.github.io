<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="并发控制模式：orDone的两种实现"/>








  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/09/06/并发控制模式：orDone的两种实现/"/>


<meta name="description" content="点击原文链接获得更好阅读排版 文章目录 方式一 递归  方式二 利用反射  性能差异   orDone 是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。 今天我们来看下两种不同的实现方式： 方式一 递归利用二分法递归， 将所有待监听信号的chan都select起来， 当有第一个chan返回时，close orDone 来通知读取方已有第一个任务返回 代码如下比较直观：">
<meta property="og:type" content="article">
<meta property="og:title" content="并发控制模式：orDone的两种实现">
<meta property="og:url" content="https://riddlego.github.io/2021/09/06/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%9AorDone%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="点击原文链接获得更好阅读排版 文章目录 方式一 递归  方式二 利用反射  性能差异   orDone 是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。 今天我们来看下两种不同的实现方式： 方式一 递归利用二分法递归， 将所有待监听信号的chan都select起来， 当有第一个chan返回时，close orDone 来通知读取方已有第一个任务返回 代码如下比较直观：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-06T15:10:37.000Z">
<meta property="article:modified_time" content="2021-09-06T15:15:46.319Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="zh-Hans">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 并发控制模式：orDone的两种实现 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          并发控制模式：orDone的两种实现
        
      </h1>

      <time class="post-time">
          9月 06 2021
      </time>
    </header>



    
            <div class="post-content">
            <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/F5H0C--diuuPTcrZhSC0cA">点击原文链接获得更好阅读排版</a></p>
<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ul>
<li><p>方式一 递归</p>
</li>
<li><p>方式二 利用反射</p>
</li>
<li><p>性能差异</p>
</li>
</ul>
<p>orDone 是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。</p>
<p>今天我们来看下两种不同的实现方式：</p>
<h2 id="方式一-递归"><a href="#方式一-递归" class="headerlink" title="方式一 递归"></a>方式一 递归</h2><p>利用二分法递归， 将所有待监听信号的chan都select起来，</p>
<p>当有第一个chan返回时，close orDone 来通知读取方已有第一个任务返回</p>
<p>代码如下比较直观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入多个并发chan，返回是否结束的 orDone chan</span><br><span class="line">func Or(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> &#x2F;&#x2F; 只有零个或者1个chan</span><br><span class="line"> switch len(channels) &#123;</span><br><span class="line"> case 0:</span><br><span class="line">        &#x2F;&#x2F; 返回nil， 让读取阻塞等待</span><br><span class="line">  return nil</span><br><span class="line"> case 1:</span><br><span class="line">  return channels[0]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回时利用close做结束信号的广播</span><br><span class="line">  defer close(orDone)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 利用select监听第一个chan的返回</span><br><span class="line">  switch len(channels) &#123;</span><br><span class="line">  case 2: &#x2F;&#x2F; 直接select</span><br><span class="line">   select &#123;</span><br><span class="line">   case &lt;-channels[0]:</span><br><span class="line">   case &lt;-channels[1]:</span><br><span class="line">   &#125;</span><br><span class="line">  default: &#x2F;&#x2F; 二分法递归处理</span><br><span class="line">   m :&#x3D; len(channels) &#x2F; 2</span><br><span class="line">   select &#123;</span><br><span class="line">   case &lt;-Or(channels[:m]...):</span><br><span class="line">   case &lt;-Or(channels[m:]...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> return orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方式二-利用反射"><a href="#方式二-利用反射" class="headerlink" title="方式二 利用反射"></a>方式二 利用反射</h2><p>这里要用到reflect.SelectCase, 他可以描述一种select的case, 来指明其接受的是chan的读取或发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SelectCase struct &#123;</span><br><span class="line"> Dir  SelectDir &#x2F;&#x2F; direction of case</span><br><span class="line"> Chan Value     &#x2F;&#x2F; channel to use (for send or receive)</span><br><span class="line"> Send Value     &#x2F;&#x2F; value to send (for send)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个，就可以之间遍历，不用递归来实现有限的select case构造</p>
<p>最后用reflect.Select(cases)监听信号就可以了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func OrInReflect(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> &#x2F;&#x2F; 只有0个或者1个</span><br><span class="line"> switch len(channels) &#123;</span><br><span class="line"> case 0:</span><br><span class="line">  return nil</span><br><span class="line"> case 1:</span><br><span class="line">  return channels[0]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer close(orDone)</span><br><span class="line">  &#x2F;&#x2F; 利用反射构建SelectCase，这里是读取</span><br><span class="line">  var cases []reflect.SelectCase</span><br><span class="line">  for _, c :&#x3D; range channels &#123;</span><br><span class="line">   cases &#x3D; append(cases, reflect.SelectCase&#123;</span><br><span class="line">    Dir:  reflect.SelectRecv,</span><br><span class="line">    Chan: reflect.ValueOf(c),</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 随机选择一个可用的case</span><br><span class="line">  reflect.Select(cases)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> return orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>这两种都可以支持大量chan的信号监听，那性能差异大么</p>
<p>虽说递归开销肯定不小，反射也不一定效率高，拿个压测来试试吧</p>
<p>先构造一下大量并发chan</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func repeat(</span><br><span class="line"> done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 外部传入done控制是否结束</span><br><span class="line"> values ...interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> valueStream :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回时释放</span><br><span class="line">  defer close(valueStream)</span><br><span class="line">  for &#123;</span><br><span class="line">   for _, v :&#x3D; range values &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-done:</span><br><span class="line">     return</span><br><span class="line">    case valueStream &lt;- v:</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> return valueStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后压测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkOr(b *testing.B) &#123;</span><br><span class="line"> done :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> defer close(done)</span><br><span class="line"> num :&#x3D; 100</span><br><span class="line"> streams :&#x3D; make([]&lt;-chan interface&#123;&#125;, num)</span><br><span class="line"> for i :&#x3D; range streams &#123;</span><br><span class="line">  streams[i] &#x3D; repeat(done, []int&#123;1, 2, 3&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> b.ResetTimer()</span><br><span class="line"> for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  &lt;-Or(streams...)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkOrInReflect(b *testing.B) &#123;</span><br><span class="line"> &#x2F;&#x2F; 代码类似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑了下结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;NewbMiao&#x2F;Dig101-Go&#x2F;concurrency&#x2F;channel&#x2F;schedule&#x2F;orDone</span><br><span class="line">BenchmarkOr-12                 31815      38136 ns&#x2F;op     9551 B&#x2F;op       99 allocs&#x2F;op</span><br><span class="line">BenchmarkOrInReflect-12        55797      21755 ns&#x2F;op    25232 B&#x2F;op      112 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>可以看出，大量并发chan场景下， 反射使用内存更多些，但速度更快。</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/09/06/%E6%88%91%E7%BB%88%E4%BA%8E%E8%AF%86%E7%A0%B4%E4%BA%86%E8%BF%99%E4%B8%AAGo%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%8A%E6%88%8F/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">我终于识破了这个Go编译器把戏</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/09/06/Go-Module%E6%95%99%E7%A8%8B%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E9%95%9C%E5%83%8F%E3%80%81%E6%A0%A1%E9%AA%8C%E5%92%8C%E4%BB%A5%E5%8F%8AAthens/">
        <span class="next-text nav-default">Go-Module教程第4部分：镜像、校验和以及Athens</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
