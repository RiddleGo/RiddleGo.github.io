<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Go语言微服务框架-5.GORM库的适配sqlmock的单元测试"/>




  <meta name="keywords" content="GORM," />





  <link rel="alternate" href="/atom.xml" title="RiddleGo" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://riddlego.github.io/2021/09/05/Go语言微服务框架-5-GORM库的适配sqlmock的单元测试/"/>


<meta name="description" content="原文全部来自，请移步原文阅读，这里就是边看边复制的笔记，点击进入原文 随着GORM库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的GORM过于简单，应用到实际的项目中局限性很大。 与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的MySQL去验证功能，那成本实在太高。那么，这里我们就引入一个经典的sqlmock框架，并配合对数据库相关代码的修改，来实">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言微服务框架-5.GORM库的适配sqlmock的单元测试">
<meta property="og:url" content="https://riddlego.github.io/2021/09/05/Go%E8%AF%AD%E8%A8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-5-GORM%E5%BA%93%E7%9A%84%E9%80%82%E9%85%8Dsqlmock%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="RiddleGo">
<meta property="og:description" content="原文全部来自，请移步原文阅读，这里就是边看边复制的笔记，点击进入原文 随着GORM库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的GORM过于简单，应用到实际的项目中局限性很大。 与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的MySQL去验证功能，那成本实在太高。那么，这里我们就引入一个经典的sqlmock框架，并配合对数据库相关代码的修改，来实">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-05T04:19:18.000Z">
<meta property="article:modified_time" content="2021-09-05T07:51:30.598Z">
<meta property="article:author" content="Russshare">
<meta property="article:tag" content="GORM">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Go语言微服务框架-5.GORM库的适配sqlmock的单元测试 - RiddleGo </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">RiddleGo</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Go语言微服务框架-5.GORM库的适配sqlmock的单元测试
        
      </h1>

      <time class="post-time">
          9月 05 2021
      </time>
    </header>



    
            <div class="post-content">
            <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3YI50zoRbBb_VuFB-ZzEvg">原文全部来自，请移步原文阅读，这里就是边看边复制的笔记，点击进入原文</a></p>
<p>随着GORM库的引入，我们在数据库持久化上已经有了解决方案。但上一篇我们使用的GORM过于简单，应用到实际的项目中局限性很大。</p>
<p>与此同时，我们也缺乏一个有效的手段来验证自己编写的相关代码。如果依靠连接到真实的MySQL去验证功能，那成本实在太高。那么，这里我们就引入一个经典<strong>的sqlmock框架</strong>，并配合对数据库相关代码的修改，来实现相关代码的可测试性。</p>
<h2 id="v0-4-1：GORM库的适配sqlmock的单元测试"><a href="#v0-4-1：GORM库的适配sqlmock的单元测试" class="headerlink" title="v0.4.1：GORM库的适配sqlmock的单元测试"></a>v0.4.1：GORM库的适配sqlmock的单元测试</h2><p>项目链接 <a target="_blank" rel="noopener" href="https://github.com/Junedayday/micro_web_service/tree/v0.4.1">https://github.com/Junedayday/micro_web_service/tree/v0.4.1</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于主要是针对GORM的小改动，所以增加了一个小版本号</span><br></pre></td></tr></table></figure>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>利用sqlmock工具，并对数据库相关代码进行修改，实现单元测试。</p>
<h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><p>Order相关代码的改造</p>
<p>引入sqlmock到测试代码</p>
<p>注意点讲解</p>
<h2 id="目录构造"><a href="#目录构造" class="headerlink" title="目录构造"></a>目录构造</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--- micro_web_service            项目目录</span><br><span class="line"> |-- gen                            从idl文件夹中生成的文件，不可手动修改</span><br><span class="line">    |-- idl                             对应idl文件夹</span><br><span class="line">       |-- demo                             对应idl&#x2F;demo服务</span><br><span class="line">          |-- demo.pb.go                        demo.proto的基础结构</span><br><span class="line">          |-- demo.pb.gw.go                     demo.proto的HTTP接口，对应gRPC-Gateway</span><br><span class="line">          |-- demo_grpc.pb.go                   demo.proto的gRPC接口代码</span><br><span class="line"> |-- idl                            原始的idl定义</span><br><span class="line">    |-- demo                            业务package定义</span><br><span class="line">       |-- demo.proto                       protobuffer的原始定义</span><br><span class="line"> |-- internal                       项目的内部代码，不对外暴露</span><br><span class="line">    |-- config                          配置相关的文件夹</span><br><span class="line">       |-- viper.go                         viper的相关加载逻辑</span><br><span class="line">    |-- dao                             Data Access Object层</span><br><span class="line">       |-- order.go                         更新：OrderO对象，订单表</span><br><span class="line">       |-- order_test.go                    新增：Order的单元测试</span><br><span class="line">    |-- mysql                           MySQL连接</span><br><span class="line">       |-- init.go                          初始化连接到MySQL的工作</span><br><span class="line">    |-- server                          服务器的实现</span><br><span class="line">       |-- demo.go                          server中对demo这个服务的接口实现</span><br><span class="line">       |-- server.go                        server的定义，须实现对应服务的方法</span><br><span class="line">     |-- zlog                            封装日志的文件夹</span><br><span class="line">        |-- zap.go                           zap封装的代码实现</span><br><span class="line"> |-- buf.gen.yaml                   buf生成代码的定义</span><br><span class="line"> |-- buf.yaml                       buf工具安装所需的工具</span><br><span class="line"> |-- gen.sh                         buf生成的shell脚本</span><br><span class="line"> |-- go.mod                         Go Module文件</span><br><span class="line"> |-- main.go                        项目启动的main函数</span><br></pre></td></tr></table></figure>

<h2 id="1-Order相关代码的改造"><a href="#1-Order相关代码的改造" class="headerlink" title="1.Order相关代码的改造"></a>1.Order相关代码的改造</h2><p>我们要对Order相关的代码进行改造，来满足以下两个点：</p>
<ul>
<li><p>1—可测试性，可以脱离对真实数据库连接的依赖</p>
</li>
<li><p>2—灵活的更新方法，可以支持对指定条件、指定字段的更新</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  gorm.io&#x2F;gorm 指的是gorm V2版本，详细可参考 https:&#x2F;&#x2F;gorm.io&#x2F;zh_CN&#x2F;docs&#x2F;v2_release_note.html</span><br><span class="line">  github.com&#x2F;jinzhu&#x2F;gorm 一般指V1版本</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">type OrderRepo struct &#123;</span><br><span class="line"> db *gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将gorm.DB作为一个参数，在初始化时赋值：方便测试时，放一个mock的db</span><br><span class="line">func NewOrderRepo(db *gorm.DB) *OrderRepo &#123;</span><br><span class="line"> return &amp;OrderRepo&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Order针对的是 orders 表中的一行数据</span><br><span class="line">type Order struct &#123;</span><br><span class="line"> Id    int64</span><br><span class="line"> Name  string</span><br><span class="line"> Price float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; OrderFields 作为一个 数据库Order对象+fields字段的组合</span><br><span class="line">&#x2F;&#x2F; fields用来指定Order中的哪些字段生效</span><br><span class="line">type OrderFields struct &#123;</span><br><span class="line"> order  *Order</span><br><span class="line"> fields []interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewOrderFields(order *Order, fields []interface&#123;&#125;) *OrderFields &#123;</span><br><span class="line"> return &amp;OrderFields&#123;</span><br><span class="line">  order:  order,</span><br><span class="line">  fields: fields,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (repo *OrderRepo) AddOrder(order *Order) (err error) &#123;</span><br><span class="line"> err &#x3D; repo.db.Create(order).Error</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (repo *OrderRepo) QueryOrders(pageNumber, pageSize int, condition *OrderFields) (orders []Order, err error) &#123;</span><br><span class="line"> db :&#x3D; repo.db</span><br><span class="line"> &#x2F;&#x2F; condition非nil的话，追加条件</span><br><span class="line"> if condition !&#x3D; nil &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里的field指定了order中生效的字段，这些字段会被放在SQL的where条件中</span><br><span class="line">  db &#x3D; db.Where(condition.order, condition.fields...)</span><br><span class="line"> &#125;</span><br><span class="line"> err &#x3D; db.</span><br><span class="line">  Limit(pageSize).</span><br><span class="line">  Offset((pageNumber - 1) * pageSize).</span><br><span class="line">  Find(&amp;orders).Error</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (repo *OrderRepo) UpdateOrder(updated, condition *OrderFields) (err error) &#123;</span><br><span class="line"> if updated &#x3D;&#x3D; nil || len(updated.fields) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">  return errors.New(&quot;update must choose certain fields&quot;)</span><br><span class="line"> &#125; else if condition &#x3D;&#x3D; nil &#123;</span><br><span class="line">  return errors.New(&quot;update must include where condition&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> err &#x3D; repo.db.</span><br><span class="line">  Model(&amp;Order&#123;&#125;).</span><br><span class="line">  &#x2F;&#x2F; 这里的field指定了order中被更新的字段</span><br><span class="line">  Select(updated.fields[0], updated.fields[1:]...).</span><br><span class="line">  &#x2F;&#x2F; 这里的field指定了被更新的where条件中的字段</span><br><span class="line">  Where(condition.order, condition.fields...).</span><br><span class="line">  Updates(updated.order).</span><br><span class="line">  Error</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-引入sqlmock到测试代码"><a href="#2-引入sqlmock到测试代码" class="headerlink" title="2.引入sqlmock到测试代码"></a>2.引入sqlmock到测试代码</h2><p>sqlmock是检查数据库最常用的工具，我们先不管它使用起来的复杂性，先来看看怎么实现对应的测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，我们使用的是gorm 2.0，网上很多例子其实是针对1.0的</span><br><span class="line">var (</span><br><span class="line"> DB   *gorm.DB</span><br><span class="line"> mock sqlmock.Sqlmock</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TestMain是在当前package下，最先运行的一个函数，常用于初始化</span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line"> var (</span><br><span class="line">  db  *sql.DB</span><br><span class="line">  err error</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> db, mock, err &#x3D; sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> DB, err &#x3D; gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  Conn:                      db,</span><br><span class="line">  SkipInitializeWithVersion: true,</span><br><span class="line"> &#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; m.Run 是真正调用下面各个Test函数的入口</span><br><span class="line"> os.Exit(m.Run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  sqlmock 对语法限制比较大，下面的sql语句必须精确匹配（包括符号和空格）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">func TestOrderRepo_AddOrder(t *testing.T) &#123;</span><br><span class="line"> var order &#x3D; &amp;Order&#123;Name: &quot;order1&quot;, Price: 1.1&#125;</span><br><span class="line"> orderRepo :&#x3D; NewOrderRepo(DB)</span><br><span class="line"></span><br><span class="line"> mock.ExpectBegin()</span><br><span class="line"> mock.ExpectExec(&quot;INSERT INTO &#96;orders&#96; (&#96;name&#96;,&#96;price&#96;) VALUES (?,?)&quot;).</span><br><span class="line">  WithArgs(order.Name, order.Price).</span><br><span class="line">  WillReturnResult(sqlmock.NewResult(1, 1))</span><br><span class="line"> mock.ExpectCommit()</span><br><span class="line"> err :&#x3D; orderRepo.AddOrder(order)</span><br><span class="line"> assert.Nil(t, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestOrderRepo_QueryOrders(t *testing.T) &#123;</span><br><span class="line"> var orders &#x3D; []Order&#123;</span><br><span class="line">  &#123;1, &quot;name1&quot;, 1.0&#125;,</span><br><span class="line">  &#123;2, &quot;name2&quot;, 1.0&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> page, size :&#x3D; 2, 10</span><br><span class="line"> orderRepo :&#x3D; NewOrderRepo(DB)</span><br><span class="line"> condition :&#x3D; NewOrderFields(&amp;Order&#123;Price: 1.0&#125;, []interface&#123;&#125;&#123;&quot;price&quot;&#125;)</span><br><span class="line"></span><br><span class="line"> mock.ExpectQuery(</span><br><span class="line">  &quot;SELECT * FROM &#96;orders&#96; WHERE &#96;orders&#96;.&#96;price&#96; &#x3D; ? LIMIT 10 OFFSET 10&quot;).</span><br><span class="line">  WithArgs(condition.order.Price).</span><br><span class="line">  WillReturnRows(</span><br><span class="line">   sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;name&quot;, &quot;price&quot;&#125;).</span><br><span class="line">    AddRow(orders[0].Id, orders[0].Name, orders[0].Price).</span><br><span class="line">    AddRow(orders[1].Id, orders[1].Name, orders[1].Price))</span><br><span class="line"></span><br><span class="line"> ret, err :&#x3D; orderRepo.QueryOrders(page, size, condition)</span><br><span class="line"> assert.Nil(t, err)</span><br><span class="line"> assert.Equal(t, orders, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestOrderRepo_UpdateOrder(t *testing.T) &#123;</span><br><span class="line"> orderRepo :&#x3D; NewOrderRepo(DB)</span><br><span class="line"> &#x2F;&#x2F; 表示要更新的字段为Order对象中的id,name两个字段</span><br><span class="line"> updated :&#x3D; NewOrderFields(&amp;Order&#123;Id: 1, Name: &quot;test_name&quot;&#125;, []interface&#123;&#125;&#123;&quot;id&quot;, &quot;name&quot;&#125;)</span><br><span class="line"> &#x2F;&#x2F; 表示更新的条件为Order对象中的price字段</span><br><span class="line"> condition :&#x3D; NewOrderFields(&amp;Order&#123;Price: 1.0&#125;, []interface&#123;&#125;&#123;&quot;price&quot;&#125;)</span><br><span class="line"></span><br><span class="line"> mock.ExpectBegin()</span><br><span class="line"> mock.ExpectExec(</span><br><span class="line">  &quot;UPDATE &#96;orders&#96; SET &#96;id&#96;&#x3D;?,&#96;name&#96;&#x3D;? WHERE &#96;orders&#96;.&#96;price&#96; &#x3D; ?&quot;).</span><br><span class="line">  WithArgs(updated.order.Id, updated.order.Name, condition.order.Price).</span><br><span class="line">  WillReturnResult(sqlmock.NewResult(1, 1))</span><br><span class="line"> mock.ExpectCommit()</span><br><span class="line"></span><br><span class="line"> err :&#x3D; orderRepo.UpdateOrder(updated, condition)</span><br><span class="line"> assert.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-注意点讲解"><a href="#3-注意点讲解" class="headerlink" title="3.注意点讲解"></a>3.注意点讲解</h2><p>虽然添加了注释，我这边依旧讲一下修改的重点：</p>
<ul>
<li><p>gorm.DB作为一个初始化的参数，将其转变成一个依赖注入，使这块代码更具可测试性</p>
</li>
<li><p>查询和更新采用了一个新的结构体OrderFields，是用里面的fields声明了order中哪个字段生效</p>
</li>
</ul>
<h2 id="GORM框架的进一步扩展"><a href="#GORM框架的进一步扩展" class="headerlink" title="GORM框架的进一步扩展"></a>GORM框架的进一步扩展</h2><p>通过这一次对GORM数据库相关代码的迭代，还是可以发现有些不足：</p>
<ul>
<li><p>对复杂SQL的支持不足：如group by、子查询等语句</p>
</li>
<li><p>对field这块限制不好，id, name， price，容易发生误填字段的问题</p>
</li>
<li><p>没有串联日志模块</p>
</li>
</ul>
<p>接下来的模块，我会逐渐对2、3两点进行补充，而第1点需要有选择性地实现，我也会结合具体的场景进行分享。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一个小版本，我们让DAO这个与数据库交互模块的代码更具<strong>可读性（从调用侧可以清楚地了解到要做什么）、健壮性（单元测试）和可扩展性（对后续字段的扩展也很容易支持）。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Github: https:&#x2F;&#x2F;github.com&#x2F;Junedayday&#x2F;code_reading</span><br><span class="line"></span><br><span class="line">Blog: http:&#x2F;&#x2F;junes.tech&#x2F;</span><br><span class="line"></span><br><span class="line">Bilibili: https:&#x2F;&#x2F;space.bilibili.com&#x2F;293775192</span><br><span class="line"></span><br><span class="line">公众号: golangcoding</span><br></pre></td></tr></table></figure>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/GORM/">GORM</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/09/05/Go-%E5%BA%95%E5%B1%82/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Go-底层</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/09/04/Go-%E6%8F%92%E4%BB%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">
        <span class="next-text nav-default">Go-插件功能的实现方式</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2021
    <span class="footer-author">Russshare.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
