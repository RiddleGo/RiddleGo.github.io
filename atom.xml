<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RiddleGo</title>
  
  <subtitle>小时候想以后做个作家</subtitle>
  <link href="https://riddlego.github.io/atom.xml" rel="self"/>
  
  <link href="https://riddlego.github.io/"/>
  <updated>2021-10-20T08:43:18.636Z</updated>
  <id>https://riddlego.github.io/</id>
  
  <author>
    <name>Russshare</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>next-zhenxi</title>
    <link href="https://riddlego.github.io/2021/10/20/next-zhenxi/"/>
    <id>https://riddlego.github.io/2021/10/20/next-zhenxi/</id>
    <published>2021-10-20T06:04:39.000Z</published>
    <updated>2021-10-20T08:43:18.636Z</updated>
    
    <content type="html"><![CDATA[<p>这过去的两年多，真的好快，一不小心就是教研室的大师兄了，时间要是和我一样赖在床上不走，可是我还是期待快点长大，因为真的还有好多的事情需要我去寻找答案。也不能自私的让爸妈一直去承担太多的东西，想要的，想给予的都存在。</p><p>那间一个人的宿舍，让我过的不算是辜负，用好多个假期与凌晨做出了一份满满当当的简历，因为是从零开始，所以就要比别人走的多，因为资历差所以能得到的只要次等的资源，但那也是我不敢奢求的，尽管被各种流言蜚语包围，是抱着嘲笑又或是揶揄的态度，我也开始装模作样的哈哈一过。偶尔不小心让不满和情绪从嘴巴不小心漏出，就特别的后怕，因为过往的经历，所以我都尽量眯着眼睛，不让自己开口讲话。</p><p>当然这都是自我的一点罗里吧嗦的废话，下一步要做的就是好好的整理与学习，将这过往学习的技术栈进行一个整理，还有对应的资料也需要进行整理，想着进行分享出去，因为暂时的技术深度不适合做技术分享，同时也没有开始真正的工作，再加上又不是计算机专业的，平时所做的项目都是综合性的，软硬件都需要设计，所以这样的话最好还是推迟一点。</p><p>确实没有计划好下一步的事情就会显得无所事事，想个没头的苍蝇，很让人烦恼，但是如果说真的做个list去记录完成，又会觉得有点不舒服和不习惯。啊哈，再一次证明我是矛盾体的诞生。而且感觉自己的记忆力真的越来越下滑了，哈哈，可怕怕。所以真的有个便签太重要了，便利贴也还是蛮不错的。</p><p>这段时间，开始不那么苛责自己，开始学会接纳自己，但是好像在某些小的方向，还是不能这么这样的随意，毕竟是需要push自己的，接纳不是随意。<br>不过不知道多久，或者是好久之前被拖延症开始被感染这个时不时很严重的影响到自己。每次开始打算或者计划好要做什么不会马上行动，但是会先看看视频，这是极其不好的，这过往的两年B站的关键词都是学习，今年差了点意思，可能存在部分是满足不了自己的问题解决，更多地是懈怠了。打着接纳自己的口号懈怠了，下一个阶段确实还需要做的蛮多的。进入之前需要学习的也有很多，希望能提前安排一下，或者是随缘吧，这谁能决定啊，阿西，给我一个方向啊倒是，哈哈，md，这样一想，从15年的无头绪变成现在的无头绪，哈哈。不过那就踏实做好手上的事情，然后也可以去定制一些，做一些记录，进行自己技术栈的优化，我想一定能用上的，迷茫的时候也不要停下脚步吧，迷雾散开的时候才会一把抓住。</p><p>嗯哼，纠正自己的，不要压制自己的欲望，而是让自己的欲望变得高级和有意义。同时，不用想着在学校就好好玩，现在已经很轻松，每个人来自不同的起点，又处在不一样的环境，不一样的现在的忙碌已经让我觉得很幸福了，这样的环境，想着自己17年在30多度的铝合金大棚里切割铁板的时候，那个时候和比我大十几岁的工友们住在板房里，两个工业风扇在房间里面呼啦啦的吹，用这玩意一定得往地上先浇水，不然尘土会随着风飞进你的呼吸，进入你身体的每个部分，我也不知道这是不是那些大叔吓我的，不过总是让我想起电影里面看见的那些被陷入沼泽的人，于是我每次总是捂着被子睡觉，即使满头大汗，挨着我的叔每次睡觉前总是说年轻人身体就是好，干完一天活还能有着心思，然后大家都大笑，那个时候我不知道为什么大家为什么每次听到这个就会笑，也不知道他原来说我在捂着被子做手淫。斜对面床的大哥只大我几岁，每天晚上都在和网上一个女人聊天，偶尔不聊天的时候就从他枕头下面把那个用发黄卫生纸包住的口风琴拿出来吹，我也自学过，但是中途放弃了，我很羡慕他，口风琴让他和我们看起来不在一个世界一样，而我不想一辈子就这样。</p><p>最近是过的比较充足但一点也不算是充实，各样的繁琐事情，最不好的就是沉浸程度太低，这样其实自我的学习程度是极其低下的，对一件事情的深刻程度太低了所以说还是需要时间的投入，很烦就是一喝水就想尿尿，一检查就说心里问题以及正常的生理情况。这倒是让人非常的不舒服，所以工作的时候就减少水的摄入，这是最好的办法啦。</p><p>blabla的废话，后面要做的事情就一件一件的开始记录，添加或者删除，请珍惜环境与时间，并将眼睛与胆量结合，做点不一样的事情，这样的同时还可以满足自己小时候的愿望，帮助更多地人。这是一直所期待的，相比于死亡，最可怕的莫不是被人遗忘。其实也知道一直的工作是不可能会延续下去的，不知道现在的状态与渴望会持续到多久，我甚至已经开始想我写遗书的时候有多帅，哈哈给我儿子、孙子一人整封信，我只写那么几句话，剩下的全部塞满金银财宝，哈哈想着就觉得很酷。所以其实另一方面还是要有除了工作以外的灰色收入，这部分收入应该是不受到周遭环境的限制，应该是一直存在的，应该是持续的。存钱我想永远都不是最妥当的办法，是的，现在想做的就是自媒体，和投资。自媒体入门较低，但是要产生收益，那肯定是需要有特别的品质和过硬的质量输出，这样才经得起考验。这样就需要积累，可是自己，嗯哼，健身、技术、或者文学都是个二杆子，md没有特别的特长真是让人难过的事情。</p><p>不过太多的也不用可以的去想，下一步的事情，要好好地做一个计划还是蛮难的，现在自己的想法太多，我不想轻易对自己的每个精彩都放弃，于是乎，我想以后记录下来自己的每个想法，然后开始坚持做下去，坚持一个月没有效益就可以放弃，也不是什么都坚持，可以先做调研，先去学习。</p><p>看书是必须写下自己的感悟的，或许忘记了句子，也忘了故事情节，脑子里剩下的只有那几个惊人的巧合或者翻转，但是看完肯定有很多要说的，这部分是很重要的，记录下来也算是对这本书做个纪念。</p><h2 id="接下来要做的事情"><a href="#接下来要做的事情" class="headerlink" title="接下来要做的事情"></a>接下来要做的事情</h2><p>项目  配合解决，然后记录出现的问题，电路的设计遇到的问题，在进行这里需要考虑到哪些方面的影响，避免这些影响涉及的技术，再稍微拓展，进行整理</p><p>毕设的模块间的走通  前端采集+信号发送+数据展示  并将需要的素材进行整理，每个模块的资料进行整理，可以测量大量的数据，然后进行数据的分析处理</p><p>毕业论文 这部分需要阅读文献+资料的整理+整个毕业论文的框架结构</p><p>技术栈的路线图整理+每个方向需要学习那些技术，应该到哪种程度</p><p>博客、资料的整理  也算是对这两年多时间的一个整理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这过去的两年多，真的好快，一不小心就是教研室的大师兄了，时间要是和我一样赖在床上不走，可是我还是期待快点长大，因为真的还有好多的事情需要我去寻找答案。也不能自私的让爸妈一直去承担太多的东西，想要的，想给予的都存在。&lt;/p&gt;
&lt;p&gt;那间一个人的宿舍，让我过的不算是辜负，用好多</summary>
      
    
    
    
    <category term="猛男日记" scheme="https://riddlego.github.io/categories/%E7%8C%9B%E7%94%B7%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>每天都在学会告别</title>
    <link href="https://riddlego.github.io/2021/10/20/%E6%AF%8F%E5%A4%A9%E9%83%BD%E5%9C%A8%E5%AD%A6%E4%BC%9A%E5%91%8A%E5%88%AB/"/>
    <id>https://riddlego.github.io/2021/10/20/%E6%AF%8F%E5%A4%A9%E9%83%BD%E5%9C%A8%E5%AD%A6%E4%BC%9A%E5%91%8A%E5%88%AB/</id>
    <published>2021-10-20T05:59:46.000Z</published>
    <updated>2021-10-20T06:04:09.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这算是对最近这几个月的一点回溯，或者是反思总结一些空间。不知道多久开始可以的避免不让人快乐得字词。<br>成长需要不断学习的就是告别，而最不期待的就行学习这个。哈哈，偶尔这时候就感觉自己还像个小屁孩，阿西，这可不是很好的状态。<br>人总是有不好的，会被一些先来的偏见给予掩藏，结果到了分别的时候，一切的都不是那么重要，反而有的时候还会后悔当时为什么不好好的讲话沟通，可是时间是永远不会倒着转，于是做过的事情就像钉子一样，拔起来还会有一个印记在那里，这点事情永远不会消逝，被时间渐渐的磨损掉表面的粗糙，偶在在往后的相似场景被回想起来。<br>这几个月的实习，学习到的东西其实是与时间不成正比的，不过这段时间也做了其他的事情，算是有个着落，但是说不清是好是坏，毕竟未来的路怎么样走都说不准。但是这段是时间的技术补充确实太过的浅薄了，这是让我极度的不舒服和空虚，总是想着等以后吧这件事情忙完，再去做其他的事情，但是具体的生活中怎么可能给我们机会，大多数是一起蜂拥而至，又在某个凌晨的晚上最后闹腾一下然后散去。<br>关于技术这个方面，希望在所里用到的数据处理和可视化这部分能在毕业论文中用起来，也希望能做一个可视化数据分析的template，或者什么，微信公众号也好，或者其他的都好。做个记录，到时候回过头去复习或者怎么样都是好的，如果让这些随风而去，那可是极其有点可惜。无论是分享还是什么我想都是蛮不错的。于是乎也让我的下一步要做的事情多了个选项，毕竟混了这段时间，人就感觉很没有劲，not so good。</p><p>每个人都期待躺平，可是现在我偶尔还是会想起那个时候，六块钱的炒饭，在街头的啃馒头的时间，被白眼、责骂与鄙夷包裹的日子过的有多难受，凌晨一点入睡，四点醒来，每个夜晚都做着噩梦，还得装作死要面子的样子。那个时候没人在乎自己本身，什么都得自己扛着，害怕第二天就死掉，又在某个凌晨也不想活下去，可就是好不甘心。实习的这段时间，每天早上六点多骑车去地铁站的路上倒是有那个时候的感觉，但是现在可以交通工具，或者打个车，到了有亮亮的办公室，冬暖夏凉。边哭边觉得自己还可以再坚持一下，也许真的后面是没有希望的路途，但是还是不想这么样烂掉。</p><p>实习的结束比预期早了一点，因为有工资其实是还想再多待一会，但是因为实在是感觉荒废了太多的时间，学不到东西，让人开始着急与慌乱不安。</p><p>是矛盾体，一方面觉得自己算是某个方面是好的，一方面又容易自卑，处在这个环境。那个时候看着北大仰望星空招生宣传，一个人在宿舍哭的乱糟糟，也在好多时候给自己狠狠的一巴掌让自己继续别特么停下来，命运在屁股后面踹了一脚又一脚，叫嚣着不走就滚一边去，别给他家的少爷挡路。我不想看到经过我鄙夷的眼神，所以我一瘸一拐的还想在拖延一下，直到某个时间，或许那个时间是死亡。</p><p>因为抑郁的频繁，我学着自己去弱化悲伤，比较吃药太贵了。</p><p>我也是实在是搞不懂自己的心软，这是我不喜欢自己的脆弱一面，甚至宁愿长得凶恶一点。</p><p>我们总是在不同的地方、时间进行告别，告别昨天的自己，告别经过的事情与事物。</p><p>乱七八糟的猛男碎碎念，blablabla。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这算是对最近这几个月的一点回溯，或者是反思总结一些空间。不知道多久开始可以的避免不让人快乐得字词。&lt;br&gt;成长需要不断学习的就是告别，而最不</summary>
      
    
    
    
    <category term="猛男日记" scheme="https://riddlego.github.io/categories/%E7%8C%9B%E7%94%B7%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法怎样学习</title>
    <link href="https://riddlego.github.io/2021/10/20/%E7%AE%97%E6%B3%95%E6%80%8E%E6%A0%B7%E5%AD%A6%E4%B9%A0/"/>
    <id>https://riddlego.github.io/2021/10/20/%E7%AE%97%E6%B3%95%E6%80%8E%E6%A0%B7%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-20T05:59:15.000Z</published>
    <updated>2021-10-20T06:00:37.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从实力出发我实在是不配写这篇分享，但是还是斗胆分享一点小小心得和自己的看法、做法。如果真的有点用处那就是万分荣幸。</p><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>我先介绍一下背景，我面试所取得offer除了美团、字节以外都是手机厂，所以对算法的要求就是处于一个中等偏下到中等偏上。</p><p><strong>也有投递字节、BAT，侥幸在简历画的功夫没有浪费，简历在整个秋招都是all pass</strong></p><p>但是在做互联网大厂笔试的时候没有全部OC，基本上都是两个左右，有的厂一个也进面试了，后面还拿了offer，只能说感谢面试官放我一马。</p><p>这样这就是大概的情况，下面简单分享一下我的算法刷题经验。</p><h2 id="我的准备经历"><a href="#我的准备经历" class="headerlink" title="我的准备经历"></a>我的准备经历</h2><p>故事的小黄花。。。blabla，好了不闹了。<br>我是四月份开始刷题，因为这个时候我需要想去体验一下面试，于是乎边刷题边投递了几家大厂，然后做笔试的时候一脸懵逼</p><hr><p>我是谁？我姓啥？我在哪？</p><p>这是啥？要求啥？做个啥？</p><p>真的我感觉我以前的代码白写了，在经历惨无人道的被虐之后，痛定思痛，我觉得我的刷题方法有问题。</p><p><strong>1、一般看到一个题，一分钟没有思路，就看答案，然后觉得自己看懂了就会了。（实际上你懂得）</strong></p><p><strong>2、刷题太着急，没从基础开始，随机刷题。（对普通人来说实际上这就是浪费）</strong></p><p><strong>3、不相信方法，我对那些前辈讲的方法嗤之以鼻，觉得题刷就完事儿，整那么多花里胡哨的干嘛。（前辈我错了，我是傻蛋）</strong></p><p>于是我到某乎、某sdn以及前辈的blog开始学习前辈的刷题经验，再看了很多的的经验学习分享，以及白嫖了许多大佬的学习资料后，我开始根据自己的情况整理刷题的路径和方法。</p><p>这个时候我在研究所的实习面试通过了（国企面试yyds），于是乎这次的准备在我要实习和完成实验室项目课题的情况下开始了，于是这对我的计划要求愈发的提高。</p><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><p><strong>剑指offer</strong></p><p>这本书，答应我，必须看。<br>其实刚刚开始我觉得看这些书太浪费时间，直接上题猛冲就完事，然而是我太单纯。当现在回过头我结合学习的经历和面试的经历，我才发现这本书是真的重要，而我当时忽视前辈们的意见，我真是个傻蛋。</p><p>这本书循序渐进，你给我得劲的刷，耐心点，我面试手撕的题基本上全是出于此。</p><p>建议三遍：</p><p><strong>第一遍</strong>：快速刷题，不懂思路可以看答案，然后自己抄一遍，实现一遍，留个映像。</p><p><strong>第二遍</strong>：因为今年全是线上的共享屏幕的手撕，但是面试华为的时候，面试官让我写在纸上，然后拍照上传的操作是把我惊艳到了。第二遍我建议如果以后线下面试，我建议可以拿着问题手写一遍代码，别看答案，自己想。</p><p><strong>第三遍</strong>：这一遍就是巩固一下，到这个程度了，其实你对某些题之间的关系，与考点的归纳自己其实应该心里大概有个了解了。<strong>我一直倡导的记忆与学习不是死记硬背，而是思考与重复。</strong> 这一遍你可以去LeetCode上找到剑指offer题集刷。</p><p>ps:为什么我要说是思考与重复，这也是亲身体会，因为实习和项目，我在两个月的高密度刷题学习后，当时感觉自己又可以了，然后在实习期间就懈怠了，一周想起了刷个两三道，然而当信誓旦旦打开力扣准备一展身手的时候，被一道做过的中等难度题难住了。（阿西）</p><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><p>这里就不啰嗦了，就去刷那个牛客热题132，然后开始针对性的做一些大厂的真题。作用就是体会难度和打击一下现在状态膨胀的自己。</p><h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>说实话，我觉得算法真的对于一个程序员很重要，但是我觉得算法对于部分人不实用。对于这部分的人，我推荐LeetCode的真题，但是对于其他的题我持保留意见。</p><p>所以大概以上的流程就是  </p><hr><p><strong>剑指offer–&gt;牛客网真题、热题–&gt;LeetCode大厂真题、热题</strong></p><hr><p>到这里你肯定会说，啰里啰嗦这么久也没有个刷题的方法，对于算法难点的解答什么的干活，其实我也想写，奈何前辈们已经泄露太多经典有效的方法了。我就不献丑了，这里我就推荐一下我关注的算法公众号，真的对我有帮助，也希望能对你有所收获。</p><h3 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h3><p>偶然的邂逅吧，算法这部分确实被玩的透透的了，直接就是这个公众号—labuladong，然后什么动态规划、滑动窗口等等都讲的很清楚，对于算法这部分也讲的很详细。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一篇不太有干活的菜鸟分享，我这里不建议大家找一堆资料，小时候老师就说了一=本书看透比看很多本书好得多。</p><p>所以大家找资料找到<strong>合适的自己的</strong>资料找一份就可以，然后就踏实的学习即可。不用整太多，反而会花了心思。</p><p>剩下的就是坚持吧，突然想说人生啊就是不断地考试！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从实力出发我实在是不配写这篇分享，但是还是斗胆分享一点小小心得和自己的看法、做法。如果真的有点用处那就是万分荣幸。&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="面试合集" scheme="https://riddlego.github.io/categories/%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>all-pass简历</title>
    <link href="https://riddlego.github.io/2021/10/20/all-pass%E7%AE%80%E5%8E%86/"/>
    <id>https://riddlego.github.io/2021/10/20/all-pass%E7%AE%80%E5%8E%86/</id>
    <published>2021-10-20T05:58:59.000Z</published>
    <updated>2021-10-20T06:00:18.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实认识不到简历重要性，以及对简历不走心的情况对于我们应届生来说实在是正常。</p><p>不是因为懒，就是因为难，做一份好的简历实在是很不容易的，但是一份好的简历带来的收获也是非常你值得去付出的。</p><p>我是在经历石沉大海、前辈指点、自我反思以后开始反复修改自己的简历，在提前批、秋招中简历all-pass，当然不是pass了就拿到了offer，毕竟小菜鸟。</p><p>我会在文章末尾放上简历模板，不多，就几份。我比较喜欢极简的风格，我觉得这也是程序员大多数追求的一个方向，我会标识我用的模板。</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p>这一部分其实是很多人最有把握却写的最糟糕的部分，对不起对不起我说我自己，嘿嘿。</p><p>常见的错误：</p><ul><li><p>1、侧重点不在技术而在于情感感悟</p><p>   我们在写这一部分的时候，有部分同学没有把重点放在技术栈方面，而是说这个项目精神层次的东西，比如这次项目学会了沟通能力啊，以及抗压能力啊等等，这部分可以放在自我评价里面。</p></li><li><p>2、冗长流水账</p><p>   我们在记录自己的项目的时候，最好是按照模块划分好，不要第一句话还在介绍前端、第二句就到了后端，这样显的你的逻辑感很差，同时面试官也会很迷糊</p></li><li><p>3、没有突出自己的责任与角色</p><p>   最后一点就是再项目中没有介绍自己的角色，担任了什么任务，做了哪些工作，这一部分最好是能直接用数据量化，多用技术名词。很多的文字其实面试官可能也没有看的太过的详细，但是技术名词，只要搞技术的一眼就会被吸引到，这样他就留有映像，知道你会什么。</p></li></ul><p>其实还有很多的问题，我也参照了蛮多前辈写的，但是我觉得还是有点太繁杂了。因为简历大多数都是一页纸，项目经历少的可以详细展开写一下，项目多的其实根本无法将项目写的粒度达到多细，所以这就要求我们再极少的文字来描述清楚。</p><hr><p>我的项目有三个，因此我将项目分成了以下的三个部分：</p><p><strong>简介</strong>：名字+一句话描述项目   如果是项目负责人  就在后面加个括号（项目负责人），项目成员可加可不加。是就是，不是就不是，这个要如实回答。</p><p><strong>技术</strong>：如：WSN+Ipv6、gin、goechart、Geecache、redis、Android、Docker、k8s（这个部分其实你需要做的就是将你在项目中涉及到的技术写上来）但是写上来的，在项目中的使用情况一定要搞清楚，面试官会抓住这些然后深挖你是否是真的用到了，所以就算部分不是你做的，你写上去，就一定要把它原理搞懂，同时结合实际场景能给别人讲清楚，这是大大的加分。</p><p><strong>职责</strong>：这里你就分点写你的做了哪些工作，工作量少了就把工作再具体拆分。这里一定要结合一些技术名词描述：<strong>如利用gin框架搭建了Web界面进行可视化</strong>，这个就比你说搭建了一个可视化界面效果强烈的多。</p><hr><p><strong>如果项目的成果，包括最后的成果和发表的论文等等，这些也可以写出来。我这部分当时没有写，是选择在面试的时候说的。</strong></p><p><strong>如果你的项目经历较少，那么我觉得你还可以直接写出项目的亮点，和你解决掉问题；</strong></p><p><strong>下面这部分不用写在你的简历，但是你要做到心中有数，因为到时候面试的时候肯定会从嘴巴里说出来加分且有效。</strong></p><p>以上这个过程其实也是帮你自己梳理项目，你想当你面试的时候，当你给面试官介绍项目毫无逻辑感，当你面试完，面试官甚至不知从何问起，这样是灰常的尴尬。</p><p>其实如果你要是能站在一个更高的层次去描述一个项目，将技术与业务分层，再在项目中体现出软件开发的模式，设计的模式，这种绝对是大大的加分，但是这个很难嘛。在学校做的项目其实都是只要功能实现，并没有说需要复用和迭代，所以这部分的不知道才是很正常的–&gt;如果你不是计算机本专业的。</p><p>那么在面试的时候这部分你应该怎么给面试官介绍你的项目呢？</p><p>我觉得分为三个部分</p><h3 id="背景介绍："><a href="#背景介绍：" class="headerlink" title="背景介绍："></a>背景介绍：</h3><ul><li>1、为什么要做这个项目，需求在哪里，解决了什么问题？</li><li>2、和市面上现有的相比我这个项目存在哪些他们必具备的优势？</li></ul><h3 id="项目的宏观组成部分-功能技术："><a href="#项目的宏观组成部分-功能技术：" class="headerlink" title="项目的宏观组成部分+功能技术："></a>项目的宏观组成部分+功能技术：</h3><ul><li><p>由哪几个部分组成：</p><ul><li>假如你做了一个物联网系统，那么将是前端信号采集电路+数据信号传输网关+数据可视化展示这三个部分组成</li><li>假如你做了一个分布式缓存系统，那么将是根据LRU淘汰算法+并发缓存+分布式结点设置</li></ul></li><li><p>技术说明</p><ul><li>这个部分用到了哪些技术，做技术选型有哪些考虑，为什么选择这个技术。</li></ul></li></ul><p>这个项目的分模块我觉得可以从两个方向去入手。第一就是根据技术栈的边界线，模块的界限进行划分；第二个就是根据待解决的问题。<strong>第一个会更加容易，也更加清楚，我推荐第一个。</strong></p><h3 id="项目的成果"><a href="#项目的成果" class="headerlink" title="项目的成果"></a>项目的成果</h3><p>这个就是根据项目，解决了什么问题，优化了什么，提升了什么。</p><p><strong>关于学生党，其实最主要的就是在这里引出：</strong></p><p><strong>发表了什么文章</strong></p><p><strong>申请了什么专利</strong></p><p><strong>赢得了什么比赛</strong></p><p><strong>获得了什么表扬</strong></p><h3 id="项目的亮点"><a href="#项目的亮点" class="headerlink" title="项目的亮点"></a>项目的亮点</h3><p>创新的地方</p><p>解决了市面上现存的问题</p><p>和其他的产品进行比较</p><p>其实按照以上去阐述你的项目，你就已经站在较高的维度去看待一些问题，搞技术的如果还有一些产品的思维体现，那么将是非常有帮助的，也是很能体现你能力的。</p><h3 id="没项目能行吗？"><a href="#没项目能行吗？" class="headerlink" title="没项目能行吗？"></a>没项目能行吗？</h3><p>你想啥呢亲，不可以。</p><p>网上开源的太多了，你完全可以找一个项目跟着做。比如一个关于jin框架的类似于番茄TODOlist这样的，你完全可以改成关于健康打卡，疫情防控登记等等，这样的例子太多了。其实很多项目底层的技术都是相通的，你要做的就是搞懂底层的技术，再给它换个衣裳，这个项目不就是你的了。所以没项目都不是事儿哈，懒才是。（没说你没说你呢亲）</p><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><p>这部分其实有就是有，没有就是没有，实事求是是第一点。</p><p>其次我觉得这部分其实和项目经历类似，但是呢还是不怎么类似，其实像项目的话我们都是在学校做的项目，其实对于整个项目是有个宏观的了解，但是在实际工作中这是极其不一样的。你可能负责的方向和工作内容是很狭窄的，或者实习咱们压根就没有做个什么。</p><p>但是也要写出自己的含金量来，其实一般大厂技术岗是不会存在这些问题，小公司的话可能你就得写一点亮点来体现自己不是个sqlboy或者curdboy。</p><p>比如：<br>  搭建系统的框架啊，设计模式啊等</p><p>  我觉得就是大公司往技术深度说，小公司你就提升这个认识的宽度，对于你工作的部分进行一些拓展这样也可以丰富内容。</p><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>这部分，如果你有项目经历+实习经历已经写不下了，其实需不需要也不是很严重了。</p><p>但是如果你非要写，也记住不要骚，求你了，你那点墨水留着讲给你女朋友好吧，你是搞技术的记住关键点就在于你的技术能力+抗压能力+<br>学习能力+沟通能力。</p><p><strong>你所需要的就是从技术层面去描述自己，最好体现的就是你的乐观积极态度、对技术的热爱、和良好的沟通能力，其他的花里胡哨哥哥们，咱们低调点。</strong></p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>1、第一个可以根据不同的公司设计不同的颜色，比如华为是红色，京东也是，淘宝可能就是橙色，这个的前提是你的简历有那种带色的边框。</p><p>2、除非真的精通某项技术，我都建议写熟悉，我当时甚至唯唯诺诺两的两三个技术点还写的用过。</p><p>3、简历这张纸的任何位置都可能成为面试官的考点，所以务必写上去的都要做详尽的准备。</p><p>4、如果你在讲诉某个项目的时候，能拓展到简历上没有的，提高一下深度，那就非常的加分了。</p><p>5、简历其实现在都是现在填好了简历，其实现在每个公司都得在它自己的系统上填写一遍简历，所以其实自己制作简历的作用性在下滑，但是你做好了自己的简历，到时候直接往上copy不是更快，所以简历还是要好好做的。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1、简历几页可以？"><a href="#1、简历几页可以？" class="headerlink" title="1、简历几页可以？"></a>1、简历几页可以？</h3><p>不要超过两页</p><h3 id="2、需要写本科学校吗？"><a href="#2、需要写本科学校吗？" class="headerlink" title="2、需要写本科学校吗？"></a>2、需要写本科学校吗？</h3><p>建议写上，这问题是针对本科普通，考上名校研究生的，我觉得写上是一个态度，没必要遮遮掩掩的。毕竟是咱们母校，于情于理，写上没毛病。</p><h3 id="3、必须要贴照片吗？"><a href="#3、必须要贴照片吗？" class="headerlink" title="3、必须要贴照片吗？"></a>3、必须要贴照片吗？</h3><p>建议贴一张，然后这个照片建议你去某团搜一下证件照，然后花个几十块钱拍个证件照，他会给你一张修好的帅气美丽的电子照片，保存好，然后到时候就可以用了。</p><h3 id="4、不同的岗位和不同的公司可以用同一份简历吗？"><a href="#4、不同的岗位和不同的公司可以用同一份简历吗？" class="headerlink" title="4、不同的岗位和不同的公司可以用同一份简历吗？"></a>4、不同的岗位和不同的公司可以用同一份简历吗？</h3><p>这个其实你要根据招聘的要求来做一些定制化，别人要求的技术栈你肯定要写出来，你面试不同的岗位肯定需要不同的简历。</p><p>像我自己在面试嵌入式的时候我的简历项目和技能，我把嵌入式方面的技术着重描述列出来。</p><p>面试后端的时候，那我简历的项目就筛除了关于硬件电路设计，单片机那个部分，项目和技能就着重体现了关于后端的方面。</p><h3 id="5、发现邮件的注意事项？"><a href="#5、发现邮件的注意事项？" class="headerlink" title="5、发现邮件的注意事项？"></a>5、发现邮件的注意事项？</h3><p>邮件注意点：</p><ul><li>1、邮件地址要注意不要有什么不合法的字和符号，这样留下的影响不好，同时也会当做垃圾邮件直接删除了。</li><li>2、主题不要空着，也不要乱写，建议：简历投递：姓名+岗位+学校+电话号码。</li><li>3、简历最好直接放在附件，简历务必是PDF格式，这样避免因为不同的电脑打开出现排版错乱的现象。在邮件正文里，注明简历在附件，然后礼貌简单的祝福语即可。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简历这个玩意还是需要好好花点心思，很难说一天或者一周就全部投入进去做一份简历一劳永逸，很多时候就是做好了，然后自己再看一下，找朋友看一下，提出一些意见，再不断地修改，到最后完成一份很棒的简历。</p><p>简历模板链接：</p><p>1、<a href="https://cv.qiaobutang.com/tpl/la1">https://cv.qiaobutang.com/tpl/la1</a></p><p>2、免费好看的简历模板下载站（100%无套路） - <em>简历</em>设计师的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/361384432">https://zhuanlan.zhihu.com/p/361384432</a></p><p>3、推荐一个免费的良心网站（免费简历制作） - 老Y工作室的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/136807880">https://zhuanlan.zhihu.com/p/136807880</a></p><p>有什么后面再补充咯！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实认识不到简历重要性，以及对简历不走心的情况对于我们应届生来说实在是正常。&lt;/p&gt;
&lt;p&gt;不是因为懒，就是因为难，做一份好的简历实在是很不</summary>
      
    
    
    
    <category term="面试合集" scheme="https://riddlego.github.io/categories/%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/"/>
    
    
    <category term="简历" scheme="https://riddlego.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>wifi入门基础知识</title>
    <link href="https://riddlego.github.io/2021/10/10/wifi%E6%9C%80%E8%BF%91%E8%A6%81%E7%9C%8B%E7%9C%8B/"/>
    <id>https://riddlego.github.io/2021/10/10/wifi%E6%9C%80%E8%BF%91%E8%A6%81%E7%9C%8B%E7%9C%8B/</id>
    <published>2021-10-10T15:23:34.000Z</published>
    <updated>2021-10-10T15:34:55.665Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/leho666/article/details/89136542?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-9.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-9.no_search_link">WIFI协议详解</a></p><p><a href="https://blog.csdn.net/weixin_40204595/article/details/81408696?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">wifi中的几种组网协议、几个角色、几个概念介绍</a></p><p><a href="https://www.openwrt.pro/post-500.html">WIFI基本知识整理</a></p><p><a href="https://blog.csdn.net/yu__jia/article/details/77480257">AP和STA模式分别是什么意思</a></p><p><a href="https://blog.csdn.net/dagefeijiqumeiguo/article/details/47086267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">WiFi的STA和AP模式指什么？</a></p><p><a href="https://blog.csdn.net/lsalp/article/details/80592533">ESP8266WiFi模块AT指令入门指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/leho666/article/details/89136542?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~defaul</summary>
      
    
    
    
    <category term="wifi" scheme="https://riddlego.github.io/categories/wifi/"/>
    
    
    <category term="wifi" scheme="https://riddlego.github.io/tags/wifi/"/>
    
    <category term="物联网" scheme="https://riddlego.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    <category term="ESP8266" scheme="https://riddlego.github.io/tags/ESP8266/"/>
    
  </entry>
  
  <entry>
    <title>namespace</title>
    <link href="https://riddlego.github.io/2021/09/27/namespace/"/>
    <id>https://riddlego.github.io/2021/09/27/namespace/</id>
    <published>2021-09-27T08:21:29.000Z</published>
    <updated>2021-09-27T08:34:25.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="昂"><a href="#昂" class="headerlink" title="昂"></a>昂</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>最近在用c++，因为也算是个半路出家的，以前倒是玩过一段时间，当时看侯捷老师的课程，对c++迷恋到不行，后来因为项目和种种原因转了golang，这次又需要用到的时候，发现每次都有这个namespace，想知道这个玩意到底是什么用？</p><p><a href="https://mp.weixin.qq.com/s/bThkjaJBe3_81MIS3z8VhA">看了一篇来自前辈的文章,点击这里进入原文获得最佳体验</a></p><p>由于人类可用词汇实在太少（喜欢把函数名写成一堆无意义乱码的同学请无视掉这句话），而程序无穷尽，so 大家写程序里，重名不可避免，就像人多了，必然出现重名一个道理。</p><p>所以当足够多的人一起写程序，各自负责某一段时，出现重名简直就是100%事件。</p><p>如果不解决这一问题，编程就变成一个单机游戏了，顶多局网：几个人沟通一下，你用啥，我用啥，不许用我的哈~</p><p><strong>这事难不倒聪明的程序猿们。他们引入了命名空间（namespace）这个概念。</strong></p><p>这样每个人的程序都在自己的命名空间中生效。只要大家负责区段全局名字不同（如果相同，改一下，加个数字），那就不发生冲突，中间函数啊，库啊，类啊，爱写啥写啥。</p><p><strong>C++的标准程序库中，所有的标识符都被定义在一个名为std的namespace中。</strong></p><p>怎么知道标识符？输入后是黑色，不加粗，不需要申明就能干活的东西。</p><p>还是用Hello举个简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">cout&lt;&lt;&quot;Hello world!&quot; ;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很多同学学习C++的第一个程序。</p><p>这里的标识符，只有一个：cout。</p><p>（呃，我把代码那里设置了黑底，那就白色不加粗，嗯，就这么随性~）</p><p>所以，上面程序，也可以改写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">int main()&#123;</span><br><span class="line">cout&lt;&lt;&quot;Hello world!&quot; ;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>using std::cout 这句的意思是说，下面的cout是标准库里的。</p><p>当然，直接在cout 前面加上std::，也行，但多个cout就不划算咯。</p><p>这里只输出，挺划算，但多了就很不划算了。</p><p>而且对于初学者而言，区分“识别符”本身就有些劝退。</p><p>所以一般，我们都直接加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure><p>能一句话解决的事，决不写两句~~</p><p>以上为科普内容，初学者看到这里，跳到文末点个赞就好。</p><p>如果想了解一下namespace，可以继续往下看。(哈哈好的点赞继续看)</p><p>namespace 是指申明命名空间。</p><p>需要注意的是：</p><p>1、命名空间，必需在主函数开始前进行申明，放在主函数后面是没用的。</p><p>2、命名空间中的函数，可以在主函数前写，也可以在主函数后写，甚至可以在命名空间申明的时候直接写上，这个不影响。</p><p>3、任何时候，不能与全局命名空间，也就是与std矛盾！</p><p>所以通过namespace，我们可以实现多人合作完成程序，而且不需要因为“命名”这种小破事而开会讨论、投票表决……</p><h2 id="其实这个在docker中也有这个，linux的namespace，namespace就相当于国界线，在每个需要隔离的元素之间画上边界线，让环境独立安全的运行。"><a href="#其实这个在docker中也有这个，linux的namespace，namespace就相当于国界线，在每个需要隔离的元素之间画上边界线，让环境独立安全的运行。" class="headerlink" title="其实这个在docker中也有这个，linux的namespace，namespace就相当于国界线，在每个需要隔离的元素之间画上边界线，让环境独立安全的运行。"></a>其实这个在docker中也有这个，linux的namespace，namespace就相当于国界线，在每个需要隔离的元素之间画上边界线，让环境独立安全的运行。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;昂&quot;&gt;&lt;a href=&quot;#昂&quot; class=&quot;headerlink&quot; title=&quot;昂&quot;&gt;&lt;/a&gt;昂&lt;/h2&gt;&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h3&gt;&lt;p&gt;最近在用c++</summary>
      
    
    
    
    <category term="C++" scheme="https://riddlego.github.io/categories/C/"/>
    
    
    <category term="namespace" scheme="https://riddlego.github.io/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>Go单测从零到溜系列</title>
    <link href="https://riddlego.github.io/2021/09/27/Go%E5%8D%95%E6%B5%8B%E4%BB%8E%E9%9B%B6%E5%88%B0%E6%BA%9C%E7%B3%BB%E5%88%97/"/>
    <id>https://riddlego.github.io/2021/09/27/Go%E5%8D%95%E6%B5%8B%E4%BB%8E%E9%9B%B6%E5%88%B0%E6%BA%9C%E7%B3%BB%E5%88%97/</id>
    <published>2021-09-27T04:38:12.000Z</published>
    <updated>2021-09-27T08:20:07.385Z</updated>
    
    <content type="html"><![CDATA[<p>在学校简单的工作环境对于测试这个不是很重视，但是在开发工作中这个就很重要了。所以我们需要认真学习测试相关理论同时也需要具体的实践，golang关于测试真的配套服务还是真的不错。</p><p><a href="https://mp.weixin.qq.com/s/NGgn7E5AJX8hEVPtQ2DaDw">—0.单元测试基础</a></p><p>这篇文章讲了很多的关于单元测试的知识，同时还有对应例子，对于单元测试讲解的很详细。建议大家跟着前辈的目录依次阅读，一个递进的关系。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjAxMDc1Ng==&mid=2247484588&idx=1&sn=6e640ea9c988a3abe4d08adc6c1cd18d&chksm=fe270fc7c95086d1379edbe1a98120ca6278c0329ee527d4490c9738a4fe15ba1b29c8b7dd88&scene=178&cur_album_id=2046147170570911744#rd">—1.mock网络测试</a></p><p>关于网络测试，一般来说分为两种，要不我们用别人的-调用别人的API，要不就是别人调用我们的服务-我们作为服务提供方，但是在测试的时候去实现两方对接联调是个很麻烦的事情，我曾经做项目的时候有遇到这样的场景，一丁点小细节的处理就需要我带着笔记本和单片机往别人的实验室跑。前辈的这篇文章就讲述了在前面的两种场景下mock网络测试。<strong>使用httptest和gock工具进行网络测试</strong>。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjAxMDc1Ng==&mid=2247484604&idx=1&sn=9719e7b03bfba06fea7fa59dd301284e&chksm=fe270fd7c95086c18cbd4e627b6c09dbbf4753e4541338d183f43289edb96527d58418308351&scene=178&cur_album_id=2046147170570911744#rd">2.mock数据库测试</a></p><p>介绍了如何使用<strong>go-sqlmock</strong>和<strong>miniredis</strong>工具进行<strong>MySQL</strong>和<strong>Redis</strong>的mock测试。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjAxMDc1Ng==&mid=2247484644&idx=1&sn=8fa83c9a76cd316aef162d1eb955c4d3&chksm=fe270f8fc95086994c27d814c438f9a21a95989afa235813189de9ff49087da69b2d6b21d56a&scene=178&cur_album_id=2046147170570911744#rd">—3.接口测试</a></p><p>记得以前连接口定义都搞不清楚是什么东西，随着这个学习，每个部分在真正的软件流程或者是硬件流程都有着自己的角色，而我们就需要按照一定的流程进行规划实施，只有这样才能形成规模，规模才会产生效益。</p><p>前辈的这篇文章还介绍了打桩-gostub</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjAxMDc1Ng==&mid=2247484657&idx=1&sn=9739380f1bf7525eebf735f00cbf7e53&chksm=fe270f9ac950868c5c56bef80f95979bdb5b37e7fdcdd3b9b4e655025bbfb68e33643276b0c8&scene=178&cur_album_id=2046147170570911744#rd">—4.使用monkey打桩</a></p><p>在这一篇介绍一个更强大的打桩工具——monkey，它支持为任意函数及方法进行打桩。</p><p>打桩的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">软件测试中的打桩是指用一些代码（桩stub）代替目标代码，通常用来屏蔽或补齐业务逻辑中的关键代码方便进行单元测试。</span><br><span class="line"></span><br><span class="line">屏蔽：不想在单元测试用引入数据库连接等重资源</span><br><span class="line"></span><br><span class="line">补齐：依赖的上下游函数或方法还未实现</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjAxMDc1Ng==&mid=2247484678&idx=1&sn=b0ce7d2a4046961345b946f818223d96&chksm=fe270e6dc950877b5ab051c3c772c0bfa541ec017d690f64bedd6e9736ed27611d7586cabbe9&scene=178&cur_album_id=2046147170570911744#rd">—5.goconvey的使用</a></p><p>单元测试利器——goconvey</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学校简单的工作环境对于测试这个不是很重视，但是在开发工作中这个就很重要了。所以我们需要认真学习测试相关理论同时也需要具体的实践，golang关于测试真的配套服务还是真的不错。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/NGgn7</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    <category term="测试" scheme="https://riddlego.github.io/categories/golang-More/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://riddlego.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python调用C++代码步骤详解</title>
    <link href="https://riddlego.github.io/2021/09/26/python%E8%B0%83%E7%94%A8C++%E4%BB%A3%E7%A0%81%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://riddlego.github.io/2021/09/26/python%E8%B0%83%E7%94%A8C++%E4%BB%A3%E7%A0%81%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-26T06:39:25.000Z</published>
    <updated>2021-09-27T04:34:46.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本来是前面一段时间做了的一个东西，但是啊当时偷懒没有做记录，现在好了，又需要用的时候忘记了步骤是怎么开始的了，古人说的还是有道理，无论是温故而知新，还是好记性不如烂笔头。于是今天边边学习边记录一下。</p><p>python毫无疑问是数据处理的最佳利器，但是不得不说涉及到速度这个方面还是存在可以优化的空间，当然我做这个的出发点是为了复用以前C++编写的函数，这样可以避免重复去实现逻辑，意义不是很大。</p><p>当你想实现一个功能的时候，如果你不熟悉，那么我觉得不用着急去到具体实现好技术层面，我建议可以先想一想，查一查，舔一舔，要完成这样一件事情需要那些步骤，步骤之间的逻辑关系，然后再按照顺序每个模块去学习，当然这是我的愚见。</p><p>本文整个流程  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、将c++编译成动态链接dll文件</span><br><span class="line">2、python调用</span><br></pre></td></tr></table></figure><h2 id="C-动态库-静态库"><a href="#C-动态库-静态库" class="headerlink" title="C++ 动态库  静态库"></a>C++ 动态库  静态库</h2><h3 id="1、什么是动态库、静态库"><a href="#1、什么是动态库、静态库" class="headerlink" title="1、什么是动态库、静态库"></a>1、什么是动态库、静态库</h3><p>1、静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。（so-linux, dll-windos）</p><p>2、静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行；动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p><p>3、使用静态库的时候，多个不同的可执行程序会需要独自相同的库，但是动态库的话可以被多个程序公用一个</p><p>4、静态库和动态库最本质的区别就是：该库是否被编译进目标（程序）内部。</p><p><strong>5</strong>、<strong>静态库这类库在编译的时候会直接整合到目标程序中</strong>，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。</p><p><strong>6</strong>、<strong>与静态函数库被整个捕捉到程序中不同</strong>，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。</p><p>7、还有一个重要的就是动态库可以被第三方加载，这一点是很重要的。</p><h3 id="2、怎么生成动态库、静态库"><a href="#2、怎么生成动态库、静态库" class="headerlink" title="2、怎么生成动态库、静态库"></a>2、怎么生成动态库、静态库</h3><p>我在实习的时候，那个VS还是2005，看的我一脸懵逼，回来整了个vs2019。倒不是说有什么特别大的差异，当然差异还是肯定有的，但是不至于这么大，主要是界面感觉没有现在的这么平滑亲切，让人心生好感。<br>这里就是在解决方案 新建项目的时候选择新建静态库或者动态库就行，不过—动态库还有一一些是需要声明的宏定义，这部分是蛮重要的。</p><p>具体参照一下前辈的这个视频<br><a href="https://www.bilibili.com/video/BV1ch411C7Lb?spm_id_from=333.999.0.0">Visual Studio 2019-编写C++静态库</a><br><a href="https://www.bilibili.com/video/BV1k541177AS?spm_id_from=333.999.0.0">Visual Studio 2019-编写C++动态链接库</a></p><h3 id="3、动态库的隐式调用与显式调用"><a href="#3、动态库的隐式调用与显式调用" class="headerlink" title="3、动态库的隐式调用与显式调用"></a>3、动态库的隐式调用与显式调用</h3><p>搞清楚只有动态库才能给别人用，静态库直接调用的时候就整合到自己的身体了，所以不存在其他的调用这个说法，调用只能说是调用动态库。</p><p>动态库调用呢分为隐式调用和显示调用，</p><p>视频链接<br><a href="https://www.bilibili.com/video/BV1k541177AS?spm_id_from=333.999.0.0">Visual Studio 2019-编写C++动态链接库  后面一部分就是静态调用</a><br><a href="https://www.bilibili.com/video/BV16y4y1n7S6?spm_id_from=333.999.0.0">显式调用</a></p><p>blog链接<br><a href="https://blog.csdn.net/ezhchai/article/details/78784572?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.searchformbaiduhighlight">DLL调用（1）：C++静态调用DLL</a><br><a href="https://blog.csdn.net/ezhchai/article/details/78784815?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.searchformbaiduhighlight">DLL调用（2）：C++动态调用DLL</a></p><h2 id="python-调用dll文件"><a href="#python-调用dll文件" class="headerlink" title="python 调用dll文件"></a>python 调用dll文件</h2><p>大概分为两个步骤</p><h3 id="1、提前准备"><a href="#1、提前准备" class="headerlink" title="1、提前准备"></a>1、提前准备</h3><p>导入包—ctypes，这个包就相当于一个中间的briage进行转换、适配。<br>因为python是动态的语言，而C++是动态的，当函数进行调用时候肯定这个对应的参数数据类型就需要进行转换。</p><h3 id="2、函数实现"><a href="#2、函数实现" class="headerlink" title="2、函数实现"></a>2、函数实现</h3><p>函数输入参数与返回参数</p><p><a href="https://www.bilibili.com/video/BV1mX4y1577J?spm_id_from=333.999.0.0">详细内容看这个前辈的视频哦-第三方应用程序调用DLL-Python调用C++动态库</a></p><p>知道你想偷懒，小懒猪，代码贴在这里了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import ctypes, ctypes.util</span><br><span class="line"></span><br><span class="line">def find_dll(dll_name):</span><br><span class="line">    return ctypes.util.find_library(dll_name) #查找dll</span><br><span class="line"></span><br><span class="line">def load_dll(dll_path):</span><br><span class="line">    try:</span><br><span class="line">        vc_dll &#x3D; ctypes.CDLL(dll_path) #加载动态库，若失败则抛出异常</span><br><span class="line">        print(&quot;第一步，加载动态库成功&quot;)</span><br><span class="line"></span><br><span class="line">        #</span><br><span class="line">        vc_func &#x3D; vc_dll.convert_array #获取动态库函数</span><br><span class="line">        #C++ &lt;--&gt; ctypes &lt;--&gt;python 数据类型的适配</span><br><span class="line">        #输入参数  int convert_array(int* data, int len)</span><br><span class="line">        vc_func.argtypes &#x3D; [ctypes.POINTER(ctypes.c_int),ctypes.c_int]</span><br><span class="line"></span><br><span class="line">        #返回函数  return nTotal;</span><br><span class="line">        vc_func.restype &#x3D; ctypes.c_int #函数返回值类型适配</span><br><span class="line"></span><br><span class="line">        my_list &#x3D; [3,1,6,8,5]</span><br><span class="line">        array_len &#x3D; len(my_list)</span><br><span class="line"></span><br><span class="line">        ##把列表转换成C++动态库函数所需要的参数数组，my_arrat 不是数组，但是可以当做数组去理解</span><br><span class="line">        my_array &#x3D; (ctypes.c_int * array_len)(*my_list)</span><br><span class="line"></span><br><span class="line">        ##此时的函数的输入参数已经在上面进行了转换规则设置了</span><br><span class="line">        ret &#x3D; vc_func(my_array,array_len)</span><br><span class="line">        print(&quot;函数返回值: &quot;,ret)</span><br><span class="line"></span><br><span class="line">        ## 确认修改了数组的本身</span><br><span class="line">        my_array_list &#x3D; []</span><br><span class="line">    </span><br><span class="line">        for i in range(my_array._length_):</span><br><span class="line">            my_array_list.append(my_array[i])</span><br><span class="line"></span><br><span class="line">        print(&#39;数组新值：&#39;, my_array_list) #输出到屏幕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    except OSError as e:</span><br><span class="line">        print(e,&quot;加载dll失败&quot;)</span><br><span class="line"></span><br><span class="line">###要注意dll生成的计算机是多少位  属性  配置管理器</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    dll_path &#x3D; find_dll(&quot;.&#x2F;DemoDll.dll&quot;)</span><br><span class="line">    if dll_path:</span><br><span class="line">        load_dll(dll_path)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这本来是前面一段时间做了的一个东西，但是啊当时偷懒没有做记录，现在好了，又需要用的时候忘记了步骤是怎么开始的了，古人说的还是有道理，无论是温</summary>
      
    
    
    
    <category term="python" scheme="https://riddlego.github.io/categories/python/"/>
    
    
    <category term="动态库" scheme="https://riddlego.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    <category term="静态库" scheme="https://riddlego.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go：说说fanIn和fanOut模式</title>
    <link href="https://riddlego.github.io/2021/09/11/Go%EF%BC%9A%E8%AF%B4%E8%AF%B4fanIn%E5%92%8CfanOut%E6%A8%A1%E5%BC%8F/"/>
    <id>https://riddlego.github.io/2021/09/11/Go%EF%BC%9A%E8%AF%B4%E8%AF%B4fanIn%E5%92%8CfanOut%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-11T07:41:55.000Z</published>
    <updated>2021-09-11T08:13:44.965Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/RnqHz6Oubi6eHsopPs0xkQ">原文链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/RnqHz6Oubi6eHsopPs0xkQ&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    <category term="并发" scheme="https://riddlego.github.io/categories/golang-More/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Go-Module教程第5部分：Vendoring</title>
    <link href="https://riddlego.github.io/2021/09/11/Go-Module%E6%95%99%E7%A8%8B%E7%AC%AC5%E9%83%A8%E5%88%86%EF%BC%9AVendoring/"/>
    <id>https://riddlego.github.io/2021/09/11/Go-Module%E6%95%99%E7%A8%8B%E7%AC%AC5%E9%83%A8%E5%88%86%EF%BC%9AVendoring/</id>
    <published>2021-09-11T07:41:25.000Z</published>
    <updated>2021-09-11T08:12:13.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/tRdb44lOSETC0EaTHBG4sg">原文链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/tRdb44lOSETC0EaTHBG4sg&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang-more" scheme="https://riddlego.github.io/categories/golang-more/"/>
    
    <category term="Go-Modules" scheme="https://riddlego.github.io/categories/golang-more/Go-Modules/"/>
    
    
  </entry>
  
  <entry>
    <title>Go实现ringbuffer</title>
    <link href="https://riddlego.github.io/2021/09/11/Go%E5%AE%9E%E7%8E%B0ringbuffer/"/>
    <id>https://riddlego.github.io/2021/09/11/Go%E5%AE%9E%E7%8E%B0ringbuffer/</id>
    <published>2021-09-11T07:40:58.000Z</published>
    <updated>2021-09-11T08:10:45.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-第三方库源码分析：juju-ratelimit"><a href="#Go-第三方库源码分析：juju-ratelimit" class="headerlink" title="Go 第三方库源码分析：juju/ratelimit"></a>Go 第三方库源码分析：juju/ratelimit</h2><p><a href="https://github.com/juju/ratelimit">https://github.com/juju/ratelimit</a> 是一个基于令牌桶算法的限流器：令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放。漏桶算法和令牌桶算法的主要区别在于，”漏桶算法”能够强行限制数据的传输速率(或请求频率)，而”令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。</p><p><a href="https://mp.weixin.qq.com/s/p8Kis2ZNcqcYmtLWrQpcMA">原文链接点击这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go-第三方库源码分析：juju-ratelimit&quot;&gt;&lt;a href=&quot;#Go-第三方库源码分析：juju-ratelimit&quot; class=&quot;headerlink&quot; title=&quot;Go 第三方库源码分析：juju/ratelimit&quot;&gt;&lt;/a&gt;Go 第三方库源</summary>
      
    
    
    
    <category term="golang包包" scheme="https://riddlego.github.io/categories/golang%E5%8C%85%E5%8C%85/"/>
    
    
    <category term="令牌桶" scheme="https://riddlego.github.io/tags/%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>Go第三方库源码分析：juju/ratelimit</title>
    <link href="https://riddlego.github.io/2021/09/11/Go%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Ajuju-ratelimit/"/>
    <id>https://riddlego.github.io/2021/09/11/Go%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Ajuju-ratelimit/</id>
    <published>2021-09-11T07:40:34.000Z</published>
    <updated>2021-09-11T07:40:34.912Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>深度探索Go语言：同步</title>
    <link href="https://riddlego.github.io/2021/09/11/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2Go%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%90%8C%E6%AD%A5/"/>
    <id>https://riddlego.github.io/2021/09/11/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2Go%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%90%8C%E6%AD%A5/</id>
    <published>2021-09-11T07:40:00.000Z</published>
    <updated>2021-09-11T07:54:25.797Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fkKmQ05idbTtBWcGATrWfQ">深度探索Go语言：同步（一）</a></p><p><a href="https://mp.weixin.qq.com/s/i7ruvOfPPXTtlh6utfMv0A">深度探索Go语言：同步（二）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fkKmQ05idbTtBWcGATrWfQ&quot;&gt;深度探索Go语言：同步（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/i7ruvOfPPXTtlh6</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    
  </entry>
  
  <entry>
    <title>如何避免出现SQL注入漏洞</title>
    <link href="https://riddlego.github.io/2021/09/11/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://riddlego.github.io/2021/09/11/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-09-11T07:39:37.000Z</published>
    <updated>2021-09-11T07:51:37.078Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/KKx3hFZ_X6RaK0qrR2jRjw">原文链接点击进入</a></p><h1 id="如何避免出现-SQL-注入漏洞"><a href="#如何避免出现-SQL-注入漏洞" class="headerlink" title="如何避免出现 SQL 注入漏洞"></a>如何避免出现 SQL 注入漏洞</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本文将针对开发过程中依旧经常出现的SQL编码缺陷，讲解其背后原理及形成原因。并以几个常见漏洞存在形式，提醒技术同学注意相关问题。最后会根据原理，提供解决或缓解方案。</p><h2 id="二-SQL-注入漏洞的原理、形成原因"><a href="#二-SQL-注入漏洞的原理、形成原因" class="headerlink" title="二 SQL 注入漏洞的原理、形成原因"></a>二 SQL 注入漏洞的原理、形成原因</h2><p>SQL注入漏洞，根本上讲，是由于错把外部输入当作SQL代码去执行。目前最佳的解决方案就是预编译的方式。</p><p>SQL语句在执行过程中，需要经过以下三大基本步骤：</p><ul><li>1.代码语义分析</li></ul><ul><li>2.制定执行计划</li></ul><ul><li>3.获得返回结果</li></ul><p>而一个SQL语句是由代码和数据两部分，如：</p><p>SELECT id, name, phone FROM userTable WHERE name = ‘xiaoming’;</p><p>SELECT id, name, phone FROM userTable WHERE name = 是代码，’xiaoming’是数据。</p><p>而预编译，以Mybatis为例，就是预先分析带有占位符的语义：</p><p>如SELECT id, name, phone FROM userTable WHERE id = #{name};</p><p>然后再将数据’xiaoming’，传入到占位符。这样一来，错开来代码语义分析阶段，也就不会被误认为是代码的一部分了。</p><p>在最早期，开发者显式使用JDBC来自己创建Connection，执行SQL语句。这种情况下，如果将外部可控数据拼接到SQL语句，且没有做充分过滤的话，就会产生漏洞。这种情况在正常的业务开发过程中已经很少了，按照公司规定，无特殊情况下，必须使用ORM框架来执行SQL。</p><p>但目前部分项目中，仍会使用JDBC来编写一些工具脚本，如DataMerge.java 、DatabaseClean.java，借用JDBC的灵活性，通过这些脚本来执行数据库批量操作。</p><p>此类代码不应该出现在线上版本中，以免因各种情况，被外部调用。</p><h2 id="三-直接使用-Mybatis"><a href="#三-直接使用-Mybatis" class="headerlink" title="三 直接使用 Mybatis"></a>三 直接使用 Mybatis</h2><h3 id="1-易错点"><a href="#1-易错点" class="headerlink" title="1 易错点"></a>1 易错点</h3><p>目前大部分的平台代码是基于Mybatis来处理持久层和数据库之间的交互的，Mybatis传入数据有两种占位符{}和#{}。{}和#{}。{}可以理解为语义分析前的字符串拼接，讲传入的参数，原封不动地传入。</p><p>比如说</p><p>SELECT id, name, phone FROM userTable WHERE name = ‘${name}’;<br>传入name=xiaoming后，相当于<br>SELECT id, name, phone FROM userTable WHERE name = ‘xiaoming’;</p><p>实际应用中</p><p>SELECT id, name, phone FROM userTable WHERE ${col} = ‘xiaoming’;<br>传入col = “name”，相当于<br>SELECT id, name, phone FROM userTable WHERE name = ‘xiaoming’;</p><p>就像预编译原理介绍里讲的一样，使用#{} 占位符就不存在注入问题了。但有些业务场景是不可以直接使用#{}的。</p><p>比如order by语法中</p><p>如果编写SELECT id, name, phone FROM userTable ORDER BY #{}; ，执行时是会报错的。因为order by后的内容，是一个列名，属于代码语义的一部分。如果在语义分析部分没有确定下来，就相当于执行SELECT id, name, phone FROM userTable ORDER BY 。肯定会有语法错误。</p><p>再比如like场景下</p><p>SELECT id, name, phone FROM userTable WHERE name like ‘%#{name}%’;<br>#{}不会被解析，从而导致报错。</p><p>in 语法和 between语法都是如此，那么如何解决这类问题呢？</p><h3 id="2-正确写法"><a href="#2-正确写法" class="headerlink" title="2 正确写法"></a>2 正确写法</h3><p>order by（group by）语句中使用${}</p><p>1.使用条件判断</p><p>2.使用全局过滤机制，限制order by后的变量内容只能是数字、字母、下划线。</p><p>如使用正则过滤：</p><p>这里需要注意，过滤需要使用白名单，不能使用黑名单，黑名单无法解决注入问题。</p><p>LIKE 语句</p><p>由于需要like中的关键词需要包裹在两个%符号中，因此可以使用CONCAT函数进行拼接。</p><p>注意不要用 CONCAT(‘%’,’${stuName}’,’%’) ，这样仍然存在漏洞。也就是说，使用$符号是不对的，使用#符号才安全。</p><p>IN 语句</p><p>类似于like语句，直接使用#{}会报错，常见的错误写法为：</p><h2 id="四-Mybatis-generator-使用安全"><a href="#四-Mybatis-generator-使用安全" class="headerlink" title="四 Mybatis-generator 使用安全"></a>四 Mybatis-generator 使用安全</h2><p>繁重的CRUD代码压力下，开发者慢慢开始通过Mybatis-generator、idea-mybatis-generator插件、通用Mapper、Mybatis-generator-plus来自动生成Mapper、POJO、Dao等文件。</p><p>这些工具可以自动的生成CRUD所需要的文件，但如果使用不当，就会自动产生SQL注入漏洞。我们以最常用的org.mybatis.generator为例，来讲解可能会出现的问题。</p><h3 id="1-动态语句支持"><a href="#1-动态语句支持" class="headerlink" title="1 动态语句支持"></a>1 动态语句支持</h3><p>Mybatis-generator提供来一些函数，帮助用户把SQL的各个条件连接起来，比如多个参数的like语法，多个参数的比较语法。为了保证使用的简洁性，需要使用将一些语义代码拼接到SQL语句中。而如果开发者使用不当，将外部输入也传入了{}占位符。就会产生漏洞。</p><h3 id="2-targetRuntime-参数配置"><a href="#2-targetRuntime-参数配置" class="headerlink" title="2 targetRuntime 参数配置"></a>2 targetRuntime 参数配置</h3><p>在配置generator时，配置文件generator-rds.xml中有一个targetRuntime属性，默认为MyBatis3。在这种情况下，会启动Mybatis的动态语句支持，启动enableSelectByExample、enableDeleteByExample、enableCountByExample 以及 enableUpdateByExample功能。</p><p>以enableSelectByExample为例，会在xml映射文件中代入以下动态模块：</p><h2 id="五-其它-ORM-框架"><a href="#五-其它-ORM-框架" class="headerlink" title="五 其它 ORM 框架"></a>五 其它 ORM 框架</h2><h3 id="1-Hibernate"><a href="#1-Hibernate" class="headerlink" title="1 Hibernate"></a>1 Hibernate</h3><p>ORM全称为对象关系映射(Object Relational Mapping)，简单地说，就是将数据库中的表映射为Java对象, 这种只有属性，没有业务逻辑的对象也叫做POJO（Plain Ordinary Java Object）对象。</p><p>Hibernate是第一个被广泛使用的ORM框架，它通过XML管理数据库连接，提供全表映射模型，封装程度很高。在配置映射文件和数据库链接文件后，Hibernate就可以通过Session对象进行数据库操作，开发者无需接触SQL语句，只需要写HQL语句即可。</p><p>Hibernate经常与Struts、Spring搭配使用，也就是Java世界的经典SSH框架。</p><p>HQL相较于SQL，多了很多语法限制：</p><p>1.不能查询未做映射的表，只有当模型之间的关系明确后，才可以使用UNION语法。</p><p>2.表名，列名大小写敏感。</p><p>3.没有*、#、– 。</p><p>4.没有延时函数。</p><p>所以HQL注入利用要比SQL注入苦难得多。从代码审计的角度和普通SQL注入是一致的：</p><p>拼接会导致注入漏洞：</p><p>图片</p><p>可以使用占位符和具名参数来防止SQL语句，其本质都是预编译。</p><p>图片</p><p>图片</p><p>Hibernate在使用过程中有很多不足：</p><p>1.全表映射不灵活，更新时需要发送所有字段，影响程序运行效率。</p><p>2.对复杂查询的支持很差。</p><p>3.对存储过程的支持很差。</p><p>4.HQL性能较差，无法根据SQL进行优化。</p><p>在审计Hibernate相关注入时，可以通过全局搜索createQuery来快速定位SQL操作的位置。</p><h3 id="2-JPA"><a href="#2-JPA" class="headerlink" title="2 JPA"></a>2 JPA</h3><p>JPA全称为Java Persistence API，是Java EE提供的一种数据持久化的规范，允许开发者通过XML或注解的方式，将某个对象，持久化到数据库中。</p><p>主要包括三方面内容：</p><p>1.ORM映射元数据，通过XML或注解，描述对象和数据表之间的对应关系。框架便可以自动将对象中的数据保存到数据库中。</p><p>常见的注解有：@Entity、@Table、@Column、@Transient</p><p>2.数据操作API，内置接口，方便对某个数据表执行CRUD操作，节省开发者编写SQL的时间。</p><p>常见的方法有：entityManager.merge(T t);</p><p>3.JPQL, 提供一种面向对象而不是面向数据库的查询语言，将程序和数据库、SQL解耦合。</p><p>JPA是一套规范，Hibernate实现了这一JPA规范。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>经过上面的介绍，尤其是围绕Mybatis易错点的讨论，我们可以得到以下结论：</p><p>1.持久层组件种类繁多。</p><p>2.开发者对工具使用的错误理解，是漏洞出现的主要原因。</p><p>3.由于自动生成插件的动态特性，自动化发现SQL漏洞不能简单地使用${}来寻找。必须要根据全局的持久层组件特性，来做详细的匹配规则。</p><p>参考链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;190170#h2-3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;alka1d&#x2F;p&#x2F;11582993.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KKx3hFZ_X6RaK0qrR2jRjw&quot;&gt;原文链接点击进入&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;如何避免出现-SQL-注入漏洞&quot;&gt;&lt;a href=&quot;#如何避免出现-SQL-注入漏洞&quot; class=&quot;h</summary>
      
    
    
    
    <category term="数据库" scheme="https://riddlego.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="https://riddlego.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>huawei.md</title>
    <link href="https://riddlego.github.io/2021/09/09/huawei-md/"/>
    <id>https://riddlego.github.io/2021/09/09/huawei-md/</id>
    <published>2021-09-09T15:34:14.000Z</published>
    <updated>2021-09-09T16:30:35.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>家庭宽带100兆指的什么？<br><a href="http://m.jia.com/zixun/jxwd/909913.html">家庭宽带100兆</a></p><p>硬盘50G指的是什么？<br>1TB=1024GB,1GB=1024MB,1MB=1024KB,1KB=1024B,1B=8b ，B（Byte的缩写）代表字节，b（bit）代表二进制位,50GB=50X1024=51200MB</p><p><a href="https://www.jb51.net/diannaojichu/286430.html">1Mbps 是什么？</a></p><p><a href="https://blog.csdn.net/weixin_35686326/article/details/118986260?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_aggregation-1-118986260.pc_agg_rank_aggregation&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D&spm=1000.2123.3001.4430">通信中的k是指的什么？</a></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>VLAN协议<br><a href="https://blog.csdn.net/phunxm/article/details/9498829?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">VLAN原理详解</a></p><p>OSI七层模型<br><a href="https://blog.csdn.net/taotongning/article/details/81352985?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.no_search_link">OSI七层协议大白话解读</a></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><a href="https://blog.csdn.net/daocaoren1543169565/article/details/80535949?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.no_search_link">TCP报文详解</a><br>TCP/IP报文格式</p><p>在192.168.0.2计算机上ping 192.168.0.1 –l 10,那么在192.168.0.1这台计算机上收到的IP报文长度?</p><p>ping -l 10，是说明你ping包的data内容为10个bytes。<br>加上ICMP报文头，IP报文头，DLC 2层头，CRC字节，不到64 byte。<br>所以会填充字节，最终满足以太网最小报文64Bytes。<br>所以以太网报文长度应该是64bytes（含CRC校验字节）。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>对称加密和非对称加密区别与原理<br><a href="https://blog.csdn.net/zam183/article/details/85270472">对称加密和非对称加密（一）初步理解</a></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>VLAN协议<br><a href="https://blog.csdn.net/phunxm/article/details/9498829?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">VLAN原理详解</a></p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>网络拓扑连接方式<br><a href="https://blog.csdn.net/wdirdo/article/details/99705605">网络拓扑结构</a><br>线路拓扑</p><p>MPLS网络<br><a href="https://cshihong.blog.csdn.net/article/details/80503475?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.no_search_link">MPLS技术原理</a></p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>wifi 2.4G 20Mhz频宽  2*2MIMO  理论上能获得的带宽<br><a href="https://blog.csdn.net/jyqxerxes/article/details/78994699">LTE学习笔记六：MIMO多天线技术</a></p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>TCP/IP协议<br><a href="https://blog.csdn.net/bjweimengshu/article/details/79214572">什么是TCP/IP协议？</a></p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>无线通信  波长越短  是不是电磁波<br><a href="https://zhuanlan.zhihu.com/p/72928872">无线通信</a></p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>Windos 常用的关于网络的命令设置<br><a href="https://blog.csdn.net/xieyunc/article/details/83785390">Windows常用网络操作命令</a></p><p>Linux 常用的关于网络的命令设置<br><a href="https://blog.csdn.net/qq_34021920/article/details/80543315?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">网络—–Linux下常见网络命令总结</a></p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>关于网络速度的单位  Mbps</p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p><a href="https://zhidao.baidu.com/question/319924851.html">OTU1</a></p><p><a href="http://www.021pbx.com.cn/126.html">E1</a><br><a href="https://baike.baidu.com/item/e1/3904047?fr=aladdin">E1</a></p><p><a href="https://wenda.so.com/q/1594360630211288">STM4 STM64</a></p><p>STM64</p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p>以太网链路端口均为电口<br><a href="https://blog.csdn.net/u013076893/article/details/106455429">以太网端口协商总结</a><br>自协商</p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>LDPC码和Polar码 – 5G<br><a href="https://blog.csdn.net/sinat_31856687/article/details/103521933">LDPC码浅谈</a></p><p><a href="https://cloud.tencent.com/developer/ask/115467">Polar码 和LDPC码的区别？</a></p><p>eMBB业务</p><p><a href="https://www.eefocus.com/communication/414011">5G时代定义了三大场景：eMBB、URLLC、mMTC</a></p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>网络设备的作用  —OSI七层模型</p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p><a href="https://blog.csdn.net/milkbusy/article/details/86693616">5G的PCI</a></p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>TCP  拥塞控制  。。。等等几个机制<br><a href="https://mp.weixin.qq.com/s/BK2H7JQIo6zOrXYg9RcbeA">一文搞定 UDP 和 TCP 高频面试题！</a></p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p><a href="https://zhuanlan.zhihu.com/p/41341540">OSPF</a> </p><p><a href="OSPF%E5%8D%8F%E8%AE%AELSA%E8%B7%AF%E7%94%B1">路由的LSA</a></p><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p>确定复用<br><a href="https://blog.csdn.net/weixin_40228289/article/details/82721366">通信技术之复用与解复用</a></p><p><a href="https://baike.baidu.com/item/PTN/2836008?fr=aladdin">PTN</a></p><p><a href="https://baike.baidu.com/item/ATM%E7%BD%91%E7%BB%9C/1174087?fr=aladdin">ATM</a>  </p><p><a href="https://zhidao.baidu.com/question/584280136.html">SDH、WDM、ATM、IP-RAN、PTN、MSTP、MSTP+的差别</a></p><p><a href="https://www.zhihu.com/question/34457349">WDM</a></p><p><a href="https://www.zhihu.com/question/340708676/answer/789850020">以太网</a></p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p>保证网络安全  内部网络与外部网络之间的安全设置<br><a href="https://blog.csdn.net/u014209205/article/details/83070305">防火墙技术原理</a></p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>对于帧长为64字节的以太网报文，1000Mbps转换成pps</p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p>关于家庭上网</p><p>FTTx</p><p>同轴电缆应用场景</p><p>wifi</p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>MIMO系统</p><h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p>白盒测试与黑盒测试</p><h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>VPN 协议</p><p>VPN隧道协议</p><h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><p>NAT  网络地址转换</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>Ipv6 协议<br>结构  特点 功能</p><h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><p>MPLS</p><h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>windos网络相关命令</p><h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>通信原理</p><p>基带信号</p><p>传输带宽</p><p>通过频率</p><h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><p>3GPP协议  无线接入协议</p><p>RLC</p><p>NAS</p><p>PDCP</p><p>PHY</p><h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><p>主流的通信技术和业务</p><h2 id="33"><a href="#33" class="headerlink" title="33"></a>33</h2><p>光纤通信</p><p>通信原理 </p><p>通信的损耗</p><p>分类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;家庭宽带100兆指的什么？&lt;br&gt;&lt;a href=&quot;http://m.jia.com/zixun/jxwd/909913.html&quot;&gt;家庭宽带100</summary>
      
    
    
    
    <category term="面试合集" scheme="https://riddlego.github.io/categories/%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>我终于识破了这个Go编译器把戏</title>
    <link href="https://riddlego.github.io/2021/09/06/%E6%88%91%E7%BB%88%E4%BA%8E%E8%AF%86%E7%A0%B4%E4%BA%86%E8%BF%99%E4%B8%AAGo%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%8A%E6%88%8F/"/>
    <id>https://riddlego.github.io/2021/09/06/%E6%88%91%E7%BB%88%E4%BA%8E%E8%AF%86%E7%A0%B4%E4%BA%86%E8%BF%99%E4%B8%AAGo%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%8A%E6%88%8F/</id>
    <published>2021-09-06T15:17:22.000Z</published>
    <updated>2021-09-06T15:18:50.673Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/KfsMJN36f0IpxabAwbL6iA">我终于识破了这个 Go 编译器把戏</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KfsMJN36f0IpxabAwbL6iA&quot;&gt;我终于识破了这个 Go 编译器把戏&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    <category term="底层" scheme="https://riddlego.github.io/categories/golang-More/%E5%BA%95%E5%B1%82/"/>
    
    
    <category term="编译器" scheme="https://riddlego.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发控制模式：orDone的两种实现</title>
    <link href="https://riddlego.github.io/2021/09/06/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%9AorDone%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://riddlego.github.io/2021/09/06/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%9AorDone%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-06T15:10:37.000Z</published>
    <updated>2021-09-06T15:15:46.319Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/F5H0C--diuuPTcrZhSC0cA">点击原文链接获得更好阅读排版</a></p><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ul><li><p>方式一 递归</p></li><li><p>方式二 利用反射</p></li><li><p>性能差异</p></li></ul><p>orDone 是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。</p><p>今天我们来看下两种不同的实现方式：</p><h2 id="方式一-递归"><a href="#方式一-递归" class="headerlink" title="方式一 递归"></a>方式一 递归</h2><p>利用二分法递归， 将所有待监听信号的chan都select起来，</p><p>当有第一个chan返回时，close orDone 来通知读取方已有第一个任务返回</p><p>代码如下比较直观：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入多个并发chan，返回是否结束的 orDone chan</span><br><span class="line">func Or(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> &#x2F;&#x2F; 只有零个或者1个chan</span><br><span class="line"> switch len(channels) &#123;</span><br><span class="line"> case 0:</span><br><span class="line">        &#x2F;&#x2F; 返回nil， 让读取阻塞等待</span><br><span class="line">  return nil</span><br><span class="line"> case 1:</span><br><span class="line">  return channels[0]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回时利用close做结束信号的广播</span><br><span class="line">  defer close(orDone)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 利用select监听第一个chan的返回</span><br><span class="line">  switch len(channels) &#123;</span><br><span class="line">  case 2: &#x2F;&#x2F; 直接select</span><br><span class="line">   select &#123;</span><br><span class="line">   case &lt;-channels[0]:</span><br><span class="line">   case &lt;-channels[1]:</span><br><span class="line">   &#125;</span><br><span class="line">  default: &#x2F;&#x2F; 二分法递归处理</span><br><span class="line">   m :&#x3D; len(channels) &#x2F; 2</span><br><span class="line">   select &#123;</span><br><span class="line">   case &lt;-Or(channels[:m]...):</span><br><span class="line">   case &lt;-Or(channels[m:]...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> return orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方式二-利用反射"><a href="#方式二-利用反射" class="headerlink" title="方式二 利用反射"></a>方式二 利用反射</h2><p>这里要用到reflect.SelectCase, 他可以描述一种select的case, 来指明其接受的是chan的读取或发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SelectCase struct &#123;</span><br><span class="line"> Dir  SelectDir &#x2F;&#x2F; direction of case</span><br><span class="line"> Chan Value     &#x2F;&#x2F; channel to use (for send or receive)</span><br><span class="line"> Send Value     &#x2F;&#x2F; value to send (for send)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以之间遍历，不用递归来实现有限的select case构造</p><p>最后用reflect.Select(cases)监听信号就可以了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func OrInReflect(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> &#x2F;&#x2F; 只有0个或者1个</span><br><span class="line"> switch len(channels) &#123;</span><br><span class="line"> case 0:</span><br><span class="line">  return nil</span><br><span class="line"> case 1:</span><br><span class="line">  return channels[0]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer close(orDone)</span><br><span class="line">  &#x2F;&#x2F; 利用反射构建SelectCase，这里是读取</span><br><span class="line">  var cases []reflect.SelectCase</span><br><span class="line">  for _, c :&#x3D; range channels &#123;</span><br><span class="line">   cases &#x3D; append(cases, reflect.SelectCase&#123;</span><br><span class="line">    Dir:  reflect.SelectRecv,</span><br><span class="line">    Chan: reflect.ValueOf(c),</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 随机选择一个可用的case</span><br><span class="line">  reflect.Select(cases)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> return orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>这两种都可以支持大量chan的信号监听，那性能差异大么</p><p>虽说递归开销肯定不小，反射也不一定效率高，拿个压测来试试吧</p><p>先构造一下大量并发chan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func repeat(</span><br><span class="line"> done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 外部传入done控制是否结束</span><br><span class="line"> values ...interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line"> valueStream :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> go func() &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回时释放</span><br><span class="line">  defer close(valueStream)</span><br><span class="line">  for &#123;</span><br><span class="line">   for _, v :&#x3D; range values &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-done:</span><br><span class="line">     return</span><br><span class="line">    case valueStream &lt;- v:</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> return valueStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkOr(b *testing.B) &#123;</span><br><span class="line"> done :&#x3D; make(chan interface&#123;&#125;)</span><br><span class="line"> defer close(done)</span><br><span class="line"> num :&#x3D; 100</span><br><span class="line"> streams :&#x3D; make([]&lt;-chan interface&#123;&#125;, num)</span><br><span class="line"> for i :&#x3D; range streams &#123;</span><br><span class="line">  streams[i] &#x3D; repeat(done, []int&#123;1, 2, 3&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> b.ResetTimer()</span><br><span class="line"> for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  &lt;-Or(streams...)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkOrInReflect(b *testing.B) &#123;</span><br><span class="line"> &#x2F;&#x2F; 代码类似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了下结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;NewbMiao&#x2F;Dig101-Go&#x2F;concurrency&#x2F;channel&#x2F;schedule&#x2F;orDone</span><br><span class="line">BenchmarkOr-12                 31815      38136 ns&#x2F;op     9551 B&#x2F;op       99 allocs&#x2F;op</span><br><span class="line">BenchmarkOrInReflect-12        55797      21755 ns&#x2F;op    25232 B&#x2F;op      112 allocs&#x2F;op</span><br></pre></td></tr></table></figure><p>可以看出，大量并发chan场景下， 反射使用内存更多些，但速度更快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/F5H0C--diuuPTcrZhSC0cA&quot;&gt;点击原文链接获得更好阅读排版&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    <category term="并发" scheme="https://riddlego.github.io/categories/golang-More/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Go-Module教程第4部分：镜像、校验和以及Athens</title>
    <link href="https://riddlego.github.io/2021/09/06/Go-Module%E6%95%99%E7%A8%8B%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E9%95%9C%E5%83%8F%E3%80%81%E6%A0%A1%E9%AA%8C%E5%92%8C%E4%BB%A5%E5%8F%8AAthens/"/>
    <id>https://riddlego.github.io/2021/09/06/Go-Module%E6%95%99%E7%A8%8B%E7%AC%AC4%E9%83%A8%E5%88%86%EF%BC%9A%E9%95%9C%E5%83%8F%E3%80%81%E6%A0%A1%E9%AA%8C%E5%92%8C%E4%BB%A5%E5%8F%8AAthens/</id>
    <published>2021-09-06T15:08:16.000Z</published>
    <updated>2021-09-06T15:09:47.371Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/b1mTUOKCs-L9Tt9TdzJpQw">Go Module 教程第 4 部分：镜像、校验和以及 Athens</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/b1mTUOKCs-L9Tt9TdzJpQw&quot;&gt;Go Module 教程第 4 部分：镜像、校验和以及 Athens&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang-More" scheme="https://riddlego.github.io/categories/golang-More/"/>
    
    <category term="Go-Modules" scheme="https://riddlego.github.io/categories/golang-More/Go-Modules/"/>
    
    
    <category term="Go-Modules" scheme="https://riddlego.github.io/tags/Go-Modules/"/>
    
  </entry>
  
  <entry>
    <title>我开始怀疑</title>
    <link href="https://riddlego.github.io/2021/09/05/%E6%88%91%E5%BC%80%E5%A7%8B%E6%80%80%E7%96%91/"/>
    <id>https://riddlego.github.io/2021/09/05/%E6%88%91%E5%BC%80%E5%A7%8B%E6%80%80%E7%96%91/</id>
    <published>2021-09-05T11:21:09.000Z</published>
    <updated>2021-09-05T12:54:32.812Z</updated>
    
    <content type="html"><![CDATA[<p>自己发现自己有个不好的毛病就是一遇到很多的事情就会不知道做什么，或者是什么都想做，最近的事情又开始了，超级麻烦。</p><p>等着做一个数据分析软件，自己的头绪不是很多。</p><p>今天在知乎看见了一个前辈说的很有道理的话<br><a href="https://www.zhihu.com/question/356351510/answer/913928066?utm_source=wechat_session&utm_medium=social&utm_oi=948690773714153472&utm_content=group3_Answer&utm_campaign=shareopn">原文链接</a></p><p>可惜不能转载</p><p>其实也算是把路越走越窄，不断地做出了选择，其实也有想过去尝试更多地东西，不知道这条路到底是否适合自己，但是既然走上了这条路就必须得不停的走下去，其实糟老头子也说的不错，自己在学习方面很多的时候还是少了那个刨根究底，一个一个搞清楚的精神，但是他给我布置了那么多事情，什么都想我去做，就离谱。所以啊，不能太靠谱，要装作积极想做但是不靠谱的样子。</p><p>哈哈 瞎吐槽了几句</p><p>最近这段时间要好好在九月份内把数据分析的软件做出来，这个是当务之急，虽然别的地方也在催我，但是还是踏实的完成这个事情，如果不负责任，没有担当一次，那么在以后的工作中就会更加越来越不负责，何况这还是第一份实习，一定要搞出点样子。</p><p>整个还是需要好好计划每一步，分清楚模块，每个模块单独的功能实现，逻辑关系什么的都是需要慢慢的弄。</p><p>我想永远不要着急，其实当然几个方向都在需要你，想让你去做一些事情，确实很烦，这个周末弄什么效率好差，我超级不喜欢自己沉浸不进去的样子，哈哈哈，我时常怀疑这是不是因为没有女朋友的原因。</p><p>这些年学东西走的太着急，都是项目驱动，但是因为什么都不会，所以一个一个都是不靠谱，照着别人的咀嚼过的东西涂涂修修改改，这样自己一点思路没有，虽然最后到最后是学习了点东西，完成了点项目，也发了论文，可是真正的技术含量还是很浅薄，这样想起来我倒是蛮假大空，自己敲代码的能力还是太弱了，持续性也不强，以后还要吃这碗饭，离谱。</p><p>数据库是基本上不怎么会的，实习完弄zigbee和wifi的时候，也要好好学习一下混熟数据库，其实SQL这个语句还是很有学问。</p><p>下一步要加强自己的代码量，要独立去思考做一些东西，同时要好好捡回来自己的英语了，发现自己的英语好久没有开始阅读了，到时候就多看看英语的文档，现在养成习惯真的是一看见英语就习惯性的翻译，这样对自己的成长是不好的。</p><p>原创的文字的输出是永远不能没有的，输出来自己学到的加上自己思想的新东西。</p><p>源码就是追根究底，汇编好像其实也需要看，内部的逻辑，底层的代码走向真的好重要的，好了感觉自己给自己挖了好多坑，还不知道自己能去哪个公司，阿西，忧愁啊，感觉什么方向都是自己想做的事。</p><p>我超级反感自己这样的浅薄技术，拉的这么广，羡慕那些一个确定方向的人，羡慕啊。那些老早就知道自己的热爱，羡慕那些有自己爱好的。</p><p>这样想起来，这么多年，仿佛从来没有自己主动去选择什么都是被选择，没有多余的路走，按部就班，没有主动的奔赴哪个方向。当然现在找工作也是，被动，真尼玛被动，我讨厌，又不知道，又害怕去选择去想，我像是许三多，比16集之前的他好一点，比后面的要差得多，我特么也应该钻个牛角尖的，可是啊，我特么离南墙还有老远就戴着望远镜看见墙以后就屁颠屁颠换了个方向，所以没有撞到过，所以就这么的普通，普通。</p><p>算了，特么的，我这么多年也是浪费了很多的时间，错过了很多的人，做错了很多事，喝多很多的酒，抽了很多的烟，也算是个一事无成，时常自卑，偶尔觉得还行，不行就得劲安慰自己。</p><p>命运在后面催促像我这样的人走快点，走慢了就在屁股后面给你一脚。不小心你还摔个跟头，你当然可以选择就顺势躺下，最好是趴着的姿势，这样后面来的人踩着你，疼归疼，但是看不到你的脸，不会伤面子，除了熟人其他人根本不认识你。但是啊，有时候虽然知道自己普通，但是也是一个想被关注的衰小孩，所以啊就爬起来，拍了拍灰，觉得再走两步看看。</p><p>这往后的事情很难说的清楚，第一个阶段是迷茫的时候也不要停下脚步，下一个阶段就是做出了选择等碰到了南墙再说，前进的路上也得好好反思自己的路途方向。</p><p>抽支烟看三道题，明天继续上班。</p><p>学习需要看书，不要急于求成，现在的blog和视频成体系的很少，指不定还有错误。看书是最好的方式，而成体系的知识就是我所匮乏的。</p><p>遇到问题有条件的话尽量自己翻译，help用起来。</p><p>主动寻找论文，进行翻译，很多先近的技术就是源自大牛论文，接触前沿，也丰富自己英语。</p><p>求真</p><p>求实</p><p><strong>因为，但凡通过点滴付出，累积出来的结果，都是平淡无声的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己发现自己有个不好的毛病就是一遇到很多的事情就会不知道做什么，或者是什么都想做，最近的事情又开始了，超级麻烦。&lt;/p&gt;
&lt;p&gt;等着做一个数据分析软件，自己的头绪不是很多。&lt;/p&gt;
&lt;p&gt;今天在知乎看见了一个前辈说的很有道理的话&lt;br&gt;&lt;a href=&quot;https://ww</summary>
      
    
    
    
    <category term="猛男日记" scheme="https://riddlego.github.io/categories/%E7%8C%9B%E7%94%B7%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>每天一道算法题：高效调整数组数值顺序---在O（1）时间内删除单链表结点--反转单链表</title>
    <link href="https://riddlego.github.io/2021/09/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E9%AB%98%E6%95%88%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F---%E5%9C%A8O%EF%BC%881%EF%BC%89%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9--%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://riddlego.github.io/2021/09/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E9%AB%98%E6%95%88%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F---%E5%9C%A8O%EF%BC%881%EF%BC%89%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9--%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2021-09-05T11:17:04.000Z</published>
    <updated>2021-09-05T11:19:40.197Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fX2WN-r8GgvFAg46svZzfw">Go 常见算法面试题篇（一）：反转单链表</a></p><p><a href="https://mp.weixin.qq.com/s/ECLJnmkRvXAUeITdyusdMQ">Go 常见算法面试题篇（二）：在 O(1) 时间内删除单链表结点</a></p><p><a href="https://mp.weixin.qq.com/s/bHxEk0ONwk4MhE58DT0F-g">Go 常见算法面试题篇（三）：高效调整数组数值顺序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fX2WN-r8GgvFAg46svZzfw&quot;&gt;Go 常见算法面试题篇（一）：反转单链表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ECLJnmkRv</summary>
      
    
    
    
    <category term="牛客热题132" scheme="https://riddlego.github.io/categories/%E7%89%9B%E5%AE%A2%E7%83%AD%E9%A2%98132/"/>
    
    
  </entry>
  
</feed>
